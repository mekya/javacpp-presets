// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.zixi.global;

import org.bytedeco.zixi.feeder.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class feeder extends org.bytedeco.zixi.presets.zixiFeeder {
    static { Loader.load(); }

// Parsed from sys/_types/_iovec_t.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_IOVEC
// #define _STRUCT_IOVEC
// #include <sys/_types/_size_t.h>
// Targeting ../feeder/iovec.java


// #endif /* _STRUCT_IOVEC */


// Parsed from sys/socket.h

/*
 * Copyright (c) 2000-2019 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
 */
/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */

// #ifndef _SYS_SOCKET_H_
// #define _SYS_SOCKET_H_

// #include <sys/types.h>
// #include <sys/cdefs.h>
// #include <machine/_param.h>
// #include <net/net_kev.h>



// #include <Availability.h>

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Data types.
 */

// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sa_family_t.h>
// #include <sys/_types/_socklen_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_size_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_ssize_t.h>

/*
 * [XSI] The iovec structure shall be defined as described in <sys/uio.h>.
 */
// #include <sys/_types/_iovec_t.h>

/*
 * Types
 */
public static final int SOCK_STREAM =     1;               /* stream socket */
public static final int SOCK_DGRAM =      2;               /* datagram socket */
public static final int SOCK_RAW =        3;               /* raw-protocol interface */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_RDM =        4;               /* reliably-delivered message */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SOCK_SEQPACKET =  5;               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
public static final int SO_DEBUG =        0x0001;          /* turn on debugging info recording */
public static final int SO_ACCEPTCONN =   0x0002;          /* socket has had listen() */
public static final int SO_REUSEADDR =    0x0004;          /* allow local address reuse */
public static final int SO_KEEPALIVE =    0x0008;          /* keep connections alive */
public static final int SO_DONTROUTE =    0x0010;          /* just use interface addresses */
public static final int SO_BROADCAST =    0x0020;          /* permit sending of broadcast msgs */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_USELOOPBACK =  0x0040;          /* bypass hardware when possible */
public static final int SO_LINGER =       0x0080;          /* linger on close if data present (in ticks) */
// #else
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SO_OOBINLINE =    0x0100;          /* leave received OOB data in line */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_REUSEPORT =    0x0200;          /* allow local address & port reuse */
public static final int SO_TIMESTAMP =    0x0400;          /* timestamp received dgram traffic */
public static final int SO_TIMESTAMP_MONOTONIC =  0x0800;  /* Monotonically increasing timestamp on rcvd dgram */
// #ifndef __APPLE__
// #else
public static final int SO_DONTTRUNC =    0x2000;          /* APPLE: Retain unread data */
                                        /*  (ATOMIC proto) */
public static final int SO_WANTMORE =     0x4000;          /* APPLE: Give hint when more data ready */
public static final int SO_WANTOOBFLAG =  0x8000;          /* APPLE: Want OOB in MSG_FLAG on receive */


// #endif  /* (!__APPLE__) */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Additional options, not kept in so_options.
 */
public static final int SO_SNDBUF =       0x1001;          /* send buffer size */
public static final int SO_RCVBUF =       0x1002;          /* receive buffer size */
public static final int SO_SNDLOWAT =     0x1003;          /* send low-water mark */
public static final int SO_RCVLOWAT =     0x1004;          /* receive low-water mark */
public static final int SO_SNDTIMEO =     0x1005;          /* send timeout */
public static final int SO_RCVTIMEO =     0x1006;          /* receive timeout */
public static final int SO_ERROR =        0x1007;          /* get error status and clear */
public static final int SO_TYPE =         0x1008;          /* get socket type */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_LABEL =        0x1010;          /* deprecated */
public static final int SO_PEERLABEL =    0x1011;          /* deprecated */
// #ifdef __APPLE__
public static final int SO_NREAD =        0x1020;          /* APPLE: get 1st-packet byte count */
public static final int SO_NKE =          0x1021;          /* APPLE: Install socket-level NKE */
public static final int SO_NOSIGPIPE =    0x1022;          /* APPLE: No SIGPIPE on EPIPE */
public static final int SO_NOADDRERR =    0x1023;          /* APPLE: Returns EADDRNOTAVAIL when src is not available anymore */
public static final int SO_NWRITE =       0x1024;          /* APPLE: Get number of bytes currently in send socket buffer */
public static final int SO_REUSESHAREUID =        0x1025;          /* APPLE: Allow reuse of port/socket by different userids */
// #ifdef __APPLE_API_PRIVATE
public static final int SO_NOTIFYCONFLICT =       0x1026;  /* APPLE: send notification if there is a bind on a port which is already in use */
public static final int SO_UPCALLCLOSEWAIT =      0x1027;  /* APPLE: block on close until an upcall returns */
// #endif
public static final int SO_LINGER_SEC =   0x1080;          /* linger on close if data present (in seconds) */
public static final int SO_RANDOMPORT =   0x1082;  /* APPLE: request local port randomization */
public static final int SO_NP_EXTENSIONS =        0x1083;  /* To turn off some POSIX behavior */
// #endif

public static final int SO_NUMRCVPKT =            0x1112;  /* number of datagrams in receive socket buffer */
public static final int SO_NET_SERVICE_TYPE =     0x1116;  /* Network service type */


public static final int SO_NETSVC_MARKING_LEVEL =    0x1119;  /* Get QoS marking in effect for socket */


/* When adding new socket-options, you need to make sure MPTCP supports these as well! */

/*
 * Network Service Type for option SO_NET_SERVICE_TYPE
 *
 * The vast majority of sockets should use Best Effort that is the default
 * Network Service Type. Other Network Service Types have to be used only if
 * the traffic actually matches the description of the Network Service Type.
 *
 * Network Service Types do not represent priorities but rather describe
 * different categories of delay, jitter and loss parameters.
 * Those parameters may influence protocols from layer 4 protocols like TCP
 * to layer 2 protocols like Wi-Fi. The Network Service Type can determine
 * how the traffic is queued and scheduled by the host networking stack and
 * by other entities on the network like switches and routers. For example
 * for Wi-Fi, the Network Service Type can select the marking of the
 * layer 2 packet with the appropriate WMM Access Category.
 *
 * There is no point in attempting to game the system and use
 * a Network Service Type that does not correspond to the actual
 * traffic characteristic but one that seems to have a higher precedence.
 * The reason is that for service classes that have lower tolerance
 * for delay and jitter, the queues size is lower than for service
 * classes that are more tolerant to delay and jitter.
 *
 * For example using a voice service type for bulk data transfer will lead
 * to disastrous results as soon as congestion happens because the voice
 * queue overflows and packets get dropped. This is not only bad for the bulk
 * data transfer but it is also bad for VoIP apps that legitimately are using
 * the voice  service type.
 *
 * The characteristics of the Network Service Types are based on the service
 * classes defined in RFC 4594 "Configuration Guidelines for DiffServ Service
 * Classes"
 *
 * When system detects the outgoing interface belongs to a DiffServ domain
 * that follows the recommendation of the IETF draft "Guidelines for DiffServ to
 * IEEE 802.11 Mapping", the packet will marked at layer 3 with a DSCP value
 * that corresponds to Network Service Type.
 *
 * NET_SERVICE_TYPE_BE
 *	"Best Effort", unclassified/standard.  This is the default service
 *	class and cover the majority of the traffic.
 *
 * NET_SERVICE_TYPE_BK
 *	"Background", high delay tolerant, loss tolerant. elastic flow,
 *	variable size & long-lived. E.g: non-interactive network bulk transfer
 *	like synching or backup.
 *
 * NET_SERVICE_TYPE_RD
 *	"Responsive Data", a notch higher than "Best Effort", medium delay
 *	tolerant, elastic & inelastic flow, bursty, long-lived. E.g. email,
 *	instant messaging, for which there is a sense of interactivity and
 *	urgency (user waiting for output).
 *
 * NET_SERVICE_TYPE_OAM
 *	"Operations, Administration, and Management", medium delay tolerant,
 *	low-medium loss tolerant, elastic & inelastic flows, variable size.
 *	E.g. VPN tunnels.
 *
 * NET_SERVICE_TYPE_AV
 *	"Multimedia Audio/Video Streaming", medium delay tolerant, low-medium
 *	loss tolerant, elastic flow, constant packet interval, variable rate
 *	and size. E.g. video and audio playback with buffering.
 *
 * NET_SERVICE_TYPE_RV
 *	"Responsive Multimedia Audio/Video", low delay tolerant, low-medium
 *	loss tolerant, elastic flow, variable packet interval, rate and size.
 *	E.g. screen sharing.
 *
 * NET_SERVICE_TYPE_VI
 *	"Interactive Video", low delay tolerant, low-medium loss tolerant,
 *	elastic flow, constant packet interval, variable rate & size. E.g.
 *	video telephony.
 *
 * NET_SERVICE_TYPE_SIG
 *	"Signaling", low delay tolerant, low loss tolerant, inelastic flow,
 *	jitter tolerant, rate is bursty but short, variable size. E.g. SIP.
 *
 * NET_SERVICE_TYPE_VO
 *	"Interactive Voice", very low delay tolerant, very low loss tolerant,
 *	inelastic flow, constant packet rate, somewhat fixed size.
 *	E.g. VoIP.
 */

public static final int NET_SERVICE_TYPE_BE =     0; /* Best effort */
public static final int NET_SERVICE_TYPE_BK =     1; /* Background system initiated */
public static final int NET_SERVICE_TYPE_SIG =    2; /* Signaling */
public static final int NET_SERVICE_TYPE_VI =     3; /* Interactive Video */
public static final int NET_SERVICE_TYPE_VO =     4; /* Interactive Voice */
public static final int NET_SERVICE_TYPE_RV =     5; /* Responsive Multimedia Audio/Video */
public static final int NET_SERVICE_TYPE_AV =     6; /* Multimedia Audio/Video Streaming */
public static final int NET_SERVICE_TYPE_OAM =    7; /* Operations, Administration, and Management */
public static final int NET_SERVICE_TYPE_RD =     8; /* Responsive Data */


/* These are supported values for SO_NETSVC_MARKING_LEVEL */
public static final int NETSVC_MRKNG_UNKNOWN =            0;       /* The outgoing network interface is not known */
public static final int NETSVC_MRKNG_LVL_L2 =             1;       /* Default marking at layer 2 (for example Wi-Fi WMM) */
public static final int NETSVC_MRKNG_LVL_L3L2_ALL =       2;       /* Layer 3 DSCP marking and layer 2 marking for all Network Service Types */
public static final int NETSVC_MRKNG_LVL_L3L2_BK =        3;       /* The system policy limits layer 3 DSCP marking and layer 2 marking
	                                         * to background Network Service Types */
public static final int SAE_ASSOCID_ANY = 0;
// #define SAE_ASSOCID_ALL ((sae_associd_t)(-1L))
public static final int SAE_CONNID_ANY =  0;
// #define SAE_CONNID_ALL  ((sae_connid_t)(-1L))

/* connectx() flag parameters */
public static final int CONNECT_RESUME_ON_READ_WRITE =    0x1; /* resume connect() on read/write */
public static final int CONNECT_DATA_IDEMPOTENT =         0x2; /* data is idempotent */
public static final int CONNECT_DATA_AUTHENTICATED =      0x4;
// Targeting ../feeder/sa_endpoints_t.java


// Targeting ../feeder/linger.java


// Targeting ../feeder/so_np_extensions.java



public static final int SONPX_SETOPTSHUT =        0x000000001;     /* flag for allowing setsockopt after shutdown */



// #endif
// #endif

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
public static final int SOL_SOCKET =      0xffff;          /* options for socket level */


/*
 * Address families.
 */
public static final int AF_UNSPEC =       0;               /* unspecified */
public static final int AF_UNIX =         1;               /* local to host (pipes) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_LOCAL =        AF_UNIX;         /* backward compatibility */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET =         2;               /* internetwork: UDP, TCP, etc. */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_IMPLINK =      3;               /* arpanet imp addresses */
public static final int AF_PUP =          4;               /* pup protocols: e.g. BSP */
public static final int AF_CHAOS =        5;               /* mit CHAOS protocols */
public static final int AF_NS =           6;               /* XEROX NS protocols */
public static final int AF_ISO =          7;               /* ISO protocols */
public static final int AF_OSI =          AF_ISO;
public static final int AF_ECMA =         8;               /* European computer manufacturers */
public static final int AF_DATAKIT =      9;               /* datakit protocols */
public static final int AF_CCITT =        10;              /* CCITT protocols, X.25 etc */
public static final int AF_SNA =          11;              /* IBM SNA */
public static final int AF_DECnet =       12;              /* DECnet */
public static final int AF_DLI =          13;              /* DEC Direct data link interface */
public static final int AF_LAT =          14;              /* LAT */
public static final int AF_HYLINK =       15;              /* NSC Hyperchannel */
public static final int AF_APPLETALK =    16;              /* Apple Talk */
public static final int AF_ROUTE =        17;              /* Internal Routing Protocol */
public static final int AF_LINK =         18;              /* Link layer interface */
public static final int pseudo_AF_XTP =   19;              /* eXpress Transfer Protocol (no AF) */
public static final int AF_COIP =         20;              /* connection-oriented IP, aka ST II */
public static final int AF_CNT =          21;              /* Computer Network Technology */
public static final int pseudo_AF_RTIP =  22;              /* Help Identify RTIP packets */
public static final int AF_IPX =          23;              /* Novell Internet Protocol */
public static final int AF_SIP =          24;              /* Simple Internet Protocol */
public static final int pseudo_AF_PIP =   25;              /* Help Identify PIP packets */
public static final int AF_NDRV =         27;              /* Network Driver 'raw' access */
public static final int AF_ISDN =         28;              /* Integrated Services Digital Network */
public static final int AF_E164 =         AF_ISDN;         /* CCITT E.164 recommendation */
public static final int pseudo_AF_KEY =   29;              /* Internal key-management function */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET6 =        30;              /* IPv6 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_NATM =         31;              /* native ATM access */
public static final int AF_SYSTEM =       32;              /* Kernel event messages */
public static final int AF_NETBIOS =      33;              /* NetBIOS */
public static final int AF_PPP =          34;              /* PPP communication protocol */
public static final int pseudo_AF_HDRCMPLT = 35;           /* Used by BPF to not rewrite headers
	                                 *  in interface output routine */
public static final int AF_RESERVED_36 =  36;              /* Reserved for internal usage */
public static final int AF_IEEE80211 =    37;              /* IEEE 802.11 protocol */
public static final int AF_UTUN =         38;
public static final int AF_VSOCK =        40;              /* VM Sockets */
public static final int AF_MAX =          41;
// Targeting ../feeder/sockaddr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_MAXADDRLEN = 255;
// Targeting ../feeder/sockproto.java


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
public static final int _SS_MAXSIZE =     128;
public static native @MemberGetter int _SS_ALIGNSIZE();
public static final int _SS_ALIGNSIZE = _SS_ALIGNSIZE();
public static native @MemberGetter int _SS_PAD1SIZE();
public static final int _SS_PAD1SIZE = _SS_PAD1SIZE();
public static native @MemberGetter int _SS_PAD2SIZE();
public static final int _SS_PAD2SIZE = _SS_PAD2SIZE();
// Targeting ../feeder/sockaddr_storage.java



/*
 * Protocol families, same as address families for now.
 */
public static final int PF_UNSPEC =       AF_UNSPEC;
public static final int PF_LOCAL =        AF_LOCAL;
public static final int PF_UNIX =         PF_LOCAL;        /* backward compatibility */
public static final int PF_INET =         AF_INET;
public static final int PF_IMPLINK =      AF_IMPLINK;
public static final int PF_PUP =          AF_PUP;
public static final int PF_CHAOS =        AF_CHAOS;
public static final int PF_NS =           AF_NS;
public static final int PF_ISO =          AF_ISO;
public static final int PF_OSI =          AF_ISO;
public static final int PF_ECMA =         AF_ECMA;
public static final int PF_DATAKIT =      AF_DATAKIT;
public static final int PF_CCITT =        AF_CCITT;
public static final int PF_SNA =          AF_SNA;
public static final int PF_DECnet =       AF_DECnet;
public static final int PF_DLI =          AF_DLI;
public static final int PF_LAT =          AF_LAT;
public static final int PF_HYLINK =       AF_HYLINK;
public static final int PF_APPLETALK =    AF_APPLETALK;
public static final int PF_ROUTE =        AF_ROUTE;
public static final int PF_LINK =         AF_LINK;
public static final int PF_XTP =          pseudo_AF_XTP;   /* really just proto family, no AF */
public static final int PF_COIP =         AF_COIP;
public static final int PF_CNT =          AF_CNT;
public static final int PF_SIP =          AF_SIP;
public static final int PF_IPX =          AF_IPX;          /* same format as AF_NS */
public static final int PF_RTIP =         pseudo_AF_RTIP;  /* same format as AF_INET */
public static final int PF_PIP =          pseudo_AF_PIP;
public static final int PF_NDRV =         AF_NDRV;
public static final int PF_ISDN =         AF_ISDN;
public static final int PF_KEY =          pseudo_AF_KEY;
public static final int PF_INET6 =        AF_INET6;
public static final int PF_NATM =         AF_NATM;
public static final int PF_SYSTEM =       AF_SYSTEM;
public static final int PF_NETBIOS =      AF_NETBIOS;
public static final int PF_PPP =          AF_PPP;
public static final int PF_RESERVED_36 =  AF_RESERVED_36;
public static final int PF_UTUN =         AF_UTUN;
public static final int PF_VSOCK =        AF_VSOCK;
public static final int PF_MAX =          AF_MAX;

/*
 * These do not have socket-layer support:
 */
public static final int PF_VLAN =         ((int)0x766c616e);  /* 'vlan' */
public static final int PF_BOND =         ((int)0x626f6e64);  /* 'bond' */

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int NET_MAXID =       AF_MAX;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 */
public static final int NET_RT_DUMP =             1;       /* dump; may limit to a.f. */
public static final int NET_RT_FLAGS =            2;       /* by flags, e.g. RESOLVING */
public static final int NET_RT_IFLIST =           3;       /* survey interface list */
public static final int NET_RT_STAT =             4;       /* routing statistics */
public static final int NET_RT_TRASH =            5;       /* routes not in table but not freed */
public static final int NET_RT_IFLIST2 =          6;       /* interface list with addresses */
public static final int NET_RT_DUMP2 =            7;       /* dump; may limit to a.f. */
/*
 * Allows read access non-local host's MAC address
 * if the process has neighbor cache entitlement.
 */
public static final int NET_RT_FLAGS_PRIV =       10;
public static final int NET_RT_MAXID =            11;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */




/*
 * Maximum queue length specifiable by listen.
 */
public static final int SOMAXCONN =       128;
// Targeting ../feeder/msghdr.java





public static final int MSG_OOB =         0x1;             /* process out-of-band data */
public static final int MSG_PEEK =        0x2;             /* peek at incoming message */
public static final int MSG_DONTROUTE =   0x4;             /* send without using routing tables */
public static final int MSG_EOR =         0x8;             /* data completes record */
public static final int MSG_TRUNC =       0x10;            /* data discarded before delivery */
public static final int MSG_CTRUNC =      0x20;            /* control data lost before delivery */
public static final int MSG_WAITALL =     0x40;            /* wait for full request or error */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int MSG_DONTWAIT =    0x80;            /* this message should be nonblocking */
public static final int MSG_EOF =         0x100;           /* data completes connection */
// #ifdef __APPLE__
// #ifdef __APPLE_API_OBSOLETE
public static final int MSG_WAITSTREAM =  0x200;           /* wait up to full request.. may return partial */
// #endif
public static final int MSG_FLUSH =       0x400;           /* Start of 'hold' seq; dump so_temp, deprecated */
public static final int MSG_HOLD =        0x800;           /* Hold frag in so_temp, deprecated */
public static final int MSG_SEND =        0x1000;          /* Send the packet in so_temp, deprecated */
public static final int MSG_HAVEMORE =    0x2000;          /* Data ready to be read */
public static final int MSG_RCVMORE =     0x4000;          /* Data remains in current pkt */
// #endif
public static final int MSG_NEEDSA =      0x10000;         /* Fail receive if socket address cannot be allocated */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #if __DARWIN_C_LEVEL >= 200809L
public static final int MSG_NOSIGNAL =    0x80000;
// Targeting ../feeder/cmsghdr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #ifndef __APPLE__
// #endif
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* given pointer to struct cmsghdr, return pointer to data */
// #define CMSG_DATA(cmsg)         ((unsigned char *)(cmsg) +
// 	__DARWIN_ALIGN32(sizeof(struct cmsghdr)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
// #define CMSG_FIRSTHDR(mhdr)
// 	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ?
// 	    (struct cmsghdr *)(mhdr)->msg_control :
// 	    (struct cmsghdr *)0L)


/*
 * Given pointer to struct cmsghdr, return pointer to next cmsghdr
 * RFC 2292 says that CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr)
 */
// #define CMSG_NXTHDR(mhdr, cmsg)
// 	((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) :
// 	    ((((unsigned char *)(cmsg) +
// 	    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) +
// 	    __DARWIN_ALIGN32(sizeof(struct cmsghdr))) >
// 	    ((unsigned char *)(mhdr)->msg_control +
// 	    (mhdr)->msg_controllen)) ?
// 	        (struct cmsghdr *)0L /* NULL */ :
// 	        (struct cmsghdr *)(void *)((unsigned char *)(cmsg) +
// 	            __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/* RFC 2292 additions */
// #define CMSG_SPACE(l)           (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(l))
// #define CMSG_LEN(l)             (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (l))

// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* "Socket"-level control message types: */
public static final int SCM_RIGHTS =                      0x01;    /* access rights (array of int) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SCM_TIMESTAMP =                   0x02;    /* timestamp (struct timeval) */
public static final int SCM_CREDS =                       0x03;    /* process creds (struct cmsgcred) */
public static final int SCM_TIMESTAMP_MONOTONIC =         0x04;    /* timestamp (uint64_t) */


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * howto arguments for shutdown(2), specified by Posix.1g.
 */
public static final int SHUT_RD =         0;               /* shut down the reading side */
public static final int SHUT_WR =         1;               /* shut down the writing side */
public static final int SHUT_RDWR =       2;
// Targeting ../feeder/sf_hdtr.java




// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */




// #endif /* !_SYS_SOCKET_H_ */


// Parsed from netinet/in.h

/*
 * Copyright (c) 2000-2018 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/in.h,v 1.48.2.2 2001/04/21 14:53:06 ume Exp $
 */

// #ifndef _NETINET_IN_H_
// #define _NETINET_IN_H_

// #include <sys/appleapiopts.h>
// #include <stdint.h>             /* uint(8|16|32)_t */

// #include <Availability.h>


// #include <sys/_types/_in_addr_t.h>
// #include <sys/_types/_in_port_t.h>

/*
 * POSIX 1003.1-2003
 * "Inclusion of the <netinet/in.h> header may also make visible all
 *  symbols from <inttypes.h> and <sys/socket.h>".
 */
// #include <sys/socket.h>

/*
 * The following two #includes insure htonl and family are defined
 */
// #include <machine/endian.h>
// #include <sys/_endian.h>

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, and numerous additions.
 */

/*
 * Protocols (RFC 1700)
 */
public static final int IPPROTO_IP =              0;               /* dummy for IP */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_HOPOPTS = 0;               /* IP6 hop-by-hop options */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_ICMP =            1;               /* control message protocol */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_IGMP =            2;               /* group mgmt protocol */
public static final int IPPROTO_GGP =             3;               /* gateway^2 (deprecated) */
public static final int IPPROTO_IPV4 =            4;               /* IPv4 encapsulation */
public static final int IPPROTO_IPIP =            IPPROTO_IPV4;    /* for compatibility */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_TCP =             6;               /* tcp */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_ST =              7;               /* Stream protocol II */
public static final int IPPROTO_EGP =             8;               /* exterior gateway protocol */
public static final int IPPROTO_PIGP =            9;               /* private interior gateway */
public static final int IPPROTO_RCCMON =          10;              /* BBN RCC Monitoring */
public static final int IPPROTO_NVPII =           11;              /* network voice protocol*/
public static final int IPPROTO_PUP =             12;              /* pup */
public static final int IPPROTO_ARGUS =           13;              /* Argus */
public static final int IPPROTO_EMCON =           14;              /* EMCON */
public static final int IPPROTO_XNET =            15;              /* Cross Net Debugger */
public static final int IPPROTO_CHAOS =           16;              /* Chaos*/
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_UDP =             17;              /* user datagram protocol */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_MUX =             18;              /* Multiplexing */
public static final int IPPROTO_MEAS =            19;              /* DCN Measurement Subsystems */
public static final int IPPROTO_HMP =             20;              /* Host Monitoring */
public static final int IPPROTO_PRM =             21;              /* Packet Radio Measurement */
public static final int IPPROTO_IDP =             22;              /* xns idp */
public static final int IPPROTO_TRUNK1 =          23;              /* Trunk-1 */
public static final int IPPROTO_TRUNK2 =          24;              /* Trunk-2 */
public static final int IPPROTO_LEAF1 =           25;              /* Leaf-1 */
public static final int IPPROTO_LEAF2 =           26;              /* Leaf-2 */
public static final int IPPROTO_RDP =             27;              /* Reliable Data */
public static final int IPPROTO_IRTP =            28;              /* Reliable Transaction */
public static final int IPPROTO_TP =              29;              /* tp-4 w/ class negotiation */
public static final int IPPROTO_BLT =             30;              /* Bulk Data Transfer */
public static final int IPPROTO_NSP =             31;              /* Network Services */
public static final int IPPROTO_INP =             32;              /* Merit Internodal */
public static final int IPPROTO_SEP =             33;              /* Sequential Exchange */
public static final int IPPROTO_3PC =             34;              /* Third Party Connect */
public static final int IPPROTO_IDPR =            35;              /* InterDomain Policy Routing */
public static final int IPPROTO_XTP =             36;              /* XTP */
public static final int IPPROTO_DDP =             37;              /* Datagram Delivery */
public static final int IPPROTO_CMTP =            38;              /* Control Message Transport */
public static final int IPPROTO_TPXX =            39;              /* TP++ Transport */
public static final int IPPROTO_IL =              40;              /* IL transport protocol */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_IPV6 =            41;              /* IP6 header */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_SDRP =            42;              /* Source Demand Routing */
public static final int IPPROTO_ROUTING = 43;              /* IP6 routing header */
public static final int IPPROTO_FRAGMENT =        44;              /* IP6 fragmentation header */
public static final int IPPROTO_IDRP =            45;              /* InterDomain Routing*/
public static final int IPPROTO_RSVP =            46;              /* resource reservation */
public static final int IPPROTO_GRE =             47;              /* General Routing Encap. */
public static final int IPPROTO_MHRP =            48;              /* Mobile Host Routing */
public static final int IPPROTO_BHA =             49;              /* BHA */
public static final int IPPROTO_ESP =             50;              /* IP6 Encap Sec. Payload */
public static final int IPPROTO_AH =              51;              /* IP6 Auth Header */
public static final int IPPROTO_INLSP =           52;              /* Integ. Net Layer Security */
public static final int IPPROTO_SWIPE =           53;              /* IP with encryption */
public static final int IPPROTO_NHRP =            54;              /* Next Hop Resolution */
/* 55-57: Unassigned */
public static final int IPPROTO_ICMPV6 =          58;              /* ICMP6 */
public static final int IPPROTO_NONE =            59;              /* IP6 no next header */
public static final int IPPROTO_DSTOPTS =         60;              /* IP6 destination option */
public static final int IPPROTO_AHIP =            61;              /* any host internal protocol */
public static final int IPPROTO_CFTP =            62;              /* CFTP */
public static final int IPPROTO_HELLO =           63;              /* "hello" routing protocol */
public static final int IPPROTO_SATEXPAK =        64;              /* SATNET/Backroom EXPAK */
public static final int IPPROTO_KRYPTOLAN =       65;              /* Kryptolan */
public static final int IPPROTO_RVD =             66;              /* Remote Virtual Disk */
public static final int IPPROTO_IPPC =            67;              /* Pluribus Packet Core */
public static final int IPPROTO_ADFS =            68;              /* Any distributed FS */
public static final int IPPROTO_SATMON =          69;              /* Satnet Monitoring */
public static final int IPPROTO_VISA =            70;              /* VISA Protocol */
public static final int IPPROTO_IPCV =            71;              /* Packet Core Utility */
public static final int IPPROTO_CPNX =            72;              /* Comp. Prot. Net. Executive */
public static final int IPPROTO_CPHB =            73;              /* Comp. Prot. HeartBeat */
public static final int IPPROTO_WSN =             74;              /* Wang Span Network */
public static final int IPPROTO_PVP =             75;              /* Packet Video Protocol */
public static final int IPPROTO_BRSATMON =        76;              /* BackRoom SATNET Monitoring */
public static final int IPPROTO_ND =              77;              /* Sun net disk proto (temp.) */
public static final int IPPROTO_WBMON =           78;              /* WIDEBAND Monitoring */
public static final int IPPROTO_WBEXPAK =         79;              /* WIDEBAND EXPAK */
public static final int IPPROTO_EON =             80;              /* ISO cnlp */
public static final int IPPROTO_VMTP =            81;              /* VMTP */
public static final int IPPROTO_SVMTP =           82;              /* Secure VMTP */
public static final int IPPROTO_VINES =           83;              /* Banyon VINES */
public static final int IPPROTO_TTP =             84;              /* TTP */
public static final int IPPROTO_IGP =             85;              /* NSFNET-IGP */
public static final int IPPROTO_DGP =             86;              /* dissimilar gateway prot. */
public static final int IPPROTO_TCF =             87;              /* TCF */
public static final int IPPROTO_IGRP =            88;              /* Cisco/GXS IGRP */
public static final int IPPROTO_OSPFIGP =         89;              /* OSPFIGP */
public static final int IPPROTO_SRPC =            90;              /* Strite RPC protocol */
public static final int IPPROTO_LARP =            91;              /* Locus Address Resoloution */
public static final int IPPROTO_MTP =             92;              /* Multicast Transport */
public static final int IPPROTO_AX25 =            93;              /* AX.25 Frames */
public static final int IPPROTO_IPEIP =           94;              /* IP encapsulated in IP */
public static final int IPPROTO_MICP =            95;              /* Mobile Int.ing control */
public static final int IPPROTO_SCCSP =           96;              /* Semaphore Comm. security */
public static final int IPPROTO_ETHERIP =         97;              /* Ethernet IP encapsulation */
public static final int IPPROTO_ENCAP =           98;              /* encapsulation header */
public static final int IPPROTO_APES =            99;              /* any private encr. scheme */
public static final int IPPROTO_GMTP =            100;             /* GMTP*/
/* 101-252: Partly Unassigned */
public static final int IPPROTO_PIM =             103;             /* Protocol Independent Mcast */
public static final int IPPROTO_IPCOMP =          108;             /* payload compression (IPComp) */
public static final int IPPROTO_PGM =             113;             /* PGM */
public static final int IPPROTO_SCTP =            132;             /* SCTP */
/* 253-254: Experimentation and testing; 255: Reserved (RFC3692) */
/* BSD Private, local use, namespace incursion */
public static final int IPPROTO_DIVERT =          254;             /* divert pseudo-protocol */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_RAW =             255;             /* raw IP packet */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_MAX =             256;

/* last return value of *_input(), meaning "all job for this pkt is done".  */
public static final int IPPROTO_DONE =            257;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

/*
 * Local port number conventions:
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 * The default range is IPPORT_RESERVED through
 * IPPORT_USERRESERVED, although that is settable by sysctl.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
 * into the "high" range.  These are reserved for client outbound connections
 * which do not want to be filtered by any firewalls.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.  This
 * convention is based on "vouchsafe" principles only.  It is only secure
 * if you trust the remote host to restrict these ports.
 *
 * The default range of ports and the high range can be changed by
 * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
 *
 * Changing those values has bad security implications if you are
 * using a a stateless firewall that is allowing packets outside of that
 * range in order to allow transparent outgoing connections.
 *
 * Such a firewall configuration will generally depend on the use of these
 * default values.  If you change them, you may find your Security
 * Administrator looking for you with a heavy object.
 *
 * For a slightly more orthodox text view on this:
 *
 *            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
 *
 *    port numbers are divided into three ranges:
 *
 *                0 -  1023 Well Known Ports
 *             1024 - 49151 Registered Ports
 *            49152 - 65535 Dynamic and/or Private Ports
 *
 */

public static final int __DARWIN_IPPORT_RESERVED =        1024;

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
 * Ports > IPPORT_USERRESERVED are reserved
 * for servers, not necessarily privileged.  (IP_PORTRANGE_DEFAULT)
 */
// #ifndef IPPORT_RESERVED
public static final int IPPORT_RESERVED =         __DARWIN_IPPORT_RESERVED;
// #endif
public static final int IPPORT_USERRESERVED =     5000;

/*
 * Default local port range to use by setting IP_PORTRANGE_HIGH
 */
public static final int IPPORT_HIFIRSTAUTO =      49152;
public static final int IPPORT_HILASTAUTO =       65535;

/*
 * Scanning for a free reserved port return a value below IPPORT_RESERVED,
 * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
 * 512, but that conflicts with some well-known-services that firewalls may
 * have a fit if we use.
 */
public static final int IPPORT_RESERVEDSTART =    600;
// Targeting ../feeder/in_addr.java



/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
public static final int INADDR_ANY =              (int)0x00000000;
public static final int INADDR_BROADCAST =        (int)0xffffffff;   /* must be masked */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #define IN_CLASSA(i)            (((u_int32_t)(i) & 0x80000000) == 0)
public static final int IN_CLASSA_NET =           0xff000000;
public static final int IN_CLASSA_NSHIFT =        24;
public static final int IN_CLASSA_HOST =          0x00ffffff;
public static final int IN_CLASSA_MAX =           128;

// #define IN_CLASSB(i)            (((u_int32_t)(i) & 0xc0000000) == 0x80000000)
public static final int IN_CLASSB_NET =           0xffff0000;
public static final int IN_CLASSB_NSHIFT =        16;
public static final int IN_CLASSB_HOST =          0x0000ffff;
public static final int IN_CLASSB_MAX =           65536;

// #define IN_CLASSC(i)            (((u_int32_t)(i) & 0xe0000000) == 0xc0000000)
public static final int IN_CLASSC_NET =           0xffffff00;
public static final int IN_CLASSC_NSHIFT =        8;
public static final int IN_CLASSC_HOST =          0x000000ff;

// #define IN_CLASSD(i)            (((u_int32_t)(i) & 0xf0000000) == 0xe0000000)
public static final int IN_CLASSD_NET =           0xf0000000;      /* These ones aren't really */
public static final int IN_CLASSD_NSHIFT =        28;              /* net and host fields, but */
public static final int IN_CLASSD_HOST =          0x0fffffff;      /* routing needn't know.    */
// #define IN_MULTICAST(i)         IN_CLASSD(i)

// #define IN_EXPERIMENTAL(i)      (((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
// #define IN_BADCLASS(i)          (((u_int32_t)(i) & 0xf0000000) == 0xf0000000)

public static final int INADDR_LOOPBACK =         (int)0x7f000001;

public static final int INADDR_NONE =             0xffffffff;              /* -1 return */

public static final int INADDR_UNSPEC_GROUP =     (int)0xe0000000;   /* 224.0.0.0 */
public static final int INADDR_ALLHOSTS_GROUP =   (int)0xe0000001;   /* 224.0.0.1 */
public static final int INADDR_ALLRTRS_GROUP =    (int)0xe0000002;   /* 224.0.0.2 */
public static final int INADDR_ALLRPTS_GROUP =    (int)0xe0000016;   /* 224.0.0.22, IGMPv3 */
public static final int INADDR_CARP_GROUP =       (int)0xe0000012;   /* 224.0.0.18 */
public static final int INADDR_PFSYNC_GROUP =     (int)0xe00000f0;   /* 224.0.0.240 */
public static final int INADDR_ALLMDNS_GROUP =    (int)0xe00000fb;   /* 224.0.0.251 */
public static final int INADDR_MAX_LOCAL_GROUP =  (int)0xe00000ff;   /* 224.0.0.255 */

// #ifdef __APPLE__
public static final int IN_LINKLOCALNETNUM =      (int)0xA9FE0000; /* 169.254.0.0 */
// #define IN_LINKLOCAL(i)         (((u_int32_t)(i) & IN_CLASSB_NET) == IN_LINKLOCALNETNUM)
// #define IN_LOOPBACK(i)          (((u_int32_t)(i) & 0xff000000) == 0x7f000000)
// #define IN_ZERONET(i)           (((u_int32_t)(i) & 0xff000000) == 0)

// #define IN_PRIVATE(i)   ((((u_int32_t)(i) & 0xff000000) == 0x0a000000) ||
// 	                 (((u_int32_t)(i) & 0xfff00000) == 0xac100000) ||
// 	                 (((u_int32_t)(i) & 0xffff0000) == 0xc0a80000))


// #define IN_LOCAL_GROUP(i)       (((u_int32_t)(i) & 0xffffff00) == 0xe0000000)

// #define IN_ANY_LOCAL(i)         (IN_LINKLOCAL(i) || IN_LOCAL_GROUP(i))
// #endif /* __APPLE__ */

public static final int IN_LOOPBACKNET =          127;
// Targeting ../feeder/sockaddr_in.java



// #define IN_ARE_ADDR_EQUAL(a, b)
//     (bcmp(&(a)->s_addr, &(b)->s_addr,
// 	sizeof (struct in_addr)) == 0)


public static final int INET_ADDRSTRLEN =                 16;
// Targeting ../feeder/ip_opts.java



/*
 * Options for use with [gs]etsockopt at the IP level.
 * First word of comment is data type; bool is stored in int.
 */
public static final int IP_OPTIONS =              1;    /* buf/ip_opts; set/get IP options */
public static final int IP_HDRINCL =              2;    /* int; header is included with data */
public static final int IP_TOS =                  3;    /* int; IP type of service and preced. */
public static final int IP_TTL =                  4;    /* int; IP time to live */
public static final int IP_RECVOPTS =             5;    /* bool; receive all IP opts w/dgram */
public static final int IP_RECVRETOPTS =          6;    /* bool; receive IP opts for response */
public static final int IP_RECVDSTADDR =          7;    /* bool; receive IP dst addr w/dgram */
public static final int IP_RETOPTS =              8;    /* ip_opts; set/get IP options */
public static final int IP_MULTICAST_IF =         9;    /* u_char; set/get IP multicast i/f  */
public static final int IP_MULTICAST_TTL =        10;   /* u_char; set/get IP multicast ttl */
public static final int IP_MULTICAST_LOOP =       11;   /* u_char; set/get IP multicast loopback */
public static final int IP_ADD_MEMBERSHIP =       12;   /* ip_mreq; add an IP group membership */
public static final int IP_DROP_MEMBERSHIP =      13;   /* ip_mreq; drop an IP group membership */
public static final int IP_MULTICAST_VIF =        14;   /* set/get IP mcast virt. iface */
public static final int IP_RSVP_ON =              15;   /* enable RSVP in kernel */
public static final int IP_RSVP_OFF =             16;   /* disable RSVP in kernel */
public static final int IP_RSVP_VIF_ON =          17;   /* set RSVP per-vif socket */
public static final int IP_RSVP_VIF_OFF =         18;   /* unset RSVP per-vif socket */
public static final int IP_PORTRANGE =            19;   /* int; range to choose for unspec port */
public static final int IP_RECVIF =               20;   /* bool; receive reception if w/dgram */
/* for IPSEC */
public static final int IP_IPSEC_POLICY =         21;   /* int; set/get security policy */
public static final int IP_FAITH =                22;   /* deprecated */
// #ifdef __APPLE__
public static final int IP_STRIPHDR =             23;   /* bool: drop receive of raw IP header */
// #endif
public static final int IP_RECVTTL =              24;   /* bool; receive reception TTL w/dgram */
public static final int IP_BOUND_IF =             25;   /* int; set/get bound interface */
public static final int IP_PKTINFO =              26;   /* get pktinfo on recv socket, set src on sent dgram  */
public static final int IP_RECVPKTINFO =          IP_PKTINFO;      /* receive pktinfo w/dgram */
public static final int IP_RECVTOS =              27;   /* bool; receive IP TOS w/dgram */
public static final int IP_DONTFRAG =             28;   /* don't fragment packet */

public static final int IP_FW_ADD =               40;   /* add a firewall rule to chain */
public static final int IP_FW_DEL =               41;   /* delete a firewall rule from chain */
public static final int IP_FW_FLUSH =             42;   /* flush firewall rule chain */
public static final int IP_FW_ZERO =              43;   /* clear single/all firewall counter(s) */
public static final int IP_FW_GET =               44;   /* get entire firewall rule chain */
public static final int IP_FW_RESETLOG =          45;   /* reset logging counters */

/* These older firewall socket option codes are maintained for backward compatibility. */
public static final int IP_OLD_FW_ADD =           50;   /* add a firewall rule to chain */
public static final int IP_OLD_FW_DEL =           51;   /* delete a firewall rule from chain */
public static final int IP_OLD_FW_FLUSH =         52;   /* flush firewall rule chain */
public static final int IP_OLD_FW_ZERO =          53;   /* clear single/all firewall counter(s) */
public static final int IP_OLD_FW_GET =           54;   /* get entire firewall rule chain */
public static final int IP_NAT__XXX =                     55;   /* set/get NAT opts XXX Deprecated, do not use */
public static final int IP_OLD_FW_RESETLOG =      56;   /* reset logging counters */

public static final int IP_DUMMYNET_CONFIGURE =   60;   /* add/configure a dummynet pipe */
public static final int IP_DUMMYNET_DEL =         61;   /* delete a dummynet pipe from chain */
public static final int IP_DUMMYNET_FLUSH =       62;   /* flush dummynet */
public static final int IP_DUMMYNET_GET =         64;   /* get entire dummynet pipes */

public static final int IP_TRAFFIC_MGT_BACKGROUND =       65;   /* int*; get background IO flags; set background IO */
public static final int IP_MULTICAST_IFINDEX =    66;   /* int*; set/get IP multicast i/f index */

/* IPv4 Source Filter Multicast API [RFC3678] */
public static final int IP_ADD_SOURCE_MEMBERSHIP =        70;   /* join a source-specific group */
public static final int IP_DROP_SOURCE_MEMBERSHIP =       71;   /* drop a single source */
public static final int IP_BLOCK_SOURCE =                 72;   /* block a source */
public static final int IP_UNBLOCK_SOURCE =               73;   /* unblock a source */

/* The following option is private; do not use it from user applications. */
public static final int IP_MSFILTER =                     74;   /* set/get filter list */

/* Protocol Independent Multicast API [RFC3678] */
public static final int MCAST_JOIN_GROUP =                80;   /* join an any-source group */
public static final int MCAST_LEAVE_GROUP =               81;   /* leave all sources for group */
public static final int MCAST_JOIN_SOURCE_GROUP =         82;   /* join a source-specific group */
public static final int MCAST_LEAVE_SOURCE_GROUP =        83;   /* leave a single source */
public static final int MCAST_BLOCK_SOURCE =              84;   /* block a source */
public static final int MCAST_UNBLOCK_SOURCE =            85;   /* unblock a source */


/*
 * Defaults and limits for options
 */
public static final int IP_DEFAULT_MULTICAST_TTL =  1;     /* normally limit m'casts to 1 hop  */
public static final int IP_DEFAULT_MULTICAST_LOOP = 1;     /* normally hear sends if a member  */

/*
 * The imo_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 */
public static final int IP_MIN_MEMBERSHIPS =      31;
public static final int IP_MAX_MEMBERSHIPS =      4095;

/*
 * Default resource limits for IPv4 multicast source filtering.
 * These may be modified by sysctl.
 */
public static final int IP_MAX_GROUP_SRC_FILTER =         512;     /* sources per group */
public static final int IP_MAX_SOCK_SRC_FILTER =          128;     /* sources per socket/group */
public static final int IP_MAX_SOCK_MUTE_FILTER =         128;
// Targeting ../feeder/ip_mreq.java


// Targeting ../feeder/ip_mreqn.java



// #pragma pack(4)
// Targeting ../feeder/ip_mreq_source.java


// Targeting ../feeder/group_req.java


// Targeting ../feeder/group_source_req.java



// #ifndef __MSFILTERREQ_DEFINED
// #define __MSFILTERREQ_DEFINED
// Targeting ../feeder/__msfilterreq.java



// #endif /* __MSFILTERREQ_DEFINED */

// #pragma pack()

/*
 * Advanced (Full-state) APIs [RFC3678]
 * The RFC specifies uint_t for the 6th argument to [sg]etsourcefilter().
 * We use uint32_t here to be consistent.
 */
public static native int setipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t") int arg3,
    @Cast("uint32_t") int arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") IntPointer arg3,
    @Cast("uint32_t*") IntPointer arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") IntBuffer arg3,
    @Cast("uint32_t*") IntBuffer arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") int[] arg3,
    @Cast("uint32_t*") int[] arg4, in_addr arg5);
public static native int setsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t") int arg4, @Cast("uint32_t") int arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") IntPointer arg4, @Cast("uint32_t*") IntPointer arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") IntBuffer arg4, @Cast("uint32_t*") IntBuffer arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") int[] arg4, @Cast("uint32_t*") int[] arg5, sockaddr_storage arg6);

/*
 * Filter modes; also used to represent per-socket filter mode internally.
 */
public static final int MCAST_UNDEFINED = 0;       /* fmode: not yet defined */
public static final int MCAST_INCLUDE =   1;       /* fmode: include these source(s) */
public static final int MCAST_EXCLUDE =   2;       /* fmode: exclude these source(s) */

/*
 * Argument for IP_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
public static final int IP_PORTRANGE_DEFAULT =    0;       /* default range */
public static final int IP_PORTRANGE_HIGH =       1;       /* "high" - request firewall bypass */
public static final int IP_PORTRANGE_LOW =        2;
// Targeting ../feeder/in_pktinfo.java



/*
 * Definitions for inet sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 */
public static final int IPPROTO_MAXID =   (IPPROTO_AH + 1);        /* don't list to IPPROTO_MAX */


/*
 * Names for IP sysctl objects
 */
public static final int IPCTL_FORWARDING =        1;       /* act as router */
public static final int IPCTL_SENDREDIRECTS =     2;       /* may send redirects when forwarding */
public static final int IPCTL_DEFTTL =            3;       /* default TTL */
// #ifdef notyet
public static final int IPCTL_DEFMTU =            4;       /* default MTU */
// #endif
public static final int IPCTL_RTEXPIRE =          5;       /* cloned route expiration time */
public static final int IPCTL_RTMINEXPIRE =       6;       /* min value for expiration time */
public static final int IPCTL_RTMAXCACHE =        7;       /* trigger level for dynamic expire */
public static final int IPCTL_SOURCEROUTE =       8;       /* may perform source routes */
public static final int IPCTL_DIRECTEDBROADCAST = 9;       /* may re-broadcast received packets */
public static final int IPCTL_INTRQMAXLEN =       10;      /* max length of netisr queue */
public static final int IPCTL_INTRQDROPS =        11;      /* number of netisr q drops */
public static final int IPCTL_STATS =             12;      /* ipstat structure */
public static final int IPCTL_ACCEPTSOURCEROUTE = 13;      /* may accept source routed packets */
public static final int IPCTL_FASTFORWARDING =    14;      /* use fast IP forwarding code */
public static final int IPCTL_KEEPFAITH =         15;      /* deprecated */
public static final int IPCTL_GIF_TTL =           16;      /* default TTL for gif encap packet */
public static final int IPCTL_MAXID =             17;

// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* INET6 stuff */
// #define __KAME_NETINET_IN_H_INCLUDED_
// #include <netinet6/in6.h>
// #undef __KAME_NETINET_IN_H_INCLUDED_



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native int bindresvport(int arg0, sockaddr_in arg1);
public static native int bindresvport_sa(int arg0, sockaddr arg1);
// #endif
// #endif /* _NETINET_IN_H_ */


// Parsed from zixi_definitions.h

// #pragma once

// #include <time.h>

// #ifndef __cplusplus
// 	#ifndef bool
// 	#endif
// #endif

// zixi warning values
public static final int ZIXI_WARNING_OVER_LIMIT =			100;

// zixi error values
// recoverable errors
public static final int ZIXI_ERROR_RECONNECTING =			7;
public static final int ZIXI_ERROR_BUFFER_TO_SMALL =		6;
public static final int ZIXI_ERROR_NOT_READY =			5;
public static final int ZIXI_ERROR_ALREADY_CONNECTED =	4;
public static final int ZIXI_ERROR_ALREADY_INITIALIZED =	3;
public static final int ZIXI_ERROR_STREAM_CHANGED =		2;
public static final int ZIXI_ERROR_INVALID_PARAMETER =	1;

// no error
public static final int ZIXI_ERROR_OK =					0;

// non-recoverable errors
public static final int ZIXI_ERROR_FAILED =				-1;
public static final int ZIXI_ERROR_TIMEOUT =				-2;
public static final int ZIXI_ERROR_NOT_INITIALIZED =		-3;
public static final int ZIXI_ERROR_NOT_CONNECTED =		-4;
public static final int ZIXI_ERROR_DLL_NOT_FOUND =		-5;
public static final int ZIXI_ERROR_FUNCTION_NOT_FOUND =	-6;
public static final int ZIXI_ERROR_AUTHORIZATION_FAILED =	-7;
public static final int ZIXI_ERROR_LICENSING_FAILED =		-8;
public static final int ZIXI_ERROR_NETWORK_ERRORS =		-9;
public static final int ZIXI_ERROR_VERSION =				-10;
public static final int ZIXI_ERROR_SERVER_FULL =			-11;
public static final int ZIXI_ERROR_EOF =					-12;
public static final int ZIXI_ERROR_NOT_SUPPORTED =		-13;
public static final int ZIXI_ERROR_TEST_FAILED =			-14;
public static final int ZIXI_ERROR_RESOLVING_FAILED =		-15;
public static final int ZIXI_ERROR_CACHE_TO_SMALL =		-16;
public static final int ZIXI_ERROR_NETWORK =				-17;
public static final int ZIXI_ERROR_NOT_FOUND =			-18;
public static final int ZIXI_ERROR_BAD_URL =				-19;
public static final int ZIXI_ERROR_FILE_LOCAL =			-20;
public static final int ZIXI_ERROR_FILE_REMOTE =			-21;		
public static final int ZIXI_WARNING_REMOTE_FILE_EXISTS = -22;		//	File cannot be uploaded without 'overwrite' permission.
public static final int ZIXI_ERROR_DECRYPTION =			-23;	
public static final int ZIXI_ERROR_CERTIFICATE =			-24;
public static final int ZIXI_ERROR_WRONG_SRP =			-25;

// zixi encryption types
/** enum ZIXI_ENCRYPTION */
public static final int
	ZIXI_AES_128 = 0,
	ZIXI_AES_192 = 1,
	ZIXI_AES_256 = 2,
	ZIXI_CHACHA20 = 3, // fast cipher for platforms without AES-NI
	ZIXI_NO_ENCRYPTION = 4;
//	ZIXI_AUTO_ENCRYPTION - deprecated - use DTLS on the server side instead

// zixi connection status
/** enum ZIXI_STATUS */
public static final int	
	ZIXI_DISCONNECTED = 0,
	ZIXI_CONNECTING = 1,
	ZIXI_CONNECTED = 2,
	ZIXI_DISCONNECTING = 3,
	ZIXI_RECONNECTING = 4;

// zixi log levels
/** enum ZIXI_LOG_LEVELS */
public static final int
	ZIXI_LOG_NONE = -1,
	ZIXI_LOG_ALL = 0,
	ZIXI_LOG_DEBUG = 1,
	ZIXI_LOG_INFO = 2,
	ZIXI_LOG_WARNINGS = 3,
	ZIXI_LOG_ERRORS = 4,
	ZIXI_LOG_FATAL = 5;

/** enum ZIXI_LATENCY_MODE */
public static final int
	ZIXI_LATENCY_STATIC = 0,
	ZIXI_LATENCY_INCREASING = 1,
	ZIXI_LATENCY_DYNAMIC = 2;

/** enum ZIXI_ADAPTIVE_MODE */
public static final int
	ZIXI_ADAPTIVE_NONE = 0,
	ZIXI_ADAPTIVE_ENCODER = 1,
	ZIXI_ADAPTIVE_FEC = 2;

/** enum ZIXI_FEC_MODE */
public static final int
	ZIXI_FEC_OFF = 0,
	ZIXI_FEC_ON = 1,
	ZIXI_FEC_ADAPTIVE = 2;

/** enum ZIXI_VIDEO_CODECS */
public static final int
	ZIXI_VIDEO_CODEC_NONE = 0,
	ZIXI_VIDEO_CODEC_H264 = 1,
	ZIXI_VIDEO_CODEC_HEVC = 2;

/** enum ZIXI_AUDIO_CODECS */
public static final int
	ZIXI_AUDIO_CODEC_NONE = 0,
	ZIXI_AUDIO_CODEC_AAC	 = 1,
	ZIXI_AUDIO_CODEC_OPUS = 2;


/** enum ZIXI_DTLS_CERTIFICATE_VERIFICATION_STATUS */
public static final int
	ZIXI_DTLS_CERT_OK					 = 0,		//	Certificate verified.
	ZIXI_DTLS_CERT_NOT_RECEIVED			 = 1,		//	Server did not send any certificate.
	ZIXI_DLTS_CERT_INVALID_CERTIFICATE	 = 2,		//	Certificate in not valid.
	ZIXI_DTLS_CERT_NOT_VERIFIED			 = 3,		//	Certificate verification failed.
	ZIXI_DTLS_CERT_SELF_SIGNED			 = 4,		//	Certificate is self signed.
	ZIXI_DTLS_CERT_EXPIRED				 = 5,		//	Certificate is expired.
	ZIXI_DTLS_CERT_NOT_YET_VALID		 = 6,		//	Certificate is not yet valid.
	ZIXI_DTLS_CERT_INVALID_CA			 = 7,		//	Certificate authority not recognized.
	ZIXI_DTLS_CERT_HOSTNAME_MISMATCH	 = 8,		//	Certificate issued to hostname different from one provided in connection parameters.
	ZIXI_DTLS_WRONG_SRP					 = 9,		//	Wrong username/password.
	ZIXI_DTLS_INVALID_SSL_CONNECTION	 = 10;		//	Invalid SSL connection.
// Targeting ../feeder/ZIXI_STREAM_INFO.java


// Targeting ../feeder/ZIXI_NETWORK_STATS.java


// Targeting ../feeder/ZIXI_ERROR_CORRECTION_STATS.java


// Targeting ../feeder/ZIXI_CONNECTION_STATS.java


// Targeting ../feeder/ZIXI_BITRATE_CHANGED_FUNC.java


// Targeting ../feeder/ZIXI_STATUS_FUNC.java


// Targeting ../feeder/ZIXI_NEW_STREAM_FUNC.java


// Targeting ../feeder/ZIXI_LOG_FUNC.java


// Targeting ../feeder/ZIXI_IO_FUNCTION.java


// Targeting ../feeder/ZIXI_RELEASE_FUNCTION.java


// Targeting ../feeder/ZIXI_RTMP_HANDLE_WRITE_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_WRITE_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_HANDLE_READ_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_READ_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_CALLBACKS.java



public static final int ZIXI_GUID_LENGTH =	128;
public static final int ZIXI_SESSION_LENGTH =	128;
public static final int ZIXI_CHANNEL_LENGTH =	64;

public static final int ZIXI_MAX_ADAPTIVE_STREAMS =	16;
// Targeting ../feeder/ZIXI_MEDIA_INFO.java


// Targeting ../feeder/ZIXI_FAILOVER_COMPONENT_STATS.java



/** enum ZIXI_PROTOCOL */
public static final int
	ZIXI_PROTOCOL_UDP = 0,
	ZIXI_PROTOCOL_MMT = 1,
	ZIXI_PROTOCOL_RIST_SIMPLE = 2,
	ZIXI_PROTOCOL_RIST_MAIN = 3,
	ZIXI_PROTOCOL_HTTP = 4,
	ZIXI_PROTOCOL_HTTPS = 5;


/** enum ZIXI_FAILOVER_MODE */
public static final int
	ZIXI_FAILOVER_MODE_NONE = 0,	//	streams are assumed to be different, no merging will be attemted.
	ZIXI_FAILOVER_MODE_RTP = 1,			//	merge by RTP headers. SMPTE 2022-7
	ZIXI_FAILOVER_MODE_CONTENT = 2;		//	merge by RTP headers if available or by TS content.


// Parsed from zixi_feeder_interface.h

// #pragma once

// #include "./zixi_definitions.h"
// #include <stdint.h>

// #if defined(IOS) || defined(MAC)
// #include <stdio.h>
// #endif

// #ifndef DLL_EXPORT

// #ifdef WIN32
// #else

// #if defined (ANDROID)
// #else

// #include <stdio.h>
// #define ZIXI_FILE_HANDLE FILE*
// #define INVALID_FILE_HANDLE NULL
// #endif // ANDROID
//   #if __GNUC__ >= 4
//     #define DLL_EXPORT __attribute__ ((visibility ("default")))
//   #else
//     #define DLL_EXPORT
//   #endif
// #endif

// #endif

public static final int MAX_SCTE_ARRAY_SIZE = 255;
// Targeting ../feeder/zixi_nic_config.java


// Targeting ../feeder/zixi_elementary_stream_config.java


// Targeting ../feeder/splice_time_t.java


// Targeting ../feeder/break_duration_t.java


// Targeting ../feeder/scte35_splice_insert_t.java


// Targeting ../feeder/zixi_stream_config.java


// Targeting ../feeder/ZIXI_ENCODER_SETBITRATE_FUNCTION.java


// Targeting ../feeder/ZIXI_ASYNC_OPEN_CALLBACK.java


// Targeting ../feeder/encoder_control_info.java


// Targeting ../feeder/zixi_rtmp_out_config.java


// Targeting ../feeder/zixi_upload_config.java


// Targeting ../feeder/async_open_info.java




// #ifndef ZIXI_NO_FUNCTION_HEADERS

// #ifdef __cplusplus
// #endif

//--------------------------------------------------------
//			Configuration functions
//--------------------------------------------------------


/**
\brief	prepare configuration structs with default values
		<p>
		must be called prior to zixi_open_stream
<p>
@param	stream[optional]
@param	rtmp[optional]
@param	upload[optional]
<p>
\ return	ZIXI_ERROR_OK
*/
public static native int zixi_prepare_configuration(zixi_stream_config stream, zixi_rtmp_out_config rtmp, zixi_upload_config upload);

/**
\brief	configure logging.
		<p>
		can be called during operation to change the log level or log function
<p>
@param		log_level	- log detail level ,
						  [-1] to turn off ,
						  [0] to log everything (significantly hurt performance - only for deep debugging) ,
						  [1-5] different log levels (3 recommended)
@param		log_func	- logging callback function
@param		user_data	- user data that will be returned as the first parameter in log_func
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_configure_logging(@Cast("ZIXI_LOG_LEVELS") int log_level, ZIXI_LOG_FUNC log_func, Pointer user_data);

/**
\brief		Deprecated - use user_id and password parameters in zixi_stream_config
<p>
@param		user		- user unique ID
@param		user_len	- 'user' buffer length
@param		session		- session token or password
@param		session_len	- 'session' buffer length
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_configure_credentials(@Cast("const char*") BytePointer user, int user_len, @Cast("const char*") BytePointer session, int session_len);
public static native int zixi_configure_credentials(String user, int user_len, String session, int session_len);

/**
\brief		creates a new stream
<p>
@param		parameters				- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new stream
<p>
@param		parameters				- stream parameters
@param		async_info				- callback handler for connection notification
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failiure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_stream_async(@ByVal zixi_stream_config parameters, @ByVal async_open_info async_info, encoder_control_info enc_ctrl, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream_async(@ByVal zixi_stream_config parameters, @ByVal async_open_info async_info, encoder_control_info enc_ctrl, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new multiplexed connection, use zixi_add_multiplexed_stream to configure the individual streams
<p>
@param		parameters				- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		streams_count			- number of expected streams (set to 0 if unknown)
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_multiplexed_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("unsigned int") int streams_count, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_multiplexed_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("unsigned int") int streams_count, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		add a new multiplexed stream with rtmp output to an existing multiplexed connection
<p>
@param		stream_handle			- handle for a multiplexed stream created by zixi_open_multiplexed_stream
@param		stream_id				- sub stream id, the final id on the server will be <main stream id>_<sub stream id>
@param		rtmp_out				- rtmp output parameters
@param		multiplex_index[out]	- use this index when sending packets via zixi_send_multiplexed_packet
@param		elementary_streams		- user will provide elementary streams (call to zixi_send_multiplexed_frame)
@param		stream_config			- provide video/audio codecs
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
\retrun		ZIXI_ERROR_FAILED
*/
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") BytePointer stream_id, zixi_rtmp_out_config rtmp_out, IntPointer multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") ByteBuffer stream_id, zixi_rtmp_out_config rtmp_out, IntBuffer multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") byte[] stream_id, zixi_rtmp_out_config rtmp_out, int[] multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);

/**
\brief		creates a new stream with rtmp output on the broadcaster side
<p>
@param		parameters			- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		rtmp_out				- rtmp output parameters
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failiure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
*/
public static native int zixi_open_stream_with_rtmp(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, zixi_rtmp_out_config rtmp_out, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream_with_rtmp(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, zixi_rtmp_out_config rtmp_out, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new upload
<p>
@param		parameters			- upload parameters
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_NOT_FOUND
@return		ZIXI_ERROR_FILE_LOCAL
@return		ZIXI_ERROR_FILE_REMOTE
@return		ZIXI_WARNING_REMOTE_FILE_EXISTS
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_LICENSING_FAILED
*/
public static native int zixi_upload_file(@ByVal zixi_upload_config parameters, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_upload_file(@ByVal zixi_upload_config parameters, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		indicates that a growing file no longer grows
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_finalize_upload(Pointer stream_handle);

/**
\brief		sets the target bitrate for a file upload - must not be lower than max_bitrate configured in initialization
<p>
@param		stream_handle - stream handle returned from zixi_upload_file
<p>
@return		ZIXI_ERROR_OK
			ZIXI_ERROR_INVALID_PARAMETER - invalid file upload handle
			ZIXI_ERROR_FAILED			 - failed to set max bitrate
*/
public static native int zixi_set_upload_file_target_bitrate(Pointer stream_handle, @Cast("uint64_t") long target_bitrate);

/**
\brief		closes an open stream
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_close_stream(Pointer stream_handle);

/**
\brief		update network interfaces to use for bonded streams, can be used to change IP addresses during a session
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		local_ips		- vector of nic ips
@param		count		- number of nics
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_update_local_ips(Pointer stream_handle, zixi_nic_config local_nics, int count);

/**
\brief		update network interfaces to use for bonded streams, this method will use all avilable IPs on the machine
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_set_automatic_ips(Pointer stream_handle);

/**
\brief		sends one packet to destination
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param	    ts_frame_buffer	- transport stream data
@param	    buffer_length	- size of ts_frame_buffer, 188 to 1316 bytes
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") BytePointer ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") ByteBuffer ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") byte[] ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);

/**
\brief		sends one packet to destination on a multiplexed stream
<p>
@param		stream_handle	- stream handle returned from zixi_open_multiplexed_stream
@param		index		- multiplex index returned from zixi_add_multiplexed_stream
@param		buffer		- transport stream data
@param		buffer_length	- size of ts_frame_buffer, 188 to 1316 bytes
<p>
@return     ZIXI_ERROR_OK
\retrun		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") BytePointer buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") ByteBuffer buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") byte[] buffer, int buffer_length, @Cast("unsigned int") int timestamp);

/**
\brief		sends one frame to destination on a multiplexed stream
<p>
@param		stream_handle	- stream handle returned from zixi_open_multiplexed_stream
@param		index			- multiplex index returned from zixi_add_multiplexed_stream
@param		frame			- elementary stream frame data
@param		frame_length	- length of frame in bytes
@param	    pts				- frame presentation timestamp, in 90khz units
@param	    dts				- frame decoding timestamp, in 90khz units. must be monotonically increasing
@param	    video			- true for video frame, false for audio
<p>
<p>
@return     ZIXI_ERROR_OK
\retrun		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") BytePointer frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") ByteBuffer frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") byte[] frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);

/**
\brief		send message to rtmp clients on this stream
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		index			- multiplex index returned from zixi_add_multiplexed_stream, or -1 if multiplexing isn't used
@param		stream_id		- transport stream data
@param		message_type	- rtmp message type
@param		data			- message data to send
@param		data_size		- data size must me less than 1400 bytes
<p>
@return     ZIXI_ERROR_OK
@return     ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") BytePointer data, int data_size);
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") ByteBuffer data, int data_size);
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") byte[] data, int data_size);

/**
\brief		returns stream statistics
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		conn_stats[out]	- pointer to connection statistics structure
@param		net_stats[out]	- pointer to network statistics structure
@param		error_correction_stats[out]	- pointer to error correction statistics structure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return		Any zixi error code applicable for initialized stream, as last error on the stream.
*/
public static native int zixi_get_stats(Pointer stream_handle, ZIXI_CONNECTION_STATS conn_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);

/**
\brief		returns stream statistics on a link in a bonded connection
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		link_index	- link index for bonded connections
@param		conn_stats[out]	- pointer to connection statistics structure
@param		net_stats[out]	- pointer to network statistics structure
@param		error_correction_stats[out]	- pointer to error correction statistics structure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_get_bonded_stats(Pointer stream_handle, int link_index, ZIXI_CONNECTION_STATS conn_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);

/**
\brief		returns upload progress
<p>
@param		stream_handle			- stream handle returned from zixi_add_stream
@param		bytes_transfered[out]	- number of byte uploaded successfully
@param		file_size[out]			- total number of bytes in file. For growing file the value is undefined before calling 'zixi_finalize_upload'
@param		status[out]			- connection status
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_NOT_FOUND;
@return		Any zixi error code applicable for initialized stream, as last error on the stream.
*/
public static native int zixi_get_upload_progress(Pointer stream_handle, LongPointer bytes_transfered, LongPointer bytes_total, @Cast("ZIXI_STATUS*") IntPointer status);
public static native int zixi_get_upload_progress(Pointer stream_handle, LongBuffer bytes_transfered, LongBuffer bytes_total, @Cast("ZIXI_STATUS*") IntBuffer status);
public static native int zixi_get_upload_progress(Pointer stream_handle, long[] bytes_transfered, long[] bytes_total, @Cast("ZIXI_STATUS*") int[] status);

/**
\brief		returns the internal thread id
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		thread_id[out]	- pointer to returned thread id
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_get_thread(Pointer stream_handle, IntPointer thread_id);
public static native int zixi_get_thread(Pointer stream_handle, IntBuffer thread_id);
public static native int zixi_get_thread(Pointer stream_handle, int[] thread_id);

/**
\brief		returns the internal native socket
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		socket[out]	- pointer to returned native socket
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_get_socket(Pointer stream_handle, IntPointer socket);
public static native int zixi_get_socket(Pointer stream_handle, IntBuffer socket);
public static native int zixi_get_socket(Pointer stream_handle, int[] socket);


/**
\brief		returns the zixi feeder library version
<p>
@param		major	- major version number
@param		minor	- minor version number (incremented each time we update our internal protocol)
@param		build	- build number
<p>
@return  	ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_version(IntPointer major, IntPointer minor, IntPointer minor_minor, IntPointer build);
public static native int zixi_version(IntBuffer major, IntBuffer minor, IntBuffer minor_minor, IntBuffer build);
public static native int zixi_version(int[] major, int[] minor, int[] minor_minor, int[] build);



// #ifdef ZIXI_FEEDER_SUPPORT_RTMP

// #endif //ZIXI_FEEDER_SUPPORT_RTMP

/**
\brief		sends one frame to destination
<p>
@param		stream_handle	- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param	    frame_buffer	- elementary data
@param	    buffer_length	- size of frame_buffer
@param	    video			- true for video frame, false for audio
@param	    pts				- frame presentation timestamp, in 90khz units
@param	    dts				- frame decoding timestamp, in 90khz units. must be monotonically increasing 
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") BytePointer frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") ByteBuffer frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") byte[] frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);


/**
\brief		inject scte35 splice_insert command to the generated stream.
			available only when sending elementary streams 
<p>
@param		stream_handle			- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param	    scte35_splice_command	- splice_insert parameters. the feeder will serialize the structure according to standard ("https://www.scte.org/SCTEDocs/Standards/SCTE 35 2016.pdf" - page 33)
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_inject_scte35(Pointer stream_handle, @ByVal scte35_splice_insert_t scte35_splice_command);


/**
\brief		inject scte35 splice_insert command to a multiplexed stream.
			available only when sending elementary streams
<p>
@param		stream_handle			- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param		index					- multiplexed stream index (see zixi_add_multiplexed_stream, multiplex_index out parameter)
@param	    scte35_splice_command	- splice_insert parameters. the feeder will serialize the structure according to standard ("https://www.scte.org/SCTEDocs/Standards/SCTE 35 2016.pdf" - page 33)
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_inject_scte35_to_multiplexed_stream(Pointer stream_handle, int index, @ByVal scte35_splice_insert_t scte35_splice_command);

// #ifdef __cplusplus	//	extern "C"
// #endif

// #endif


}
