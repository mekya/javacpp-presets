// Targeted by JavaCPP version 1.5.8: DO NOT EDIT THIS FILE

package org.bytedeco.zixi.global;

import org.bytedeco.zixi.feeder.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class feeder extends org.bytedeco.zixi.presets.zixiFeeder {
    static { Loader.load(); }

// Parsed from linux/uio.h

/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
 *	Berkeley style UIO structures	-	Alan Cox 1994.
 *
 *		This program is free software; you can redistribute it and/or
 *		modify it under the terms of the GNU General Public License
 *		as published by the Free Software Foundation; either version
 *		2 of the License, or (at your option) any later version.
 */
// #ifndef __LINUX_UIO_H
// #define __LINUX_UIO_H


// #include <linux/types.h>
// Targeting ../feeder/iovec.java



/*
 *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
 */
 
public static final int UIO_FASTIOV =	8;
public static final int UIO_MAXIOV =	1024;


// #endif /* __LINUX_UIO_H */


// Parsed from sys/uio.h

/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef _SYS_UIO_H
public static final int _SYS_UIO_H =	1;

// #include <features.h>
// #include <sys/types.h>
// #include <bits/types/struct_iovec.h>
// #include <bits/uio_lim.h>
// #ifdef __IOV_MAX
// #else
// # undef UIO_MAXIOV
// #endif

/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long readv(int __fd, @Const iovec __iovec, int __count);

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long writev(int __fd, @Const iovec __iovec, int __count);


// #ifdef __USE_MISC
// #endif	/* Use misc.  */


// #ifdef __USE_GNU
// # ifndef __USE_FILE_OFFSET64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv2(int __fp, @Const iovec __iovec, int __count,
			@Cast("__off_t") long __offset, int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev2(int __fd, @Const iovec __iodev, int __count,
			 @Cast("__off_t") long __offset, int __flags);

// # else
// # endif

// # ifdef __USE_LARGEFILE64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv64v2(int __fp, @Const iovec __iovec,
			   int __count, @Cast("__off64_t") long __offset,
			   int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev64v2(int __fd, @Const iovec __iodev,
			    int __count, @Cast("__off64_t") long __offset,
			    int __flags);
// # endif
// #endif /* Use GNU.  */

/* Some operating systems provide system-specific extensions to this
   header.  */
// #ifdef __USE_GNU
// # include <bits/uio-ext.h>
// #endif

// #endif /* sys/uio.h */


// Parsed from bits/sockaddr.h

/* Definition of struct sockaddr_* common members and sizes, generic version.
   Copyright (C) 1995-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */

// #ifndef _BITS_SOCKADDR_H
public static final int _BITS_SOCKADDR_H =	1;


/* POSIX.1g specifies this type name for the `sa_family' member.  */

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

// #define	__SOCKADDR_COMMON(sa_prefix)
//   sa_family_t sa_prefix##family

public static native @MemberGetter int __SOCKADDR_COMMON_SIZE();
public static final int __SOCKADDR_COMMON_SIZE = __SOCKADDR_COMMON_SIZE();

/* Size of struct sockaddr_storage.  */
public static final int _SS_SIZE = 128;

// #endif	/* bits/sockaddr.h */


// Parsed from bits/socket.h

/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef __BITS_SOCKET_H
// #define __BITS_SOCKET_H

// #ifndef _SYS_SOCKET_H
// # error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
// #endif

// #define __need_size_t
// #include <stddef.h>

// #include <sys/types.h>

/* Type for length arguments in socket calls.  */
// #ifndef __socklen_t_defined
// # define __socklen_t_defined
// #endif

/* Get the architecture-dependent definition of enum __socket_type.  */
// #include <bits/socket_type.h>

/* Protocol families.  */
public static final int PF_UNSPEC =	0;	/* Unspecified.  */
public static final int PF_LOCAL =	1;	/* Local to host (pipes and file-domain).  */
public static final int PF_UNIX =		PF_LOCAL; /* POSIX name for PF_LOCAL.  */
public static final int PF_FILE =		PF_LOCAL; /* Another non-standard name for PF_LOCAL.  */
public static final int PF_INET =		2;	/* IP protocol family.  */
public static final int PF_AX25 =		3;	/* Amateur Radio AX.25.  */
public static final int PF_IPX =		4;	/* Novell Internet Protocol.  */
public static final int PF_APPLETALK =	5;	/* Appletalk DDP.  */
public static final int PF_NETROM =	6;	/* Amateur radio NetROM.  */
public static final int PF_BRIDGE =	7;	/* Multiprotocol bridge.  */
public static final int PF_ATMPVC =	8;	/* ATM PVCs.  */
public static final int PF_X25 =		9;	/* Reserved for X.25 project.  */
public static final int PF_INET6 =	10;	/* IP version 6.  */
public static final int PF_ROSE =		11;	/* Amateur Radio X.25 PLP.  */
public static final int PF_DECnet =	12;	/* Reserved for DECnet project.  */
public static final int PF_NETBEUI =	13;	/* Reserved for 802.2LLC project.  */
public static final int PF_SECURITY =	14;	/* Security callback pseudo AF.  */
public static final int PF_KEY =		15;	/* PF_KEY key management API.  */
public static final int PF_NETLINK =	16;
public static final int PF_ROUTE =	PF_NETLINK; /* Alias to emulate 4.4BSD.  */
public static final int PF_PACKET =	17;	/* Packet family.  */
public static final int PF_ASH =		18;	/* Ash.  */
public static final int PF_ECONET =	19;	/* Acorn Econet.  */
public static final int PF_ATMSVC =	20;	/* ATM SVCs.  */
public static final int PF_RDS =		21;	/* RDS sockets.  */
public static final int PF_SNA =		22;	/* Linux SNA Project */
public static final int PF_IRDA =		23;	/* IRDA sockets.  */
public static final int PF_PPPOX =	24;	/* PPPoX sockets.  */
public static final int PF_WANPIPE =	25;	/* Wanpipe API sockets.  */
public static final int PF_LLC =		26;	/* Linux LLC.  */
public static final int PF_IB =		27;	/* Native InfiniBand address.  */
public static final int PF_MPLS =		28;	/* MPLS.  */
public static final int PF_CAN =		29;	/* Controller Area Network.  */
public static final int PF_TIPC =		30;	/* TIPC sockets.  */
public static final int PF_BLUETOOTH =	31;	/* Bluetooth sockets.  */
public static final int PF_IUCV =		32;	/* IUCV sockets.  */
public static final int PF_RXRPC =	33;	/* RxRPC sockets.  */
public static final int PF_ISDN =		34;	/* mISDN sockets.  */
public static final int PF_PHONET =	35;	/* Phonet sockets.  */
public static final int PF_IEEE802154 =	36;	/* IEEE 802.15.4 sockets.  */
public static final int PF_CAIF =		37;	/* CAIF sockets.  */
public static final int PF_ALG =		38;	/* Algorithm sockets.  */
public static final int PF_NFC =		39;	/* NFC sockets.  */
public static final int PF_VSOCK =	40;	/* vSockets.  */
public static final int PF_KCM =		41;	/* Kernel Connection Multiplexor.  */
public static final int PF_QIPCRTR =	42;	/* Qualcomm IPC Router.  */
public static final int PF_SMC =		43;	/* SMC sockets.  */
public static final int PF_XDP =		44;	/* XDP sockets.  */
public static final int PF_MAX =		45;	/* For now..  */

/* Address families.  */
public static final int AF_UNSPEC =	PF_UNSPEC;
public static final int AF_LOCAL =	PF_LOCAL;
public static final int AF_UNIX =		PF_UNIX;
public static final int AF_FILE =		PF_FILE;
public static final int AF_INET =		PF_INET;
public static final int AF_AX25 =		PF_AX25;
public static final int AF_IPX =		PF_IPX;
public static final int AF_APPLETALK =	PF_APPLETALK;
public static final int AF_NETROM =	PF_NETROM;
public static final int AF_BRIDGE =	PF_BRIDGE;
public static final int AF_ATMPVC =	PF_ATMPVC;
public static final int AF_X25 =		PF_X25;
public static final int AF_INET6 =	PF_INET6;
public static final int AF_ROSE =		PF_ROSE;
public static final int AF_DECnet =	PF_DECnet;
public static final int AF_NETBEUI =	PF_NETBEUI;
public static final int AF_SECURITY =	PF_SECURITY;
public static final int AF_KEY =		PF_KEY;
public static final int AF_NETLINK =	PF_NETLINK;
public static final int AF_ROUTE =	PF_ROUTE;
public static final int AF_PACKET =	PF_PACKET;
public static final int AF_ASH =		PF_ASH;
public static final int AF_ECONET =	PF_ECONET;
public static final int AF_ATMSVC =	PF_ATMSVC;
public static final int AF_RDS =		PF_RDS;
public static final int AF_SNA =		PF_SNA;
public static final int AF_IRDA =		PF_IRDA;
public static final int AF_PPPOX =	PF_PPPOX;
public static final int AF_WANPIPE =	PF_WANPIPE;
public static final int AF_LLC =		PF_LLC;
public static final int AF_IB =		PF_IB;
public static final int AF_MPLS =		PF_MPLS;
public static final int AF_CAN =		PF_CAN;
public static final int AF_TIPC =		PF_TIPC;
public static final int AF_BLUETOOTH =	PF_BLUETOOTH;
public static final int AF_IUCV =		PF_IUCV;
public static final int AF_RXRPC =	PF_RXRPC;
public static final int AF_ISDN =		PF_ISDN;
public static final int AF_PHONET =	PF_PHONET;
public static final int AF_IEEE802154 =	PF_IEEE802154;
public static final int AF_CAIF =		PF_CAIF;
public static final int AF_ALG =		PF_ALG;
public static final int AF_NFC =		PF_NFC;
public static final int AF_VSOCK =	PF_VSOCK;
public static final int AF_KCM =		PF_KCM;
public static final int AF_QIPCRTR =	PF_QIPCRTR;
public static final int AF_SMC =		PF_SMC;
public static final int AF_XDP =		PF_XDP;
public static final int AF_MAX =		PF_MAX;

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
public static final int SOL_RAW =		255;
public static final int SOL_DECNET =      261;
public static final int SOL_X25 =         262;
public static final int SOL_PACKET =	263;
public static final int SOL_ATM =		264;	/* ATM layer (cell level).  */
public static final int SOL_AAL =		265;	/* ATM Adaption Layer (packet level).  */
public static final int SOL_IRDA =	266;
public static final int SOL_NETBEUI =	267;
public static final int SOL_LLC =		268;
public static final int SOL_DCCP =	269;
public static final int SOL_NETLINK =	270;
public static final int SOL_TIPC =	271;
public static final int SOL_RXRPC =	272;
public static final int SOL_PPPOL2TP =	273;
public static final int SOL_BLUETOOTH =	274;
public static final int SOL_PNPIPE =	275;
public static final int SOL_RDS =		276;
public static final int SOL_IUCV =	277;
public static final int SOL_CAIF =	278;
public static final int SOL_ALG =		279;
public static final int SOL_NFC =		280;
public static final int SOL_KCM =		281;
public static final int SOL_TLS =		282;
public static final int SOL_XDP =		283;

/* Maximum queue length specifiable by listen.  */
public static final int SOMAXCONN =	4096;

/* Get the definition of the macro to define the common sockaddr members.  */
// #include <bits/sockaddr.h>
// Targeting ../feeder/sockaddr.java




/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
// #define __ss_aligntype	unsigned long int
public static native @MemberGetter int _SS_PADSIZE();
public static final int _SS_PADSIZE = _SS_PADSIZE();
// Targeting ../feeder/sockaddr_storage.java




/* Bits in the FLAGS argument to `send', `recv', et al.  */
/** enum  */
public static final int
    MSG_OOB		 = 0x01,	/* Process out-of-band data.  */
// #define MSG_OOB		MSG_OOB
    MSG_PEEK		 = 0x02,	/* Peek at incoming messages.  */
// #define MSG_PEEK	MSG_PEEK
    MSG_DONTROUTE	 = 0x04,	/* Don't use local routing.  */
// #define MSG_DONTROUTE	MSG_DONTROUTE
// #ifdef __USE_GNU
    /* DECnet uses a different name.  */
    MSG_TRYHARD		 = MSG_DONTROUTE,
// # define MSG_TRYHARD	MSG_DONTROUTE
// #endif
    MSG_CTRUNC		 = 0x08,	/* Control data lost before delivery.  */
// #define MSG_CTRUNC	MSG_CTRUNC
    MSG_PROXY		 = 0x10,	/* Supply or ask second address.  */
// #define MSG_PROXY	MSG_PROXY
    MSG_TRUNC		 = 0x20,
// #define MSG_TRUNC	MSG_TRUNC
    MSG_DONTWAIT	 = 0x40, /* Nonblocking IO.  */
// #define MSG_DONTWAIT	MSG_DONTWAIT
    MSG_EOR		 = 0x80, /* End of record.  */
// #define MSG_EOR		MSG_EOR
    MSG_WAITALL		 = 0x100, /* Wait for a full request.  */
// #define MSG_WAITALL	MSG_WAITALL
    MSG_FIN		 = 0x200,
// #define MSG_FIN		MSG_FIN
    MSG_SYN		 = 0x400,
// #define MSG_SYN		MSG_SYN
    MSG_CONFIRM		 = 0x800, /* Confirm path validity.  */
// #define MSG_CONFIRM	MSG_CONFIRM
    MSG_RST		 = 0x1000,
// #define MSG_RST		MSG_RST
    MSG_ERRQUEUE	 = 0x2000, /* Fetch message from error queue.  */
// #define MSG_ERRQUEUE	MSG_ERRQUEUE
    MSG_NOSIGNAL	 = 0x4000, /* Do not generate SIGPIPE.  */
// #define MSG_NOSIGNAL	MSG_NOSIGNAL
    MSG_MORE		 = 0x8000,  /* Sender will send more.  */
// #define MSG_MORE	MSG_MORE
    MSG_WAITFORONE	 = 0x10000, /* Wait for at least one packet to return.*/
// #define MSG_WAITFORONE	MSG_WAITFORONE
    MSG_BATCH		 = 0x40000, /* sendmmsg: more messages coming.  */
// #define MSG_BATCH	MSG_BATCH
    MSG_ZEROCOPY	 = 0x4000000, /* Use user data in kernel path.  */
// #define MSG_ZEROCOPY	MSG_ZEROCOPY
    MSG_FASTOPEN	 = 0x20000000, /* Send data in TCP SYN.  */
// #define MSG_FASTOPEN	MSG_FASTOPEN

    MSG_CMSG_CLOEXEC	 = 0x40000000;	/* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */
// #define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
// Targeting ../feeder/msghdr.java


// Targeting ../feeder/cmsghdr.java



/* Ancillary data object manipulation macros.  */
// #if __glibc_c99_flexarr_available
// # define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
// #else
// # define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
// #endif
// #define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
// #define CMSG_FIRSTHDR(mhdr)
//   ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)
//    ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
// #define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1)
// 			 & (size_t) ~(sizeof (size_t) - 1))
// #define CMSG_SPACE(len) (CMSG_ALIGN (len)
// 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
// #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))

public static native cmsghdr __cmsg_nxthdr(msghdr __mhdr,
				      cmsghdr __cmsg);
// #ifdef __USE_EXTERN_INLINES
// #endif	/* Use `extern inline'.  */

/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
/** enum  */
public static final int
    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
// #define SCM_RIGHTS SCM_RIGHTS
    SCM_CREDENTIALS = 0x02;	/* Credentials passing.  */
// # define SCM_CREDENTIALS SCM_CREDENTIALS
// #endif
// Targeting ../feeder/ucred.java


// #endif

// #ifdef __USE_MISC
// #else
public static final int SO_DEBUG = 1;
// # include <bits/socket-constants.h>
// Targeting ../feeder/linger.java



// #endif	/* bits/socket.h */


// Parsed from sys/socket.h

/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef	_SYS_SOCKET_H
public static final int _SYS_SOCKET_H =	1;

// #include <features.h>


// #endif /* sys/socket.h */


// Parsed from netinet/in.h

/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef	_NETINET_IN_H
public static final int _NETINET_IN_H =	1;

// #include <features.h>
// #include <bits/stdint-iLntn.h>
// #include <sys/socket.h>
// #include <bits/types.h>


/* Internet address.  */
// Targeting ../feeder/in_addr.java



/* Get system-specific definitions.  */
// #include <bits/in.h>

/* Standard well-defined IP protocols.  */
/** enum  */
public static final int
    IPPROTO_IP = 0,	   /* Dummy protocol for TCP.  */
// #define IPPROTO_IP		IPPROTO_IP
    IPPROTO_ICMP = 1,	   /* Internet Control Message Protocol.  */
// #define IPPROTO_ICMP		IPPROTO_ICMP
    IPPROTO_IGMP = 2,	   /* Internet Group Management Protocol. */
// #define IPPROTO_IGMP		IPPROTO_IGMP
    IPPROTO_IPIP = 4,	   /* IPIP tunnels (older KA9Q tunnels use 94).  */
// #define IPPROTO_IPIP		IPPROTO_IPIP
    IPPROTO_TCP = 6,	   /* Transmission Control Protocol.  */
// #define IPPROTO_TCP		IPPROTO_TCP
    IPPROTO_EGP = 8,	   /* Exterior Gateway Protocol.  */
// #define IPPROTO_EGP		IPPROTO_EGP
    IPPROTO_PUP = 12,	   /* PUP protocol.  */
// #define IPPROTO_PUP		IPPROTO_PUP
    IPPROTO_UDP = 17,	   /* User Datagram Protocol.  */
// #define IPPROTO_UDP		IPPROTO_UDP
    IPPROTO_IDP = 22,	   /* XNS IDP protocol.  */
// #define IPPROTO_IDP		IPPROTO_IDP
    IPPROTO_TP = 29,	   /* SO Transport Protocol Class 4.  */
// #define IPPROTO_TP		IPPROTO_TP
    IPPROTO_DCCP = 33,	   /* Datagram Congestion Control Protocol.  */
// #define IPPROTO_DCCP		IPPROTO_DCCP
    IPPROTO_IPV6 = 41,     /* IPv6 header.  */
// #define IPPROTO_IPV6		IPPROTO_IPV6
    IPPROTO_RSVP = 46,	   /* Reservation Protocol.  */
// #define IPPROTO_RSVP		IPPROTO_RSVP
    IPPROTO_GRE = 47,	   /* General Routing Encapsulation.  */
// #define IPPROTO_GRE		IPPROTO_GRE
    IPPROTO_ESP = 50,      /* encapsulating security payload.  */
// #define IPPROTO_ESP		IPPROTO_ESP
    IPPROTO_AH = 51,       /* authentication header.  */
// #define IPPROTO_AH		IPPROTO_AH
    IPPROTO_MTP = 92,	   /* Multicast Transport Protocol.  */
// #define IPPROTO_MTP		IPPROTO_MTP
    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */
// #define IPPROTO_BEETPH		IPPROTO_BEETPH
    IPPROTO_ENCAP = 98,	   /* Encapsulation Header.  */
// #define IPPROTO_ENCAP		IPPROTO_ENCAP
    IPPROTO_PIM = 103,	   /* Protocol Independent Multicast.  */
// #define IPPROTO_PIM		IPPROTO_PIM
    IPPROTO_COMP = 108,	   /* Compression Header Protocol.  */
// #define IPPROTO_COMP		IPPROTO_COMP
    IPPROTO_SCTP = 132,	   /* Stream Control Transmission Protocol.  */
// #define IPPROTO_SCTP		IPPROTO_SCTP
    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
// #define IPPROTO_UDPLITE		IPPROTO_UDPLITE
    IPPROTO_MPLS = 137,    /* MPLS in IP.  */
// #define IPPROTO_MPLS		IPPROTO_MPLS
    IPPROTO_RAW = 255,	   /* Raw IP packets.  */
// #define IPPROTO_RAW		IPPROTO_RAW
    IPPROTO_MAX = 256;

/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
   network headers first and we should use those ABI-identical definitions
   instead of our own, otherwise 0.  */
// #if !__USE_KERNEL_IPV6_DEFS
/** enum  */
public static final int
    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */
// #define IPPROTO_HOPOPTS		IPPROTO_HOPOPTS
    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */
// #define IPPROTO_ROUTING		IPPROTO_ROUTING
    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
// #define IPPROTO_FRAGMENT	IPPROTO_FRAGMENT
    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */
// #define IPPROTO_ICMPV6		IPPROTO_ICMPV6
    IPPROTO_NONE = 59,     /* IPv6 no next header.  */
// #define IPPROTO_NONE		IPPROTO_NONE
    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */
// #define IPPROTO_DSTOPTS		IPPROTO_DSTOPTS
    IPPROTO_MH = 135;       /* IPv6 mobility header.  */
// #define IPPROTO_MH		IPPROTO_MH
// #endif /* !__USE_KERNEL_IPV6_DEFS */

/* Type to represent a port.  */

/* Standard well-known ports.  */
/** enum  */
public static final int
    IPPORT_ECHO = 7,		/* Echo service.  */
    IPPORT_DISCARD = 9,		/* Discard transmissions service.  */
    IPPORT_SYSTAT = 11,		/* System status service.  */
    IPPORT_DAYTIME = 13,	/* Time of day service.  */
    IPPORT_NETSTAT = 15,	/* Network status service.  */
    IPPORT_FTP = 21,		/* File Transfer Protocol.  */
    IPPORT_TELNET = 23,		/* Telnet protocol.  */
    IPPORT_SMTP = 25,		/* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37,	/* Timeserver service.  */
    IPPORT_NAMESERVER = 42,	/* Domain Name Service.  */
    IPPORT_WHOIS = 43,		/* Internet Whois service.  */
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,		/* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,		/* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,		/* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512,	/* execd service.  */
    IPPORT_LOGINSERVER = 513,	/* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,

    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000;

/* Definitions of the bits in an Internet address integer.

   On subnets, host and network parts are found according to
   the subnet mask, not these masks.  */

// #define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
public static final int IN_CLASSA_NET =		0xff000000;
public static final int IN_CLASSA_NSHIFT =	24;
public static final int IN_CLASSA_HOST =		(0xffffffff & ~IN_CLASSA_NET);
public static final int IN_CLASSA_MAX =		128;

// #define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
public static final int IN_CLASSB_NET =		0xffff0000;
public static final int IN_CLASSB_NSHIFT =	16;
public static final int IN_CLASSB_HOST =		(0xffffffff & ~IN_CLASSB_NET);
public static final int IN_CLASSB_MAX =		65536;

// #define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
public static final int IN_CLASSC_NET =		0xffffff00;
public static final int IN_CLASSC_NSHIFT =	8;
public static final int IN_CLASSC_HOST =		(0xffffffff & ~IN_CLASSC_NET);

// #define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
// #define	IN_MULTICAST(a)		IN_CLASSD(a)

// #define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
// #define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)

/* Address to accept any incoming messages.  */
public static final int INADDR_ANY =		((int) 0x00000000);
/* Address to send to all hosts.  */
public static final int INADDR_BROADCAST =	((int) 0xffffffff);
/* Address indicating an error return.  */
public static final int INADDR_NONE =		((int) 0xffffffff);

/* Network number for local host loopback.  */
public static final int IN_LOOPBACKNET =		127;
/* Address to loopback in software to local host.  */
// #ifndef INADDR_LOOPBACK
public static final int INADDR_LOOPBACK =	((int) 0x7f000001); /* Inet 127.0.0.1.  */
// #endif

/* Defines for Multicast INADDR.  */
public static final int INADDR_UNSPEC_GROUP =	((int) 0xe0000000); /* 224.0.0.0 */
public static final int INADDR_ALLHOSTS_GROUP =	((int) 0xe0000001); /* 224.0.0.1 */
public static final int INADDR_ALLRTRS_GROUP =    ((int) 0xe0000002); /* 224.0.0.2 */
public static final int INADDR_ALLSNOOPERS_GROUP = ((int) 0xe000006a); /* 224.0.0.106 */
public static final int INADDR_MAX_LOCAL_GROUP =  ((int) 0xe00000ff);
// Targeting ../feeder/in6_addr.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

@MemberGetter public static native @Const @ByRef in6_addr in6addr_any();        /* :: */
@MemberGetter public static native @Const @ByRef in6_addr in6addr_loopback();   /* ::1 */
// #define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
// #define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

public static final int INET_ADDRSTRLEN = 16;
public static final int INET6_ADDRSTRLEN = 46;
// Targeting ../feeder/sockaddr_in.java


// Targeting ../feeder/sockaddr_in6.java


// Targeting ../feeder/ipv6_mreq.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

// #ifdef __USE_MISC
// #endif

/* Functions to convert between host and network byte order.

   Please note that these functions normally take `unsigned long int' or
   `unsigned short int' values as arguments and also return them.  But
   this was a short-sighted decision since on different systems the types
   may have different representations but the values are always the same.  */

public static native @Cast("uint32_t") int ntohl(@Cast("uint32_t") int __netlong);
public static native @Cast("uint16_t") short ntohs(@Cast("uint16_t") short __netshort);
public static native @Cast("uint32_t") int htonl(@Cast("uint32_t") int __hostlong);
public static native @Cast("uint16_t") short htons(@Cast("uint16_t") short __hostshort);

// #include <endian.h>

/* Get machine dependent optimized versions of byte swapping functions.  */
// #include <bits/byteswap.h>
// #include <bits/uintn-identity.h>

// #ifdef __OPTIMIZE__
/* We can optimize calls to the conversion functions.  Either nothing has
   to be done or we are using directly the byte-swapping functions which
   often can be inlined.  */
// # if __BYTE_ORDER == __BIG_ENDIAN
/* The host byte order is the same as network byte order,
   so these functions are all just identity.  */
// # define ntohl(x)	__uint32_identity (x)
// # define ntohs(x)	__uint16_identity (x)
// # define htonl(x)	__uint32_identity (x)
// # define htons(x)	__uint16_identity (x)
// # else
// #  if __BYTE_ORDER == __LITTLE_ENDIAN
// #   define ntohl(x)	__bswap_32 (x)
// #   define ntohs(x)	__bswap_16 (x)
// #   define htonl(x)	__bswap_32 (x)
// #   define htons(x)	__bswap_16 (x)
// #  endif
// # endif
// #endif

// #ifdef __GNUC__
// # define IN6_IS_ADDR_UNSPECIFIED(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && __a->__in6_u.__u6_addr32[3] == 0; }))

// # define IN6_IS_ADDR_LOOPBACK(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && __a->__in6_u.__u6_addr32[3] == htonl (1); }))

// # define IN6_IS_ADDR_LINKLOCAL(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfe800000); }))

// # define IN6_IS_ADDR_SITELOCAL(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfec00000); }))

// # define IN6_IS_ADDR_V4MAPPED(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == htonl (0xffff); }))

// # define IN6_IS_ADDR_V4COMPAT(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && ntohl (__a->__in6_u.__u6_addr32[3]) > 1; }))

// # define IN6_ARE_ADDR_EQUAL(a,b)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       const struct in6_addr *__b = (const struct in6_addr *) (b);
//       __a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]
//       && __a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]
//       && __a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]
//       && __a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]; }))
// #else
// # define IN6_IS_ADDR_UNSPECIFIED(a)
// 	(((const uint32_t *) (a))[0] == 0
// 	 && ((const uint32_t *) (a))[1] == 0
// 	 && ((const uint32_t *) (a))[2] == 0
// 	 && ((const uint32_t *) (a))[3] == 0)

// # define IN6_IS_ADDR_LOOPBACK(a)
// 	(((const uint32_t *) (a))[0] == 0
// 	 && ((const uint32_t *) (a))[1] == 0
// 	 && ((const uint32_t *) (a))[2] == 0
// 	 && ((const uint32_t *) (a))[3] == htonl (1))

// # define IN6_IS_ADDR_LINKLOCAL(a)
// 	((((const uint32_t *) (a))[0] & htonl (0xffc00000))
// 	 == htonl (0xfe800000))

// # define IN6_IS_ADDR_SITELOCAL(a)
// 	((((const uint32_t *) (a))[0] & htonl (0xffc00000))
// 	 == htonl (0xfec00000))

// # define IN6_IS_ADDR_V4MAPPED(a)
// 	((((const uint32_t *) (a))[0] == 0)
// 	 && (((const uint32_t *) (a))[1] == 0)
// 	 && (((const uint32_t *) (a))[2] == htonl (0xffff)))

// # define IN6_IS_ADDR_V4COMPAT(a)
// 	((((const uint32_t *) (a))[0] == 0)
// 	 && (((const uint32_t *) (a))[1] == 0)
// 	 && (((const uint32_t *) (a))[2] == 0)
// 	 && (ntohl (((const uint32_t *) (a))[3]) > 1))

// # define IN6_ARE_ADDR_EQUAL(a,b)
// 	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0])
// 	 && (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1])
// 	 && (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2])
// 	 && (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
// #endif

// #define IN6_IS_ADDR_MULTICAST(a) (((const uint8_t *) (a))[0] == 0xff)

// #ifdef __USE_MISC
// #endif


// #define IN6_IS_ADDR_MC_NODELOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x1))

// #define IN6_IS_ADDR_MC_LINKLOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x2))

// #define IN6_IS_ADDR_MC_SITELOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x5))

// #define IN6_IS_ADDR_MC_ORGLOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x8))

// #define IN6_IS_ADDR_MC_GLOBAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0xe))


// #ifdef __USE_GNU
// Targeting ../feeder/in6_pktinfo.java


// Targeting ../feeder/ip6_mtuinfo.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
public static native int inet6_option_space(int __nbytes);
public static native int inet6_option_init(Pointer __bp, @Cast("cmsghdr**") PointerPointer __cmsgp,
			      int __type);
public static native int inet6_option_init(Pointer __bp, @ByPtrPtr cmsghdr __cmsgp,
			      int __type);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") BytePointer __typep, int __multx,
				int __plusy);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") ByteBuffer __typep, int __multx,
				int __plusy);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") byte[] __typep, int __multx,
				int __plusy);
public static native @Cast("uint8_t*") BytePointer inet6_option_alloc(cmsghdr __cmsg, int __datalen,
				    int __multx, int __plusy);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") PointerPointer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr BytePointer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr ByteBuffer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr byte[] __tptrp);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") PointerPointer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr BytePointer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr ByteBuffer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr byte[] __tptrp, int __type);


/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
public static native int inet6_opt_init(Pointer __extbuf, @Cast("socklen_t") int __extlen);
public static native int inet6_opt_append(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			     @Cast("uint8_t") byte __type, @Cast("socklen_t") int __len, @Cast("uint8_t") byte __align,
			     @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_append(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			     @Cast("uint8_t") byte __type, @Cast("socklen_t") int __len, @Cast("uint8_t") byte __align,
			     @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_finish(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset);
public static native int inet6_opt_set_val(Pointer __databuf, int __offset, Pointer __val,
			      @Cast("socklen_t") int __vallen);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") BytePointer __typep, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") BytePointer __typep, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") ByteBuffer __typep, @Cast("socklen_t*") IntBuffer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") byte[] __typep, @Cast("socklen_t*") int[] __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntBuffer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") int[] __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_get_val(Pointer __databuf, int __offset, Pointer __val,
			      @Cast("socklen_t") int __vallen);


/* Routing Header Option (RFC 3542).  */
public static native @Cast("socklen_t") int inet6_rth_space(int __type, int __segments);
public static native Pointer inet6_rth_init(Pointer __bp, @Cast("socklen_t") int __bp_len, int __type,
			     int __segments);
public static native int inet6_rth_add(Pointer __bp, @Const in6_addr __addr);
public static native int inet6_rth_reverse(@Const Pointer __in, Pointer __out);
public static native int inet6_rth_segments(@Const Pointer __bp);
public static native in6_addr inet6_rth_getaddr(@Const Pointer __bp, int __index);


/* Multicast source filter support.  */

/* Get IPv4 source filter.  */
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") IntPointer __fmode,
				@Cast("uint32_t*") IntPointer __numsrc, in_addr __slist);
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") IntBuffer __fmode,
				@Cast("uint32_t*") IntBuffer __numsrc, in_addr __slist);
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") int[] __fmode,
				@Cast("uint32_t*") int[] __numsrc, in_addr __slist);

/* Set IPv4 source filter.  */
public static native int setipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t") int __fmode,
				@Cast("uint32_t") int __numsrc,
				@Const in_addr __slist);


/* Get source filter.  */
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") IntPointer __fmode,
			    @Cast("uint32_t*") IntPointer __numsrc,
			    sockaddr_storage __slist);
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") IntBuffer __fmode,
			    @Cast("uint32_t*") IntBuffer __numsrc,
			    sockaddr_storage __slist);
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") int[] __fmode,
			    @Cast("uint32_t*") int[] __numsrc,
			    sockaddr_storage __slist);

/* Set source filter.  */
public static native int setsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t") int __fmode,
			    @Cast("uint32_t") int __numsrc,
			    @Const sockaddr_storage __slist);
// #endif	/* use GNU */

// #endif	/* netinet/in.h */


// Parsed from zixi_definitions.h

// #pragma once

// #include <time.h>

// #ifndef __cplusplus
// 	#ifndef bool
// 	#endif
// #endif

// zixi warning values
public static final int ZIXI_WARNING_OVER_LIMIT =			100;

// zixi error values
// recoverable errors
public static final int ZIXI_ERROR_RECONNECTING =			7;
public static final int ZIXI_ERROR_BUFFER_TO_SMALL =		6;
public static final int ZIXI_ERROR_NOT_READY =			5;
public static final int ZIXI_ERROR_ALREADY_CONNECTED =	4;
public static final int ZIXI_ERROR_ALREADY_INITIALIZED =	3;
public static final int ZIXI_ERROR_STREAM_CHANGED =		2;
public static final int ZIXI_ERROR_INVALID_PARAMETER =	1;

// no error
public static final int ZIXI_ERROR_OK =					0;

// non-recoverable errors
public static final int ZIXI_ERROR_FAILED =				-1;
public static final int ZIXI_ERROR_TIMEOUT =				-2;
public static final int ZIXI_ERROR_NOT_INITIALIZED =		-3;
public static final int ZIXI_ERROR_NOT_CONNECTED =		-4;
public static final int ZIXI_ERROR_DLL_NOT_FOUND =		-5;
public static final int ZIXI_ERROR_FUNCTION_NOT_FOUND =	-6;
public static final int ZIXI_ERROR_AUTHORIZATION_FAILED =	-7;
public static final int ZIXI_ERROR_LICENSING_FAILED =		-8;
public static final int ZIXI_ERROR_NETWORK_ERRORS =		-9;
public static final int ZIXI_ERROR_VERSION =				-10;
public static final int ZIXI_ERROR_SERVER_FULL =			-11;
public static final int ZIXI_ERROR_EOF =					-12;
public static final int ZIXI_ERROR_NOT_SUPPORTED =		-13;
public static final int ZIXI_ERROR_TEST_FAILED =			-14;
public static final int ZIXI_ERROR_RESOLVING_FAILED =		-15;
public static final int ZIXI_ERROR_CACHE_TO_SMALL =		-16;
public static final int ZIXI_ERROR_NETWORK =				-17;
public static final int ZIXI_ERROR_NOT_FOUND =			-18;
public static final int ZIXI_ERROR_BAD_URL =				-19;
public static final int ZIXI_ERROR_FILE_LOCAL =			-20;
public static final int ZIXI_ERROR_FILE_REMOTE =			-21;		
public static final int ZIXI_WARNING_REMOTE_FILE_EXISTS = -22;		//	File cannot be uploaded without 'overwrite' permission.
public static final int ZIXI_ERROR_DECRYPTION =			-23;	
public static final int ZIXI_ERROR_CERTIFICATE =			-24;
public static final int ZIXI_ERROR_WRONG_SRP =			-25;

// zixi encryption types
/** enum ZIXI_ENCRYPTION */
public static final int
	ZIXI_AES_128 = 0,
	ZIXI_AES_192 = 1,
	ZIXI_AES_256 = 2,
	ZIXI_CHACHA20 = 3, // fast cipher for platforms without AES-NI
	ZIXI_NO_ENCRYPTION = 4;
//	ZIXI_AUTO_ENCRYPTION - deprecated - use DTLS on the server side instead

// zixi connection status
/** enum ZIXI_STATUS */
public static final int	
	ZIXI_DISCONNECTED = 0,
	ZIXI_CONNECTING = 1,
	ZIXI_CONNECTED = 2,
	ZIXI_DISCONNECTING = 3,
	ZIXI_RECONNECTING = 4;

// zixi log levels
/** enum ZIXI_LOG_LEVELS */
public static final int
	ZIXI_LOG_NONE = -1,
	ZIXI_LOG_ALL = 0,
	ZIXI_LOG_DEBUG = 1,
	ZIXI_LOG_INFO = 2,
	ZIXI_LOG_WARNINGS = 3,
	ZIXI_LOG_ERRORS = 4,
	ZIXI_LOG_FATAL = 5;

/** enum ZIXI_LATENCY_MODE */
public static final int
	ZIXI_LATENCY_STATIC = 0,
	ZIXI_LATENCY_INCREASING = 1,
	ZIXI_LATENCY_DYNAMIC = 2;

/** enum ZIXI_ADAPTIVE_MODE */
public static final int
	ZIXI_ADAPTIVE_NONE = 0,
	ZIXI_ADAPTIVE_ENCODER = 1,
	ZIXI_ADAPTIVE_FEC = 2;

/** enum ZIXI_FEC_MODE */
public static final int
	ZIXI_FEC_OFF = 0,
	ZIXI_FEC_ON = 1,
	ZIXI_FEC_ADAPTIVE = 2;

/** enum ZIXI_VIDEO_CODECS */
public static final int
	ZIXI_VIDEO_CODEC_NONE = 0,
	ZIXI_VIDEO_CODEC_H264 = 1,
	ZIXI_VIDEO_CODEC_HEVC = 2;

/** enum ZIXI_AUDIO_CODECS */
public static final int
	ZIXI_AUDIO_CODEC_NONE = 0,
	ZIXI_AUDIO_CODEC_AAC	 = 1,
	ZIXI_AUDIO_CODEC_OPUS = 2;


/** enum ZIXI_DTLS_CERTIFICATE_VERIFICATION_STATUS */
public static final int
	ZIXI_DTLS_CERT_OK					 = 0,		//	Certificate verified.
	ZIXI_DTLS_CERT_NOT_RECEIVED			 = 1,		//	Server did not send any certificate.
	ZIXI_DLTS_CERT_INVALID_CERTIFICATE	 = 2,		//	Certificate in not valid.
	ZIXI_DTLS_CERT_NOT_VERIFIED			 = 3,		//	Certificate verification failed.
	ZIXI_DTLS_CERT_SELF_SIGNED			 = 4,		//	Certificate is self signed.
	ZIXI_DTLS_CERT_EXPIRED				 = 5,		//	Certificate is expired.
	ZIXI_DTLS_CERT_NOT_YET_VALID		 = 6,		//	Certificate is not yet valid.
	ZIXI_DTLS_CERT_INVALID_CA			 = 7,		//	Certificate authority not recognized.
	ZIXI_DTLS_CERT_HOSTNAME_MISMATCH	 = 8,		//	Certificate issued to hostname different from one provided in connection parameters.
	ZIXI_DTLS_WRONG_SRP					 = 9,		//	Wrong username/password.
	ZIXI_DTLS_INVALID_SSL_CONNECTION	 = 10;		//	Invalid SSL connection.
// Targeting ../feeder/ZIXI_STREAM_INFO.java


// Targeting ../feeder/ZIXI_NETWORK_STATS.java


// Targeting ../feeder/ZIXI_ERROR_CORRECTION_STATS.java


// Targeting ../feeder/ZIXI_CONNECTION_STATS.java


// Targeting ../feeder/ZIXI_BITRATE_CHANGED_FUNC.java


// Targeting ../feeder/ZIXI_STATUS_FUNC.java


// Targeting ../feeder/ZIXI_NEW_STREAM_FUNC.java


// Targeting ../feeder/ZIXI_LOG_FUNC.java


// Targeting ../feeder/ZIXI_IO_FUNCTION.java


// Targeting ../feeder/ZIXI_RELEASE_FUNCTION.java


// Targeting ../feeder/ZIXI_RTMP_HANDLE_WRITE_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_WRITE_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_HANDLE_READ_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_RTMP_READ_DATA_EXTERNAL.java


// Targeting ../feeder/ZIXI_CALLBACKS.java



public static final int ZIXI_GUID_LENGTH =	128;
public static final int ZIXI_SESSION_LENGTH =	128;
public static final int ZIXI_CHANNEL_LENGTH =	64;

public static final int ZIXI_MAX_ADAPTIVE_STREAMS =	16;
// Targeting ../feeder/ZIXI_MEDIA_INFO.java


// Targeting ../feeder/ZIXI_FAILOVER_COMPONENT_STATS.java



/** enum ZIXI_PROTOCOL */
public static final int
	ZIXI_PROTOCOL_UDP = 0,
	ZIXI_PROTOCOL_MMT = 1,
	ZIXI_PROTOCOL_RIST_SIMPLE = 2,
	ZIXI_PROTOCOL_RIST_MAIN = 3,
	ZIXI_PROTOCOL_HTTP = 4,
	ZIXI_PROTOCOL_HTTPS = 5;


/** enum ZIXI_FAILOVER_MODE */
public static final int
	ZIXI_FAILOVER_MODE_NONE = 0,	//	streams are assumed to be different, no merging will be attemted.
	ZIXI_FAILOVER_MODE_RTP = 1,			//	merge by RTP headers. SMPTE 2022-7
	ZIXI_FAILOVER_MODE_CONTENT = 2;		//	merge by RTP headers if available or by TS content.


// Parsed from zixi_feeder_interface.h

// #pragma once

// #include "./zixi_definitions.h"
// #include <stdint.h>

// #if defined(IOS) || defined(MAC)
// #include <stdio.h>
// #endif

// #ifndef DLL_EXPORT

// #ifdef WIN32
// #else

// #if defined (ANDROID)
// #else

// #include <stdio.h>
// #define ZIXI_FILE_HANDLE FILE*
// #define INVALID_FILE_HANDLE NULL
// #endif // ANDROID
//   #if __GNUC__ >= 4
//     #define DLL_EXPORT __attribute__ ((visibility ("default")))
//   #else
//     #define DLL_EXPORT
//   #endif
// #endif

// #endif

public static final int MAX_SCTE_ARRAY_SIZE = 255;
// Targeting ../feeder/zixi_nic_config.java


// Targeting ../feeder/zixi_elementary_stream_config.java


// Targeting ../feeder/splice_time_t.java


// Targeting ../feeder/break_duration_t.java


// Targeting ../feeder/scte35_splice_insert_t.java


// Targeting ../feeder/zixi_stream_config.java


// Targeting ../feeder/ZIXI_ENCODER_SETBITRATE_FUNCTION.java


// Targeting ../feeder/ZIXI_ASYNC_OPEN_CALLBACK.java


// Targeting ../feeder/encoder_control_info.java


// Targeting ../feeder/zixi_rtmp_out_config.java


// Targeting ../feeder/zixi_upload_config.java


// Targeting ../feeder/async_open_info.java




// #ifndef ZIXI_NO_FUNCTION_HEADERS

// #ifdef __cplusplus
// #endif

//--------------------------------------------------------
//			Configuration functions
//--------------------------------------------------------


/**
\brief	prepare configuration structs with default values
		<p>
		must be called prior to zixi_open_stream
<p>
@param	stream[optional]
@param	rtmp[optional]
@param	upload[optional]
<p>
\ return	ZIXI_ERROR_OK
*/
public static native int zixi_prepare_configuration(zixi_stream_config stream, zixi_rtmp_out_config rtmp, zixi_upload_config upload);

/**
\brief	configure logging.
		<p>
		can be called during operation to change the log level or log function
<p>
@param		log_level	- log detail level ,
						  [-1] to turn off ,
						  [0] to log everything (significantly hurt performance - only for deep debugging) ,
						  [1-5] different log levels (3 recommended)
@param		log_func	- logging callback function
@param		user_data	- user data that will be returned as the first parameter in log_func
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_configure_logging(@Cast("ZIXI_LOG_LEVELS") int log_level, ZIXI_LOG_FUNC log_func, Pointer user_data);

/**
\brief		Deprecated - use user_id and password parameters in zixi_stream_config
<p>
@param		user		- user unique ID
@param		user_len	- 'user' buffer length
@param		session		- session token or password
@param		session_len	- 'session' buffer length
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_configure_credentials(@Cast("const char*") BytePointer user, int user_len, @Cast("const char*") BytePointer session, int session_len);
public static native int zixi_configure_credentials(String user, int user_len, String session, int session_len);

/**
\brief		creates a new stream
<p>
@param		parameters				- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new stream
<p>
@param		parameters				- stream parameters
@param		async_info				- callback handler for connection notification
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failiure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_stream_async(@ByVal zixi_stream_config parameters, @ByVal async_open_info async_info, encoder_control_info enc_ctrl, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream_async(@ByVal zixi_stream_config parameters, @ByVal async_open_info async_info, encoder_control_info enc_ctrl, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new multiplexed connection, use zixi_add_multiplexed_stream to configure the individual streams
<p>
@param		parameters				- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		streams_count			- number of expected streams (set to 0 if unknown)
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_open_multiplexed_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("unsigned int") int streams_count, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_multiplexed_stream(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, @Cast("unsigned int") int streams_count, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		add a new multiplexed stream with rtmp output to an existing multiplexed connection
<p>
@param		stream_handle			- handle for a multiplexed stream created by zixi_open_multiplexed_stream
@param		stream_id				- sub stream id, the final id on the server will be <main stream id>_<sub stream id>
@param		rtmp_out				- rtmp output parameters
@param		multiplex_index[out]	- use this index when sending packets via zixi_send_multiplexed_packet
@param		elementary_streams		- user will provide elementary streams (call to zixi_send_multiplexed_frame)
@param		stream_config			- provide video/audio codecs
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
\retrun		ZIXI_ERROR_FAILED
*/
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") BytePointer stream_id, zixi_rtmp_out_config rtmp_out, IntPointer multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") ByteBuffer stream_id, zixi_rtmp_out_config rtmp_out, IntBuffer multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);
public static native int zixi_add_multiplexed_stream(Pointer stream_handle, @Cast("char*") byte[] stream_id, zixi_rtmp_out_config rtmp_out, int[] multiplex_index, @Cast("bool") boolean elementary_streams, @ByVal zixi_elementary_stream_config stream_config);

/**
\brief		creates a new stream with rtmp output on the broadcaster side
<p>
@param		parameters			- stream parameters
@param		enc_ctrl				- encoder controlling functions to get & adjust source bitrate. Should be null for autonomous encoder.
@param		rtmp_out				- rtmp output parameters
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failiure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_CERTIFICATE
*/
public static native int zixi_open_stream_with_rtmp(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, zixi_rtmp_out_config rtmp_out, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_open_stream_with_rtmp(@ByVal zixi_stream_config parameters, encoder_control_info enc_ctrl, zixi_rtmp_out_config rtmp_out, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		creates a new upload
<p>
@param		parameters			- upload parameters
@param		out_stream_handle[out]	- stream handle when connection succeeds. NULL on failure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_RESOLVING_FAILED
@return		ZIXI_ERROR_NETWORK
@return		ZIXI_ERROR_NOT_FOUND
@return		ZIXI_ERROR_FILE_LOCAL
@return		ZIXI_ERROR_FILE_REMOTE
@return		ZIXI_WARNING_REMOTE_FILE_EXISTS
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return		ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_CERTIFICATE
@return		ZIXI_ERROR_LICENSING_FAILED
*/
public static native int zixi_upload_file(@ByVal zixi_upload_config parameters, @Cast("void**") PointerPointer out_stream_handle);
public static native int zixi_upload_file(@ByVal zixi_upload_config parameters, @Cast("void**") @ByPtrPtr Pointer out_stream_handle);

/**
\brief		indicates that a growing file no longer grows
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_finalize_upload(Pointer stream_handle);

/**
\brief		sets the target bitrate for a file upload - must not be lower than max_bitrate configured in initialization
<p>
@param		stream_handle - stream handle returned from zixi_upload_file
<p>
@return		ZIXI_ERROR_OK
			ZIXI_ERROR_INVALID_PARAMETER - invalid file upload handle
			ZIXI_ERROR_FAILED			 - failed to set max bitrate
*/
public static native int zixi_set_upload_file_target_bitrate(Pointer stream_handle, @Cast("uint64_t") long target_bitrate);

/**
\brief		closes an open stream
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_close_stream(Pointer stream_handle);

/**
\brief		update network interfaces to use for bonded streams, can be used to change IP addresses during a session
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		local_ips		- vector of nic ips
@param		count		- number of nics
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_update_local_ips(Pointer stream_handle, zixi_nic_config local_nics, int count);

/**
\brief		update network interfaces to use for bonded streams, this method will use all avilable IPs on the machine
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_set_automatic_ips(Pointer stream_handle);

/**
\brief		sends one packet to destination
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param	    ts_frame_buffer	- transport stream data
@param	    buffer_length	- size of ts_frame_buffer, 188 to 1316 bytes
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") BytePointer ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") ByteBuffer ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_frame(Pointer stream_handle, @Cast("char*") byte[] ts_frame_buffer, int buffer_length, @Cast("unsigned int") int timestamp);

/**
\brief		sends one packet to destination on a multiplexed stream
<p>
@param		stream_handle	- stream handle returned from zixi_open_multiplexed_stream
@param		index		- multiplex index returned from zixi_add_multiplexed_stream
@param		buffer		- transport stream data
@param		buffer_length	- size of ts_frame_buffer, 188 to 1316 bytes
<p>
@return     ZIXI_ERROR_OK
\retrun		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") BytePointer buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") ByteBuffer buffer, int buffer_length, @Cast("unsigned int") int timestamp);
public static native int zixi_send_multiplexed_packet(Pointer stream_handle, int index, @Cast("char*") byte[] buffer, int buffer_length, @Cast("unsigned int") int timestamp);

/**
\brief		sends one frame to destination on a multiplexed stream
<p>
@param		stream_handle	- stream handle returned from zixi_open_multiplexed_stream
@param		index			- multiplex index returned from zixi_add_multiplexed_stream
@param		frame			- elementary stream frame data
@param		frame_length	- length of frame in bytes
@param	    pts				- frame presentation timestamp, in 90khz units
@param	    dts				- frame decoding timestamp, in 90khz units. must be monotonically increasing
@param	    video			- true for video frame, false for audio
<p>
<p>
@return     ZIXI_ERROR_OK
\retrun		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_NOT_CONNECTED
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") BytePointer frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") ByteBuffer frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);
public static native int zixi_send_multiplexed_frame(Pointer stream_handle, int index, @Cast("char*") byte[] frame, int frame_length, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts, @Cast("bool") boolean video);

/**
\brief		send message to rtmp clients on this stream
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		index			- multiplex index returned from zixi_add_multiplexed_stream, or -1 if multiplexing isn't used
@param		stream_id		- transport stream data
@param		message_type	- rtmp message type
@param		data			- message data to send
@param		data_size		- data size must me less than 1400 bytes
<p>
@return     ZIXI_ERROR_OK
@return     ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_FAILED
*/
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") BytePointer data, int data_size);
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") ByteBuffer data, int data_size);
public static native int zixi_send_rtmp_message(Pointer stream_handle, int index, int stream_id, @Cast("unsigned char") byte message_type, @Cast("unsigned char*") byte[] data, int data_size);

/**
\brief		returns stream statistics
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		conn_stats[out]	- pointer to connection statistics structure
@param		net_stats[out]	- pointer to network statistics structure
@param		error_correction_stats[out]	- pointer to error correction statistics structure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return		Any zixi error code applicable for initialized stream, as last error on the stream.
*/
public static native int zixi_get_stats(Pointer stream_handle, ZIXI_CONNECTION_STATS conn_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);

/**
\brief		returns stream statistics on a link in a bonded connection
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		link_index	- link index for bonded connections
@param		conn_stats[out]	- pointer to connection statistics structure
@param		net_stats[out]	- pointer to network statistics structure
@param		error_correction_stats[out]	- pointer to error correction statistics structure
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
*/
public static native int zixi_get_bonded_stats(Pointer stream_handle, int link_index, ZIXI_CONNECTION_STATS conn_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);

/**
\brief		returns upload progress
<p>
@param		stream_handle			- stream handle returned from zixi_add_stream
@param		bytes_transfered[out]	- number of byte uploaded successfully
@param		file_size[out]			- total number of bytes in file. For growing file the value is undefined before calling 'zixi_finalize_upload'
@param		status[out]			- connection status
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_NOT_FOUND;
@return		Any zixi error code applicable for initialized stream, as last error on the stream.
*/
public static native int zixi_get_upload_progress(Pointer stream_handle, LongPointer bytes_transfered, LongPointer bytes_total, @Cast("ZIXI_STATUS*") IntPointer status);
public static native int zixi_get_upload_progress(Pointer stream_handle, LongBuffer bytes_transfered, LongBuffer bytes_total, @Cast("ZIXI_STATUS*") IntBuffer status);
public static native int zixi_get_upload_progress(Pointer stream_handle, long[] bytes_transfered, long[] bytes_total, @Cast("ZIXI_STATUS*") int[] status);

/**
\brief		returns the internal thread id
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		thread_id[out]	- pointer to returned thread id
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_get_thread(Pointer stream_handle, IntPointer thread_id);
public static native int zixi_get_thread(Pointer stream_handle, IntBuffer thread_id);
public static native int zixi_get_thread(Pointer stream_handle, int[] thread_id);

/**
\brief		returns the internal native socket
<p>
@param		stream_handle	- stream handle returned from zixi_add_stream
@param		socket[out]	- pointer to returned native socket
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_get_socket(Pointer stream_handle, IntPointer socket);
public static native int zixi_get_socket(Pointer stream_handle, IntBuffer socket);
public static native int zixi_get_socket(Pointer stream_handle, int[] socket);


/**
\brief		returns the zixi feeder library version
<p>
@param		major	- major version number
@param		minor	- minor version number (incremented each time we update our internal protocol)
@param		build	- build number
<p>
@return  	ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_version(IntPointer major, IntPointer minor, IntPointer minor_minor, IntPointer build);
public static native int zixi_version(IntBuffer major, IntBuffer minor, IntBuffer minor_minor, IntBuffer build);
public static native int zixi_version(int[] major, int[] minor, int[] minor_minor, int[] build);



// #ifdef ZIXI_FEEDER_SUPPORT_RTMP

// #endif //ZIXI_FEEDER_SUPPORT_RTMP

/**
\brief		sends one frame to destination
<p>
@param		stream_handle	- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param	    frame_buffer	- elementary data
@param	    buffer_length	- size of frame_buffer
@param	    video			- true for video frame, false for audio
@param	    pts				- frame presentation timestamp, in 90khz units
@param	    dts				- frame decoding timestamp, in 90khz units. must be monotonically increasing 
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") BytePointer frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") ByteBuffer frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);
public static native int zixi_send_elementary_frame(Pointer stream_handle, @Cast("char*") byte[] frame_buffer, int buffer_length, @Cast("bool") boolean video, @Cast("uint64_t") long pts, @Cast("uint64_t") long dts);


/**
\brief		inject scte35 splice_insert command to the generated stream.
			available only when sending elementary streams 
<p>
@param		stream_handle			- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param	    scte35_splice_command	- splice_insert parameters. the feeder will serialize the structure according to standard ("https://www.scte.org/SCTEDocs/Standards/SCTE 35 2016.pdf" - page 33)
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_inject_scte35(Pointer stream_handle, @ByVal scte35_splice_insert_t scte35_splice_command);


/**
\brief		inject scte35 splice_insert command to a multiplexed stream.
			available only when sending elementary streams
<p>
@param		stream_handle			- stream handle returned from zixi_open_stream, zixi_open_stream_with_rtmp
@param		index					- multiplexed stream index (see zixi_add_multiplexed_stream, multiplex_index out parameter)
@param	    scte35_splice_command	- splice_insert parameters. the feeder will serialize the structure according to standard ("https://www.scte.org/SCTEDocs/Standards/SCTE 35 2016.pdf" - page 33)
<p>
@return     ZIXI_ERROR_OK
@return		ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_NOT_READY
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_WARNING_OVER_LIMIT
*/
public static native int zixi_inject_scte35_to_multiplexed_stream(Pointer stream_handle, int index, @ByVal scte35_splice_insert_t scte35_splice_command);

// #ifdef __cplusplus	//	extern "C"
// #endif

// #endif


}
