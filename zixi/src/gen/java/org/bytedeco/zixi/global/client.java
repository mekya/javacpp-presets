// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.zixi.global;

import org.bytedeco.zixi.client.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class client extends org.bytedeco.zixi.presets.zixiClient {
    static { Loader.load(); }

// Parsed from sys/_types/_iovec_t.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_IOVEC
// #define _STRUCT_IOVEC
// #include <sys/_types/_size_t.h>
// Targeting ../client/iovec.java


// #endif /* _STRUCT_IOVEC */


// Parsed from sys/socket.h

/*
 * Copyright (c) 2000-2019 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
 */
/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */

// #ifndef _SYS_SOCKET_H_
// #define _SYS_SOCKET_H_

// #include <sys/types.h>
// #include <sys/cdefs.h>
// #include <machine/_param.h>
// #include <net/net_kev.h>



// #include <Availability.h>

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Data types.
 */

// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sa_family_t.h>
// #include <sys/_types/_socklen_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_size_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_ssize_t.h>

/*
 * [XSI] The iovec structure shall be defined as described in <sys/uio.h>.
 */
// #include <sys/_types/_iovec_t.h>

/*
 * Types
 */
public static final int SOCK_STREAM =     1;               /* stream socket */
public static final int SOCK_DGRAM =      2;               /* datagram socket */
public static final int SOCK_RAW =        3;               /* raw-protocol interface */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_RDM =        4;               /* reliably-delivered message */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SOCK_SEQPACKET =  5;               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
public static final int SO_DEBUG =        0x0001;          /* turn on debugging info recording */
public static final int SO_ACCEPTCONN =   0x0002;          /* socket has had listen() */
public static final int SO_REUSEADDR =    0x0004;          /* allow local address reuse */
public static final int SO_KEEPALIVE =    0x0008;          /* keep connections alive */
public static final int SO_DONTROUTE =    0x0010;          /* just use interface addresses */
public static final int SO_BROADCAST =    0x0020;          /* permit sending of broadcast msgs */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_USELOOPBACK =  0x0040;          /* bypass hardware when possible */
public static final int SO_LINGER =       0x0080;          /* linger on close if data present (in ticks) */
// #else
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SO_OOBINLINE =    0x0100;          /* leave received OOB data in line */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_REUSEPORT =    0x0200;          /* allow local address & port reuse */
public static final int SO_TIMESTAMP =    0x0400;          /* timestamp received dgram traffic */
public static final int SO_TIMESTAMP_MONOTONIC =  0x0800;  /* Monotonically increasing timestamp on rcvd dgram */
// #ifndef __APPLE__
// #else
public static final int SO_DONTTRUNC =    0x2000;          /* APPLE: Retain unread data */
                                        /*  (ATOMIC proto) */
public static final int SO_WANTMORE =     0x4000;          /* APPLE: Give hint when more data ready */
public static final int SO_WANTOOBFLAG =  0x8000;          /* APPLE: Want OOB in MSG_FLAG on receive */


// #endif  /* (!__APPLE__) */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Additional options, not kept in so_options.
 */
public static final int SO_SNDBUF =       0x1001;          /* send buffer size */
public static final int SO_RCVBUF =       0x1002;          /* receive buffer size */
public static final int SO_SNDLOWAT =     0x1003;          /* send low-water mark */
public static final int SO_RCVLOWAT =     0x1004;          /* receive low-water mark */
public static final int SO_SNDTIMEO =     0x1005;          /* send timeout */
public static final int SO_RCVTIMEO =     0x1006;          /* receive timeout */
public static final int SO_ERROR =        0x1007;          /* get error status and clear */
public static final int SO_TYPE =         0x1008;          /* get socket type */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_LABEL =        0x1010;          /* deprecated */
public static final int SO_PEERLABEL =    0x1011;          /* deprecated */
// #ifdef __APPLE__
public static final int SO_NREAD =        0x1020;          /* APPLE: get 1st-packet byte count */
public static final int SO_NKE =          0x1021;          /* APPLE: Install socket-level NKE */
public static final int SO_NOSIGPIPE =    0x1022;          /* APPLE: No SIGPIPE on EPIPE */
public static final int SO_NOADDRERR =    0x1023;          /* APPLE: Returns EADDRNOTAVAIL when src is not available anymore */
public static final int SO_NWRITE =       0x1024;          /* APPLE: Get number of bytes currently in send socket buffer */
public static final int SO_REUSESHAREUID =        0x1025;          /* APPLE: Allow reuse of port/socket by different userids */
// #ifdef __APPLE_API_PRIVATE
public static final int SO_NOTIFYCONFLICT =       0x1026;  /* APPLE: send notification if there is a bind on a port which is already in use */
public static final int SO_UPCALLCLOSEWAIT =      0x1027;  /* APPLE: block on close until an upcall returns */
// #endif
public static final int SO_LINGER_SEC =   0x1080;          /* linger on close if data present (in seconds) */
public static final int SO_RANDOMPORT =   0x1082;  /* APPLE: request local port randomization */
public static final int SO_NP_EXTENSIONS =        0x1083;  /* To turn off some POSIX behavior */
// #endif

public static final int SO_NUMRCVPKT =            0x1112;  /* number of datagrams in receive socket buffer */
public static final int SO_NET_SERVICE_TYPE =     0x1116;  /* Network service type */


public static final int SO_NETSVC_MARKING_LEVEL =    0x1119;  /* Get QoS marking in effect for socket */


/* When adding new socket-options, you need to make sure MPTCP supports these as well! */

/*
 * Network Service Type for option SO_NET_SERVICE_TYPE
 *
 * The vast majority of sockets should use Best Effort that is the default
 * Network Service Type. Other Network Service Types have to be used only if
 * the traffic actually matches the description of the Network Service Type.
 *
 * Network Service Types do not represent priorities but rather describe
 * different categories of delay, jitter and loss parameters.
 * Those parameters may influence protocols from layer 4 protocols like TCP
 * to layer 2 protocols like Wi-Fi. The Network Service Type can determine
 * how the traffic is queued and scheduled by the host networking stack and
 * by other entities on the network like switches and routers. For example
 * for Wi-Fi, the Network Service Type can select the marking of the
 * layer 2 packet with the appropriate WMM Access Category.
 *
 * There is no point in attempting to game the system and use
 * a Network Service Type that does not correspond to the actual
 * traffic characteristic but one that seems to have a higher precedence.
 * The reason is that for service classes that have lower tolerance
 * for delay and jitter, the queues size is lower than for service
 * classes that are more tolerant to delay and jitter.
 *
 * For example using a voice service type for bulk data transfer will lead
 * to disastrous results as soon as congestion happens because the voice
 * queue overflows and packets get dropped. This is not only bad for the bulk
 * data transfer but it is also bad for VoIP apps that legitimately are using
 * the voice  service type.
 *
 * The characteristics of the Network Service Types are based on the service
 * classes defined in RFC 4594 "Configuration Guidelines for DiffServ Service
 * Classes"
 *
 * When system detects the outgoing interface belongs to a DiffServ domain
 * that follows the recommendation of the IETF draft "Guidelines for DiffServ to
 * IEEE 802.11 Mapping", the packet will marked at layer 3 with a DSCP value
 * that corresponds to Network Service Type.
 *
 * NET_SERVICE_TYPE_BE
 *	"Best Effort", unclassified/standard.  This is the default service
 *	class and cover the majority of the traffic.
 *
 * NET_SERVICE_TYPE_BK
 *	"Background", high delay tolerant, loss tolerant. elastic flow,
 *	variable size & long-lived. E.g: non-interactive network bulk transfer
 *	like synching or backup.
 *
 * NET_SERVICE_TYPE_RD
 *	"Responsive Data", a notch higher than "Best Effort", medium delay
 *	tolerant, elastic & inelastic flow, bursty, long-lived. E.g. email,
 *	instant messaging, for which there is a sense of interactivity and
 *	urgency (user waiting for output).
 *
 * NET_SERVICE_TYPE_OAM
 *	"Operations, Administration, and Management", medium delay tolerant,
 *	low-medium loss tolerant, elastic & inelastic flows, variable size.
 *	E.g. VPN tunnels.
 *
 * NET_SERVICE_TYPE_AV
 *	"Multimedia Audio/Video Streaming", medium delay tolerant, low-medium
 *	loss tolerant, elastic flow, constant packet interval, variable rate
 *	and size. E.g. video and audio playback with buffering.
 *
 * NET_SERVICE_TYPE_RV
 *	"Responsive Multimedia Audio/Video", low delay tolerant, low-medium
 *	loss tolerant, elastic flow, variable packet interval, rate and size.
 *	E.g. screen sharing.
 *
 * NET_SERVICE_TYPE_VI
 *	"Interactive Video", low delay tolerant, low-medium loss tolerant,
 *	elastic flow, constant packet interval, variable rate & size. E.g.
 *	video telephony.
 *
 * NET_SERVICE_TYPE_SIG
 *	"Signaling", low delay tolerant, low loss tolerant, inelastic flow,
 *	jitter tolerant, rate is bursty but short, variable size. E.g. SIP.
 *
 * NET_SERVICE_TYPE_VO
 *	"Interactive Voice", very low delay tolerant, very low loss tolerant,
 *	inelastic flow, constant packet rate, somewhat fixed size.
 *	E.g. VoIP.
 */

public static final int NET_SERVICE_TYPE_BE =     0; /* Best effort */
public static final int NET_SERVICE_TYPE_BK =     1; /* Background system initiated */
public static final int NET_SERVICE_TYPE_SIG =    2; /* Signaling */
public static final int NET_SERVICE_TYPE_VI =     3; /* Interactive Video */
public static final int NET_SERVICE_TYPE_VO =     4; /* Interactive Voice */
public static final int NET_SERVICE_TYPE_RV =     5; /* Responsive Multimedia Audio/Video */
public static final int NET_SERVICE_TYPE_AV =     6; /* Multimedia Audio/Video Streaming */
public static final int NET_SERVICE_TYPE_OAM =    7; /* Operations, Administration, and Management */
public static final int NET_SERVICE_TYPE_RD =     8; /* Responsive Data */


/* These are supported values for SO_NETSVC_MARKING_LEVEL */
public static final int NETSVC_MRKNG_UNKNOWN =            0;       /* The outgoing network interface is not known */
public static final int NETSVC_MRKNG_LVL_L2 =             1;       /* Default marking at layer 2 (for example Wi-Fi WMM) */
public static final int NETSVC_MRKNG_LVL_L3L2_ALL =       2;       /* Layer 3 DSCP marking and layer 2 marking for all Network Service Types */
public static final int NETSVC_MRKNG_LVL_L3L2_BK =        3;       /* The system policy limits layer 3 DSCP marking and layer 2 marking
	                                         * to background Network Service Types */
public static final int SAE_ASSOCID_ANY = 0;
// #define SAE_ASSOCID_ALL ((sae_associd_t)(-1L))
public static final int SAE_CONNID_ANY =  0;
// #define SAE_CONNID_ALL  ((sae_connid_t)(-1L))

/* connectx() flag parameters */
public static final int CONNECT_RESUME_ON_READ_WRITE =    0x1; /* resume connect() on read/write */
public static final int CONNECT_DATA_IDEMPOTENT =         0x2; /* data is idempotent */
public static final int CONNECT_DATA_AUTHENTICATED =      0x4;
// Targeting ../client/sa_endpoints_t.java


// Targeting ../client/linger.java


// Targeting ../client/so_np_extensions.java



public static final int SONPX_SETOPTSHUT =        0x000000001;     /* flag for allowing setsockopt after shutdown */



// #endif
// #endif

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
public static final int SOL_SOCKET =      0xffff;          /* options for socket level */


/*
 * Address families.
 */
public static final int AF_UNSPEC =       0;               /* unspecified */
public static final int AF_UNIX =         1;               /* local to host (pipes) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_LOCAL =        AF_UNIX;         /* backward compatibility */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET =         2;               /* internetwork: UDP, TCP, etc. */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_IMPLINK =      3;               /* arpanet imp addresses */
public static final int AF_PUP =          4;               /* pup protocols: e.g. BSP */
public static final int AF_CHAOS =        5;               /* mit CHAOS protocols */
public static final int AF_NS =           6;               /* XEROX NS protocols */
public static final int AF_ISO =          7;               /* ISO protocols */
public static final int AF_OSI =          AF_ISO;
public static final int AF_ECMA =         8;               /* European computer manufacturers */
public static final int AF_DATAKIT =      9;               /* datakit protocols */
public static final int AF_CCITT =        10;              /* CCITT protocols, X.25 etc */
public static final int AF_SNA =          11;              /* IBM SNA */
public static final int AF_DECnet =       12;              /* DECnet */
public static final int AF_DLI =          13;              /* DEC Direct data link interface */
public static final int AF_LAT =          14;              /* LAT */
public static final int AF_HYLINK =       15;              /* NSC Hyperchannel */
public static final int AF_APPLETALK =    16;              /* Apple Talk */
public static final int AF_ROUTE =        17;              /* Internal Routing Protocol */
public static final int AF_LINK =         18;              /* Link layer interface */
public static final int pseudo_AF_XTP =   19;              /* eXpress Transfer Protocol (no AF) */
public static final int AF_COIP =         20;              /* connection-oriented IP, aka ST II */
public static final int AF_CNT =          21;              /* Computer Network Technology */
public static final int pseudo_AF_RTIP =  22;              /* Help Identify RTIP packets */
public static final int AF_IPX =          23;              /* Novell Internet Protocol */
public static final int AF_SIP =          24;              /* Simple Internet Protocol */
public static final int pseudo_AF_PIP =   25;              /* Help Identify PIP packets */
public static final int AF_NDRV =         27;              /* Network Driver 'raw' access */
public static final int AF_ISDN =         28;              /* Integrated Services Digital Network */
public static final int AF_E164 =         AF_ISDN;         /* CCITT E.164 recommendation */
public static final int pseudo_AF_KEY =   29;              /* Internal key-management function */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET6 =        30;              /* IPv6 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_NATM =         31;              /* native ATM access */
public static final int AF_SYSTEM =       32;              /* Kernel event messages */
public static final int AF_NETBIOS =      33;              /* NetBIOS */
public static final int AF_PPP =          34;              /* PPP communication protocol */
public static final int pseudo_AF_HDRCMPLT = 35;           /* Used by BPF to not rewrite headers
	                                 *  in interface output routine */
public static final int AF_RESERVED_36 =  36;              /* Reserved for internal usage */
public static final int AF_IEEE80211 =    37;              /* IEEE 802.11 protocol */
public static final int AF_UTUN =         38;
public static final int AF_VSOCK =        40;              /* VM Sockets */
public static final int AF_MAX =          41;
// Targeting ../client/sockaddr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_MAXADDRLEN = 255;
// Targeting ../client/sockproto.java


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
public static final int _SS_MAXSIZE =     128;
public static native @MemberGetter int _SS_ALIGNSIZE();
public static final int _SS_ALIGNSIZE = _SS_ALIGNSIZE();
public static native @MemberGetter int _SS_PAD1SIZE();
public static final int _SS_PAD1SIZE = _SS_PAD1SIZE();
public static native @MemberGetter int _SS_PAD2SIZE();
public static final int _SS_PAD2SIZE = _SS_PAD2SIZE();
// Targeting ../client/sockaddr_storage.java



/*
 * Protocol families, same as address families for now.
 */
public static final int PF_UNSPEC =       AF_UNSPEC;
public static final int PF_LOCAL =        AF_LOCAL;
public static final int PF_UNIX =         PF_LOCAL;        /* backward compatibility */
public static final int PF_INET =         AF_INET;
public static final int PF_IMPLINK =      AF_IMPLINK;
public static final int PF_PUP =          AF_PUP;
public static final int PF_CHAOS =        AF_CHAOS;
public static final int PF_NS =           AF_NS;
public static final int PF_ISO =          AF_ISO;
public static final int PF_OSI =          AF_ISO;
public static final int PF_ECMA =         AF_ECMA;
public static final int PF_DATAKIT =      AF_DATAKIT;
public static final int PF_CCITT =        AF_CCITT;
public static final int PF_SNA =          AF_SNA;
public static final int PF_DECnet =       AF_DECnet;
public static final int PF_DLI =          AF_DLI;
public static final int PF_LAT =          AF_LAT;
public static final int PF_HYLINK =       AF_HYLINK;
public static final int PF_APPLETALK =    AF_APPLETALK;
public static final int PF_ROUTE =        AF_ROUTE;
public static final int PF_LINK =         AF_LINK;
public static final int PF_XTP =          pseudo_AF_XTP;   /* really just proto family, no AF */
public static final int PF_COIP =         AF_COIP;
public static final int PF_CNT =          AF_CNT;
public static final int PF_SIP =          AF_SIP;
public static final int PF_IPX =          AF_IPX;          /* same format as AF_NS */
public static final int PF_RTIP =         pseudo_AF_RTIP;  /* same format as AF_INET */
public static final int PF_PIP =          pseudo_AF_PIP;
public static final int PF_NDRV =         AF_NDRV;
public static final int PF_ISDN =         AF_ISDN;
public static final int PF_KEY =          pseudo_AF_KEY;
public static final int PF_INET6 =        AF_INET6;
public static final int PF_NATM =         AF_NATM;
public static final int PF_SYSTEM =       AF_SYSTEM;
public static final int PF_NETBIOS =      AF_NETBIOS;
public static final int PF_PPP =          AF_PPP;
public static final int PF_RESERVED_36 =  AF_RESERVED_36;
public static final int PF_UTUN =         AF_UTUN;
public static final int PF_VSOCK =        AF_VSOCK;
public static final int PF_MAX =          AF_MAX;

/*
 * These do not have socket-layer support:
 */
public static final int PF_VLAN =         ((int)0x766c616e);  /* 'vlan' */
public static final int PF_BOND =         ((int)0x626f6e64);  /* 'bond' */

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int NET_MAXID =       AF_MAX;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 */
public static final int NET_RT_DUMP =             1;       /* dump; may limit to a.f. */
public static final int NET_RT_FLAGS =            2;       /* by flags, e.g. RESOLVING */
public static final int NET_RT_IFLIST =           3;       /* survey interface list */
public static final int NET_RT_STAT =             4;       /* routing statistics */
public static final int NET_RT_TRASH =            5;       /* routes not in table but not freed */
public static final int NET_RT_IFLIST2 =          6;       /* interface list with addresses */
public static final int NET_RT_DUMP2 =            7;       /* dump; may limit to a.f. */
/*
 * Allows read access non-local host's MAC address
 * if the process has neighbor cache entitlement.
 */
public static final int NET_RT_FLAGS_PRIV =       10;
public static final int NET_RT_MAXID =            11;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */




/*
 * Maximum queue length specifiable by listen.
 */
public static final int SOMAXCONN =       128;
// Targeting ../client/msghdr.java





public static final int MSG_OOB =         0x1;             /* process out-of-band data */
public static final int MSG_PEEK =        0x2;             /* peek at incoming message */
public static final int MSG_DONTROUTE =   0x4;             /* send without using routing tables */
public static final int MSG_EOR =         0x8;             /* data completes record */
public static final int MSG_TRUNC =       0x10;            /* data discarded before delivery */
public static final int MSG_CTRUNC =      0x20;            /* control data lost before delivery */
public static final int MSG_WAITALL =     0x40;            /* wait for full request or error */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int MSG_DONTWAIT =    0x80;            /* this message should be nonblocking */
public static final int MSG_EOF =         0x100;           /* data completes connection */
// #ifdef __APPLE__
// #ifdef __APPLE_API_OBSOLETE
public static final int MSG_WAITSTREAM =  0x200;           /* wait up to full request.. may return partial */
// #endif
public static final int MSG_FLUSH =       0x400;           /* Start of 'hold' seq; dump so_temp, deprecated */
public static final int MSG_HOLD =        0x800;           /* Hold frag in so_temp, deprecated */
public static final int MSG_SEND =        0x1000;          /* Send the packet in so_temp, deprecated */
public static final int MSG_HAVEMORE =    0x2000;          /* Data ready to be read */
public static final int MSG_RCVMORE =     0x4000;          /* Data remains in current pkt */
// #endif
public static final int MSG_NEEDSA =      0x10000;         /* Fail receive if socket address cannot be allocated */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #if __DARWIN_C_LEVEL >= 200809L
public static final int MSG_NOSIGNAL =    0x80000;
// Targeting ../client/cmsghdr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #ifndef __APPLE__
// #endif
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* given pointer to struct cmsghdr, return pointer to data */
// #define CMSG_DATA(cmsg)         ((unsigned char *)(cmsg) +
// 	__DARWIN_ALIGN32(sizeof(struct cmsghdr)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
// #define CMSG_FIRSTHDR(mhdr)
// 	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ?
// 	    (struct cmsghdr *)(mhdr)->msg_control :
// 	    (struct cmsghdr *)0L)


/*
 * Given pointer to struct cmsghdr, return pointer to next cmsghdr
 * RFC 2292 says that CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr)
 */
// #define CMSG_NXTHDR(mhdr, cmsg)
// 	((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) :
// 	    ((((unsigned char *)(cmsg) +
// 	    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) +
// 	    __DARWIN_ALIGN32(sizeof(struct cmsghdr))) >
// 	    ((unsigned char *)(mhdr)->msg_control +
// 	    (mhdr)->msg_controllen)) ?
// 	        (struct cmsghdr *)0L /* NULL */ :
// 	        (struct cmsghdr *)(void *)((unsigned char *)(cmsg) +
// 	            __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/* RFC 2292 additions */
// #define CMSG_SPACE(l)           (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(l))
// #define CMSG_LEN(l)             (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (l))

// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* "Socket"-level control message types: */
public static final int SCM_RIGHTS =                      0x01;    /* access rights (array of int) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SCM_TIMESTAMP =                   0x02;    /* timestamp (struct timeval) */
public static final int SCM_CREDS =                       0x03;    /* process creds (struct cmsgcred) */
public static final int SCM_TIMESTAMP_MONOTONIC =         0x04;    /* timestamp (uint64_t) */


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * howto arguments for shutdown(2), specified by Posix.1g.
 */
public static final int SHUT_RD =         0;               /* shut down the reading side */
public static final int SHUT_WR =         1;               /* shut down the writing side */
public static final int SHUT_RDWR =       2;
// Targeting ../client/sf_hdtr.java




// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */




// #endif /* !_SYS_SOCKET_H_ */


// Parsed from netinet/in.h

/*
 * Copyright (c) 2000-2018 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.h	8.3 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/in.h,v 1.48.2.2 2001/04/21 14:53:06 ume Exp $
 */

// #ifndef _NETINET_IN_H_
// #define _NETINET_IN_H_

// #include <sys/appleapiopts.h>
// #include <stdint.h>             /* uint(8|16|32)_t */

// #include <Availability.h>


// #include <sys/_types/_in_addr_t.h>
// #include <sys/_types/_in_port_t.h>

/*
 * POSIX 1003.1-2003
 * "Inclusion of the <netinet/in.h> header may also make visible all
 *  symbols from <inttypes.h> and <sys/socket.h>".
 */
// #include <sys/socket.h>

/*
 * The following two #includes insure htonl and family are defined
 */
// #include <machine/endian.h>
// #include <sys/_endian.h>

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, and numerous additions.
 */

/*
 * Protocols (RFC 1700)
 */
public static final int IPPROTO_IP =              0;               /* dummy for IP */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_HOPOPTS = 0;               /* IP6 hop-by-hop options */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_ICMP =            1;               /* control message protocol */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_IGMP =            2;               /* group mgmt protocol */
public static final int IPPROTO_GGP =             3;               /* gateway^2 (deprecated) */
public static final int IPPROTO_IPV4 =            4;               /* IPv4 encapsulation */
public static final int IPPROTO_IPIP =            IPPROTO_IPV4;    /* for compatibility */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_TCP =             6;               /* tcp */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_ST =              7;               /* Stream protocol II */
public static final int IPPROTO_EGP =             8;               /* exterior gateway protocol */
public static final int IPPROTO_PIGP =            9;               /* private interior gateway */
public static final int IPPROTO_RCCMON =          10;              /* BBN RCC Monitoring */
public static final int IPPROTO_NVPII =           11;              /* network voice protocol*/
public static final int IPPROTO_PUP =             12;              /* pup */
public static final int IPPROTO_ARGUS =           13;              /* Argus */
public static final int IPPROTO_EMCON =           14;              /* EMCON */
public static final int IPPROTO_XNET =            15;              /* Cross Net Debugger */
public static final int IPPROTO_CHAOS =           16;              /* Chaos*/
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_UDP =             17;              /* user datagram protocol */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_MUX =             18;              /* Multiplexing */
public static final int IPPROTO_MEAS =            19;              /* DCN Measurement Subsystems */
public static final int IPPROTO_HMP =             20;              /* Host Monitoring */
public static final int IPPROTO_PRM =             21;              /* Packet Radio Measurement */
public static final int IPPROTO_IDP =             22;              /* xns idp */
public static final int IPPROTO_TRUNK1 =          23;              /* Trunk-1 */
public static final int IPPROTO_TRUNK2 =          24;              /* Trunk-2 */
public static final int IPPROTO_LEAF1 =           25;              /* Leaf-1 */
public static final int IPPROTO_LEAF2 =           26;              /* Leaf-2 */
public static final int IPPROTO_RDP =             27;              /* Reliable Data */
public static final int IPPROTO_IRTP =            28;              /* Reliable Transaction */
public static final int IPPROTO_TP =              29;              /* tp-4 w/ class negotiation */
public static final int IPPROTO_BLT =             30;              /* Bulk Data Transfer */
public static final int IPPROTO_NSP =             31;              /* Network Services */
public static final int IPPROTO_INP =             32;              /* Merit Internodal */
public static final int IPPROTO_SEP =             33;              /* Sequential Exchange */
public static final int IPPROTO_3PC =             34;              /* Third Party Connect */
public static final int IPPROTO_IDPR =            35;              /* InterDomain Policy Routing */
public static final int IPPROTO_XTP =             36;              /* XTP */
public static final int IPPROTO_DDP =             37;              /* Datagram Delivery */
public static final int IPPROTO_CMTP =            38;              /* Control Message Transport */
public static final int IPPROTO_TPXX =            39;              /* TP++ Transport */
public static final int IPPROTO_IL =              40;              /* IL transport protocol */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_IPV6 =            41;              /* IP6 header */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_SDRP =            42;              /* Source Demand Routing */
public static final int IPPROTO_ROUTING = 43;              /* IP6 routing header */
public static final int IPPROTO_FRAGMENT =        44;              /* IP6 fragmentation header */
public static final int IPPROTO_IDRP =            45;              /* InterDomain Routing*/
public static final int IPPROTO_RSVP =            46;              /* resource reservation */
public static final int IPPROTO_GRE =             47;              /* General Routing Encap. */
public static final int IPPROTO_MHRP =            48;              /* Mobile Host Routing */
public static final int IPPROTO_BHA =             49;              /* BHA */
public static final int IPPROTO_ESP =             50;              /* IP6 Encap Sec. Payload */
public static final int IPPROTO_AH =              51;              /* IP6 Auth Header */
public static final int IPPROTO_INLSP =           52;              /* Integ. Net Layer Security */
public static final int IPPROTO_SWIPE =           53;              /* IP with encryption */
public static final int IPPROTO_NHRP =            54;              /* Next Hop Resolution */
/* 55-57: Unassigned */
public static final int IPPROTO_ICMPV6 =          58;              /* ICMP6 */
public static final int IPPROTO_NONE =            59;              /* IP6 no next header */
public static final int IPPROTO_DSTOPTS =         60;              /* IP6 destination option */
public static final int IPPROTO_AHIP =            61;              /* any host internal protocol */
public static final int IPPROTO_CFTP =            62;              /* CFTP */
public static final int IPPROTO_HELLO =           63;              /* "hello" routing protocol */
public static final int IPPROTO_SATEXPAK =        64;              /* SATNET/Backroom EXPAK */
public static final int IPPROTO_KRYPTOLAN =       65;              /* Kryptolan */
public static final int IPPROTO_RVD =             66;              /* Remote Virtual Disk */
public static final int IPPROTO_IPPC =            67;              /* Pluribus Packet Core */
public static final int IPPROTO_ADFS =            68;              /* Any distributed FS */
public static final int IPPROTO_SATMON =          69;              /* Satnet Monitoring */
public static final int IPPROTO_VISA =            70;              /* VISA Protocol */
public static final int IPPROTO_IPCV =            71;              /* Packet Core Utility */
public static final int IPPROTO_CPNX =            72;              /* Comp. Prot. Net. Executive */
public static final int IPPROTO_CPHB =            73;              /* Comp. Prot. HeartBeat */
public static final int IPPROTO_WSN =             74;              /* Wang Span Network */
public static final int IPPROTO_PVP =             75;              /* Packet Video Protocol */
public static final int IPPROTO_BRSATMON =        76;              /* BackRoom SATNET Monitoring */
public static final int IPPROTO_ND =              77;              /* Sun net disk proto (temp.) */
public static final int IPPROTO_WBMON =           78;              /* WIDEBAND Monitoring */
public static final int IPPROTO_WBEXPAK =         79;              /* WIDEBAND EXPAK */
public static final int IPPROTO_EON =             80;              /* ISO cnlp */
public static final int IPPROTO_VMTP =            81;              /* VMTP */
public static final int IPPROTO_SVMTP =           82;              /* Secure VMTP */
public static final int IPPROTO_VINES =           83;              /* Banyon VINES */
public static final int IPPROTO_TTP =             84;              /* TTP */
public static final int IPPROTO_IGP =             85;              /* NSFNET-IGP */
public static final int IPPROTO_DGP =             86;              /* dissimilar gateway prot. */
public static final int IPPROTO_TCF =             87;              /* TCF */
public static final int IPPROTO_IGRP =            88;              /* Cisco/GXS IGRP */
public static final int IPPROTO_OSPFIGP =         89;              /* OSPFIGP */
public static final int IPPROTO_SRPC =            90;              /* Strite RPC protocol */
public static final int IPPROTO_LARP =            91;              /* Locus Address Resoloution */
public static final int IPPROTO_MTP =             92;              /* Multicast Transport */
public static final int IPPROTO_AX25 =            93;              /* AX.25 Frames */
public static final int IPPROTO_IPEIP =           94;              /* IP encapsulated in IP */
public static final int IPPROTO_MICP =            95;              /* Mobile Int.ing control */
public static final int IPPROTO_SCCSP =           96;              /* Semaphore Comm. security */
public static final int IPPROTO_ETHERIP =         97;              /* Ethernet IP encapsulation */
public static final int IPPROTO_ENCAP =           98;              /* encapsulation header */
public static final int IPPROTO_APES =            99;              /* any private encr. scheme */
public static final int IPPROTO_GMTP =            100;             /* GMTP*/
/* 101-252: Partly Unassigned */
public static final int IPPROTO_PIM =             103;             /* Protocol Independent Mcast */
public static final int IPPROTO_IPCOMP =          108;             /* payload compression (IPComp) */
public static final int IPPROTO_PGM =             113;             /* PGM */
public static final int IPPROTO_SCTP =            132;             /* SCTP */
/* 253-254: Experimentation and testing; 255: Reserved (RFC3692) */
/* BSD Private, local use, namespace incursion */
public static final int IPPROTO_DIVERT =          254;             /* divert pseudo-protocol */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int IPPROTO_RAW =             255;             /* raw IP packet */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int IPPROTO_MAX =             256;

/* last return value of *_input(), meaning "all job for this pkt is done".  */
public static final int IPPROTO_DONE =            257;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

/*
 * Local port number conventions:
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 * The default range is IPPORT_RESERVED through
 * IPPORT_USERRESERVED, although that is settable by sysctl.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
 * into the "high" range.  These are reserved for client outbound connections
 * which do not want to be filtered by any firewalls.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.  This
 * convention is based on "vouchsafe" principles only.  It is only secure
 * if you trust the remote host to restrict these ports.
 *
 * The default range of ports and the high range can be changed by
 * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
 *
 * Changing those values has bad security implications if you are
 * using a a stateless firewall that is allowing packets outside of that
 * range in order to allow transparent outgoing connections.
 *
 * Such a firewall configuration will generally depend on the use of these
 * default values.  If you change them, you may find your Security
 * Administrator looking for you with a heavy object.
 *
 * For a slightly more orthodox text view on this:
 *
 *            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
 *
 *    port numbers are divided into three ranges:
 *
 *                0 -  1023 Well Known Ports
 *             1024 - 49151 Registered Ports
 *            49152 - 65535 Dynamic and/or Private Ports
 *
 */

public static final int __DARWIN_IPPORT_RESERVED =        1024;

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
 * Ports > IPPORT_USERRESERVED are reserved
 * for servers, not necessarily privileged.  (IP_PORTRANGE_DEFAULT)
 */
// #ifndef IPPORT_RESERVED
public static final int IPPORT_RESERVED =         __DARWIN_IPPORT_RESERVED;
// #endif
public static final int IPPORT_USERRESERVED =     5000;

/*
 * Default local port range to use by setting IP_PORTRANGE_HIGH
 */
public static final int IPPORT_HIFIRSTAUTO =      49152;
public static final int IPPORT_HILASTAUTO =       65535;

/*
 * Scanning for a free reserved port return a value below IPPORT_RESERVED,
 * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
 * 512, but that conflicts with some well-known-services that firewalls may
 * have a fit if we use.
 */
public static final int IPPORT_RESERVEDSTART =    600;
// Targeting ../client/in_addr.java



/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
public static final int INADDR_ANY =              (int)0x00000000;
public static final int INADDR_BROADCAST =        (int)0xffffffff;   /* must be masked */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #define IN_CLASSA(i)            (((u_int32_t)(i) & 0x80000000) == 0)
public static final int IN_CLASSA_NET =           0xff000000;
public static final int IN_CLASSA_NSHIFT =        24;
public static final int IN_CLASSA_HOST =          0x00ffffff;
public static final int IN_CLASSA_MAX =           128;

// #define IN_CLASSB(i)            (((u_int32_t)(i) & 0xc0000000) == 0x80000000)
public static final int IN_CLASSB_NET =           0xffff0000;
public static final int IN_CLASSB_NSHIFT =        16;
public static final int IN_CLASSB_HOST =          0x0000ffff;
public static final int IN_CLASSB_MAX =           65536;

// #define IN_CLASSC(i)            (((u_int32_t)(i) & 0xe0000000) == 0xc0000000)
public static final int IN_CLASSC_NET =           0xffffff00;
public static final int IN_CLASSC_NSHIFT =        8;
public static final int IN_CLASSC_HOST =          0x000000ff;

// #define IN_CLASSD(i)            (((u_int32_t)(i) & 0xf0000000) == 0xe0000000)
public static final int IN_CLASSD_NET =           0xf0000000;      /* These ones aren't really */
public static final int IN_CLASSD_NSHIFT =        28;              /* net and host fields, but */
public static final int IN_CLASSD_HOST =          0x0fffffff;      /* routing needn't know.    */
// #define IN_MULTICAST(i)         IN_CLASSD(i)

// #define IN_EXPERIMENTAL(i)      (((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
// #define IN_BADCLASS(i)          (((u_int32_t)(i) & 0xf0000000) == 0xf0000000)

public static final int INADDR_LOOPBACK =         (int)0x7f000001;

public static final int INADDR_NONE =             0xffffffff;              /* -1 return */

public static final int INADDR_UNSPEC_GROUP =     (int)0xe0000000;   /* 224.0.0.0 */
public static final int INADDR_ALLHOSTS_GROUP =   (int)0xe0000001;   /* 224.0.0.1 */
public static final int INADDR_ALLRTRS_GROUP =    (int)0xe0000002;   /* 224.0.0.2 */
public static final int INADDR_ALLRPTS_GROUP =    (int)0xe0000016;   /* 224.0.0.22, IGMPv3 */
public static final int INADDR_CARP_GROUP =       (int)0xe0000012;   /* 224.0.0.18 */
public static final int INADDR_PFSYNC_GROUP =     (int)0xe00000f0;   /* 224.0.0.240 */
public static final int INADDR_ALLMDNS_GROUP =    (int)0xe00000fb;   /* 224.0.0.251 */
public static final int INADDR_MAX_LOCAL_GROUP =  (int)0xe00000ff;   /* 224.0.0.255 */

// #ifdef __APPLE__
public static final int IN_LINKLOCALNETNUM =      (int)0xA9FE0000; /* 169.254.0.0 */
// #define IN_LINKLOCAL(i)         (((u_int32_t)(i) & IN_CLASSB_NET) == IN_LINKLOCALNETNUM)
// #define IN_LOOPBACK(i)          (((u_int32_t)(i) & 0xff000000) == 0x7f000000)
// #define IN_ZERONET(i)           (((u_int32_t)(i) & 0xff000000) == 0)

// #define IN_PRIVATE(i)   ((((u_int32_t)(i) & 0xff000000) == 0x0a000000) ||
// 	                 (((u_int32_t)(i) & 0xfff00000) == 0xac100000) ||
// 	                 (((u_int32_t)(i) & 0xffff0000) == 0xc0a80000))


// #define IN_LOCAL_GROUP(i)       (((u_int32_t)(i) & 0xffffff00) == 0xe0000000)

// #define IN_ANY_LOCAL(i)         (IN_LINKLOCAL(i) || IN_LOCAL_GROUP(i))
// #endif /* __APPLE__ */

public static final int IN_LOOPBACKNET =          127;
// Targeting ../client/sockaddr_in.java



// #define IN_ARE_ADDR_EQUAL(a, b)
//     (bcmp(&(a)->s_addr, &(b)->s_addr,
// 	sizeof (struct in_addr)) == 0)


public static final int INET_ADDRSTRLEN =                 16;
// Targeting ../client/ip_opts.java



/*
 * Options for use with [gs]etsockopt at the IP level.
 * First word of comment is data type; bool is stored in int.
 */
public static final int IP_OPTIONS =              1;    /* buf/ip_opts; set/get IP options */
public static final int IP_HDRINCL =              2;    /* int; header is included with data */
public static final int IP_TOS =                  3;    /* int; IP type of service and preced. */
public static final int IP_TTL =                  4;    /* int; IP time to live */
public static final int IP_RECVOPTS =             5;    /* bool; receive all IP opts w/dgram */
public static final int IP_RECVRETOPTS =          6;    /* bool; receive IP opts for response */
public static final int IP_RECVDSTADDR =          7;    /* bool; receive IP dst addr w/dgram */
public static final int IP_RETOPTS =              8;    /* ip_opts; set/get IP options */
public static final int IP_MULTICAST_IF =         9;    /* u_char; set/get IP multicast i/f  */
public static final int IP_MULTICAST_TTL =        10;   /* u_char; set/get IP multicast ttl */
public static final int IP_MULTICAST_LOOP =       11;   /* u_char; set/get IP multicast loopback */
public static final int IP_ADD_MEMBERSHIP =       12;   /* ip_mreq; add an IP group membership */
public static final int IP_DROP_MEMBERSHIP =      13;   /* ip_mreq; drop an IP group membership */
public static final int IP_MULTICAST_VIF =        14;   /* set/get IP mcast virt. iface */
public static final int IP_RSVP_ON =              15;   /* enable RSVP in kernel */
public static final int IP_RSVP_OFF =             16;   /* disable RSVP in kernel */
public static final int IP_RSVP_VIF_ON =          17;   /* set RSVP per-vif socket */
public static final int IP_RSVP_VIF_OFF =         18;   /* unset RSVP per-vif socket */
public static final int IP_PORTRANGE =            19;   /* int; range to choose for unspec port */
public static final int IP_RECVIF =               20;   /* bool; receive reception if w/dgram */
/* for IPSEC */
public static final int IP_IPSEC_POLICY =         21;   /* int; set/get security policy */
public static final int IP_FAITH =                22;   /* deprecated */
// #ifdef __APPLE__
public static final int IP_STRIPHDR =             23;   /* bool: drop receive of raw IP header */
// #endif
public static final int IP_RECVTTL =              24;   /* bool; receive reception TTL w/dgram */
public static final int IP_BOUND_IF =             25;   /* int; set/get bound interface */
public static final int IP_PKTINFO =              26;   /* get pktinfo on recv socket, set src on sent dgram  */
public static final int IP_RECVPKTINFO =          IP_PKTINFO;      /* receive pktinfo w/dgram */
public static final int IP_RECVTOS =              27;   /* bool; receive IP TOS w/dgram */
public static final int IP_DONTFRAG =             28;   /* don't fragment packet */

public static final int IP_FW_ADD =               40;   /* add a firewall rule to chain */
public static final int IP_FW_DEL =               41;   /* delete a firewall rule from chain */
public static final int IP_FW_FLUSH =             42;   /* flush firewall rule chain */
public static final int IP_FW_ZERO =              43;   /* clear single/all firewall counter(s) */
public static final int IP_FW_GET =               44;   /* get entire firewall rule chain */
public static final int IP_FW_RESETLOG =          45;   /* reset logging counters */

/* These older firewall socket option codes are maintained for backward compatibility. */
public static final int IP_OLD_FW_ADD =           50;   /* add a firewall rule to chain */
public static final int IP_OLD_FW_DEL =           51;   /* delete a firewall rule from chain */
public static final int IP_OLD_FW_FLUSH =         52;   /* flush firewall rule chain */
public static final int IP_OLD_FW_ZERO =          53;   /* clear single/all firewall counter(s) */
public static final int IP_OLD_FW_GET =           54;   /* get entire firewall rule chain */
public static final int IP_NAT__XXX =                     55;   /* set/get NAT opts XXX Deprecated, do not use */
public static final int IP_OLD_FW_RESETLOG =      56;   /* reset logging counters */

public static final int IP_DUMMYNET_CONFIGURE =   60;   /* add/configure a dummynet pipe */
public static final int IP_DUMMYNET_DEL =         61;   /* delete a dummynet pipe from chain */
public static final int IP_DUMMYNET_FLUSH =       62;   /* flush dummynet */
public static final int IP_DUMMYNET_GET =         64;   /* get entire dummynet pipes */

public static final int IP_TRAFFIC_MGT_BACKGROUND =       65;   /* int*; get background IO flags; set background IO */
public static final int IP_MULTICAST_IFINDEX =    66;   /* int*; set/get IP multicast i/f index */

/* IPv4 Source Filter Multicast API [RFC3678] */
public static final int IP_ADD_SOURCE_MEMBERSHIP =        70;   /* join a source-specific group */
public static final int IP_DROP_SOURCE_MEMBERSHIP =       71;   /* drop a single source */
public static final int IP_BLOCK_SOURCE =                 72;   /* block a source */
public static final int IP_UNBLOCK_SOURCE =               73;   /* unblock a source */

/* The following option is private; do not use it from user applications. */
public static final int IP_MSFILTER =                     74;   /* set/get filter list */

/* Protocol Independent Multicast API [RFC3678] */
public static final int MCAST_JOIN_GROUP =                80;   /* join an any-source group */
public static final int MCAST_LEAVE_GROUP =               81;   /* leave all sources for group */
public static final int MCAST_JOIN_SOURCE_GROUP =         82;   /* join a source-specific group */
public static final int MCAST_LEAVE_SOURCE_GROUP =        83;   /* leave a single source */
public static final int MCAST_BLOCK_SOURCE =              84;   /* block a source */
public static final int MCAST_UNBLOCK_SOURCE =            85;   /* unblock a source */


/*
 * Defaults and limits for options
 */
public static final int IP_DEFAULT_MULTICAST_TTL =  1;     /* normally limit m'casts to 1 hop  */
public static final int IP_DEFAULT_MULTICAST_LOOP = 1;     /* normally hear sends if a member  */

/*
 * The imo_membership vector for each socket is now dynamically allocated at
 * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
 * according to a power-of-two increment.
 */
public static final int IP_MIN_MEMBERSHIPS =      31;
public static final int IP_MAX_MEMBERSHIPS =      4095;

/*
 * Default resource limits for IPv4 multicast source filtering.
 * These may be modified by sysctl.
 */
public static final int IP_MAX_GROUP_SRC_FILTER =         512;     /* sources per group */
public static final int IP_MAX_SOCK_SRC_FILTER =          128;     /* sources per socket/group */
public static final int IP_MAX_SOCK_MUTE_FILTER =         128;
// Targeting ../client/ip_mreq.java


// Targeting ../client/ip_mreqn.java



// #pragma pack(4)
// Targeting ../client/ip_mreq_source.java


// Targeting ../client/group_req.java


// Targeting ../client/group_source_req.java



// #ifndef __MSFILTERREQ_DEFINED
// #define __MSFILTERREQ_DEFINED
// Targeting ../client/__msfilterreq.java



// #endif /* __MSFILTERREQ_DEFINED */

// #pragma pack()

/*
 * Advanced (Full-state) APIs [RFC3678]
 * The RFC specifies uint_t for the 6th argument to [sg]etsourcefilter().
 * We use uint32_t here to be consistent.
 */
public static native int setipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t") int arg3,
    @Cast("uint32_t") int arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") IntPointer arg3,
    @Cast("uint32_t*") IntPointer arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") IntBuffer arg3,
    @Cast("uint32_t*") IntBuffer arg4, in_addr arg5);
public static native int getipv4sourcefilter(int arg0, @ByVal in_addr arg1, @ByVal in_addr arg2, @Cast("uint32_t*") int[] arg3,
    @Cast("uint32_t*") int[] arg4, in_addr arg5);
public static native int setsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t") int arg4, @Cast("uint32_t") int arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") IntPointer arg4, @Cast("uint32_t*") IntPointer arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") IntBuffer arg4, @Cast("uint32_t*") IntBuffer arg5, sockaddr_storage arg6);
public static native int getsourcefilter(int arg0, @Cast("uint32_t") int arg1, sockaddr arg2, @Cast("socklen_t") int arg3,
    @Cast("uint32_t*") int[] arg4, @Cast("uint32_t*") int[] arg5, sockaddr_storage arg6);

/*
 * Filter modes; also used to represent per-socket filter mode internally.
 */
public static final int MCAST_UNDEFINED = 0;       /* fmode: not yet defined */
public static final int MCAST_INCLUDE =   1;       /* fmode: include these source(s) */
public static final int MCAST_EXCLUDE =   2;       /* fmode: exclude these source(s) */

/*
 * Argument for IP_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
public static final int IP_PORTRANGE_DEFAULT =    0;       /* default range */
public static final int IP_PORTRANGE_HIGH =       1;       /* "high" - request firewall bypass */
public static final int IP_PORTRANGE_LOW =        2;
// Targeting ../client/in_pktinfo.java



/*
 * Definitions for inet sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 */
public static final int IPPROTO_MAXID =   (IPPROTO_AH + 1);        /* don't list to IPPROTO_MAX */


/*
 * Names for IP sysctl objects
 */
public static final int IPCTL_FORWARDING =        1;       /* act as router */
public static final int IPCTL_SENDREDIRECTS =     2;       /* may send redirects when forwarding */
public static final int IPCTL_DEFTTL =            3;       /* default TTL */
// #ifdef notyet
public static final int IPCTL_DEFMTU =            4;       /* default MTU */
// #endif
public static final int IPCTL_RTEXPIRE =          5;       /* cloned route expiration time */
public static final int IPCTL_RTMINEXPIRE =       6;       /* min value for expiration time */
public static final int IPCTL_RTMAXCACHE =        7;       /* trigger level for dynamic expire */
public static final int IPCTL_SOURCEROUTE =       8;       /* may perform source routes */
public static final int IPCTL_DIRECTEDBROADCAST = 9;       /* may re-broadcast received packets */
public static final int IPCTL_INTRQMAXLEN =       10;      /* max length of netisr queue */
public static final int IPCTL_INTRQDROPS =        11;      /* number of netisr q drops */
public static final int IPCTL_STATS =             12;      /* ipstat structure */
public static final int IPCTL_ACCEPTSOURCEROUTE = 13;      /* may accept source routed packets */
public static final int IPCTL_FASTFORWARDING =    14;      /* use fast IP forwarding code */
public static final int IPCTL_KEEPFAITH =         15;      /* deprecated */
public static final int IPCTL_GIF_TTL =           16;      /* default TTL for gif encap packet */
public static final int IPCTL_MAXID =             17;

// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* INET6 stuff */
// #define __KAME_NETINET_IN_H_INCLUDED_
// #include <netinet6/in6.h>
// #undef __KAME_NETINET_IN_H_INCLUDED_



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native int bindresvport(int arg0, sockaddr_in arg1);
public static native int bindresvport_sa(int arg0, sockaddr arg1);
// #endif
// #endif /* _NETINET_IN_H_ */


// Parsed from zixi_definitions.h

// #pragma once

// #include <time.h>

// #ifndef __cplusplus
// 	#ifndef bool
// 	#endif
// #endif

// zixi warning values
public static final int ZIXI_WARNING_OVER_LIMIT =			100;

// zixi error values
// recoverable errors
public static final int ZIXI_ERROR_RECONNECTING =			7;
public static final int ZIXI_ERROR_BUFFER_TO_SMALL =		6;
public static final int ZIXI_ERROR_NOT_READY =			5;
public static final int ZIXI_ERROR_ALREADY_CONNECTED =	4;
public static final int ZIXI_ERROR_ALREADY_INITIALIZED =	3;
public static final int ZIXI_ERROR_STREAM_CHANGED =		2;
public static final int ZIXI_ERROR_INVALID_PARAMETER =	1;

// no error
public static final int ZIXI_ERROR_OK =					0;

// non-recoverable errors
public static final int ZIXI_ERROR_FAILED =				-1;
public static final int ZIXI_ERROR_TIMEOUT =				-2;
public static final int ZIXI_ERROR_NOT_INITIALIZED =		-3;
public static final int ZIXI_ERROR_NOT_CONNECTED =		-4;
public static final int ZIXI_ERROR_DLL_NOT_FOUND =		-5;
public static final int ZIXI_ERROR_FUNCTION_NOT_FOUND =	-6;
public static final int ZIXI_ERROR_AUTHORIZATION_FAILED =	-7;
public static final int ZIXI_ERROR_LICENSING_FAILED =		-8;
public static final int ZIXI_ERROR_NETWORK_ERRORS =		-9;
public static final int ZIXI_ERROR_VERSION =				-10;
public static final int ZIXI_ERROR_SERVER_FULL =			-11;
public static final int ZIXI_ERROR_EOF =					-12;
public static final int ZIXI_ERROR_NOT_SUPPORTED =		-13;
public static final int ZIXI_ERROR_TEST_FAILED =			-14;
public static final int ZIXI_ERROR_RESOLVING_FAILED =		-15;
public static final int ZIXI_ERROR_CACHE_TO_SMALL =		-16;
public static final int ZIXI_ERROR_NETWORK =				-17;
public static final int ZIXI_ERROR_NOT_FOUND =			-18;
public static final int ZIXI_ERROR_BAD_URL =				-19;
public static final int ZIXI_ERROR_FILE_LOCAL =			-20;
public static final int ZIXI_ERROR_FILE_REMOTE =			-21;		
public static final int ZIXI_WARNING_REMOTE_FILE_EXISTS = -22;		//	File cannot be uploaded without 'overwrite' permission.
public static final int ZIXI_ERROR_DECRYPTION =			-23;	
public static final int ZIXI_ERROR_CERTIFICATE =			-24;
public static final int ZIXI_ERROR_WRONG_SRP =			-25;

// zixi encryption types
/** enum ZIXI_ENCRYPTION */
public static final int
	ZIXI_AES_128 = 0,
	ZIXI_AES_192 = 1,
	ZIXI_AES_256 = 2,
	ZIXI_CHACHA20 = 3, // fast cipher for platforms without AES-NI
	ZIXI_NO_ENCRYPTION = 4;
//	ZIXI_AUTO_ENCRYPTION - deprecated - use DTLS on the server side instead

// zixi connection status
/** enum ZIXI_STATUS */
public static final int	
	ZIXI_DISCONNECTED = 0,
	ZIXI_CONNECTING = 1,
	ZIXI_CONNECTED = 2,
	ZIXI_DISCONNECTING = 3,
	ZIXI_RECONNECTING = 4;

// zixi log levels
/** enum ZIXI_LOG_LEVELS */
public static final int
	ZIXI_LOG_NONE = -1,
	ZIXI_LOG_ALL = 0,
	ZIXI_LOG_DEBUG = 1,
	ZIXI_LOG_INFO = 2,
	ZIXI_LOG_WARNINGS = 3,
	ZIXI_LOG_ERRORS = 4,
	ZIXI_LOG_FATAL = 5;

/** enum ZIXI_LATENCY_MODE */
public static final int
	ZIXI_LATENCY_STATIC = 0,
	ZIXI_LATENCY_INCREASING = 1,
	ZIXI_LATENCY_DYNAMIC = 2;

/** enum ZIXI_ADAPTIVE_MODE */
public static final int
	ZIXI_ADAPTIVE_NONE = 0,
	ZIXI_ADAPTIVE_ENCODER = 1,
	ZIXI_ADAPTIVE_FEC = 2;

/** enum ZIXI_FEC_MODE */
public static final int
	ZIXI_FEC_OFF = 0,
	ZIXI_FEC_ON = 1,
	ZIXI_FEC_ADAPTIVE = 2;

/** enum ZIXI_VIDEO_CODECS */
public static final int
	ZIXI_VIDEO_CODEC_NONE = 0,
	ZIXI_VIDEO_CODEC_H264 = 1,
	ZIXI_VIDEO_CODEC_HEVC = 2;

/** enum ZIXI_AUDIO_CODECS */
public static final int
	ZIXI_AUDIO_CODEC_NONE = 0,
	ZIXI_AUDIO_CODEC_AAC	 = 1,
	ZIXI_AUDIO_CODEC_OPUS = 2;


/** enum ZIXI_DTLS_CERTIFICATE_VERIFICATION_STATUS */
public static final int
	ZIXI_DTLS_CERT_OK					 = 0,		//	Certificate verified.
	ZIXI_DTLS_CERT_NOT_RECEIVED			 = 1,		//	Server did not send any certificate.
	ZIXI_DLTS_CERT_INVALID_CERTIFICATE	 = 2,		//	Certificate in not valid.
	ZIXI_DTLS_CERT_NOT_VERIFIED			 = 3,		//	Certificate verification failed.
	ZIXI_DTLS_CERT_SELF_SIGNED			 = 4,		//	Certificate is self signed.
	ZIXI_DTLS_CERT_EXPIRED				 = 5,		//	Certificate is expired.
	ZIXI_DTLS_CERT_NOT_YET_VALID		 = 6,		//	Certificate is not yet valid.
	ZIXI_DTLS_CERT_INVALID_CA			 = 7,		//	Certificate authority not recognized.
	ZIXI_DTLS_CERT_HOSTNAME_MISMATCH	 = 8,		//	Certificate issued to hostname different from one provided in connection parameters.
	ZIXI_DTLS_WRONG_SRP					 = 9,		//	Wrong username/password.
	ZIXI_DTLS_INVALID_SSL_CONNECTION	 = 10;		//	Invalid SSL connection.
// Targeting ../client/ZIXI_STREAM_INFO.java


// Targeting ../client/ZIXI_NETWORK_STATS.java


// Targeting ../client/ZIXI_ERROR_CORRECTION_STATS.java


// Targeting ../client/ZIXI_CONNECTION_STATS.java


// Targeting ../client/ZIXI_BITRATE_CHANGED_FUNC.java


// Targeting ../client/ZIXI_STATUS_FUNC.java


// Targeting ../client/ZIXI_NEW_STREAM_FUNC.java


// Targeting ../client/ZIXI_LOG_FUNC.java


// Targeting ../client/ZIXI_IO_FUNCTION.java


// Targeting ../client/ZIXI_RELEASE_FUNCTION.java


// Targeting ../client/ZIXI_RTMP_HANDLE_WRITE_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_WRITE_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_HANDLE_READ_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_READ_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_CALLBACKS.java



public static final int ZIXI_GUID_LENGTH =	128;
public static final int ZIXI_SESSION_LENGTH =	128;
public static final int ZIXI_CHANNEL_LENGTH =	64;

public static final int ZIXI_MAX_ADAPTIVE_STREAMS =	16;
// Targeting ../client/ZIXI_MEDIA_INFO.java


// Targeting ../client/ZIXI_FAILOVER_COMPONENT_STATS.java



/** enum ZIXI_PROTOCOL */
public static final int
	ZIXI_PROTOCOL_UDP = 0,
	ZIXI_PROTOCOL_MMT = 1,
	ZIXI_PROTOCOL_RIST_SIMPLE = 2,
	ZIXI_PROTOCOL_RIST_MAIN = 3,
	ZIXI_PROTOCOL_HTTP = 4,
	ZIXI_PROTOCOL_HTTPS = 5;


/** enum ZIXI_FAILOVER_MODE */
public static final int
	ZIXI_FAILOVER_MODE_NONE = 0,	//	streams are assumed to be different, no merging will be attemted.
	ZIXI_FAILOVER_MODE_RTP = 1,			//	merge by RTP headers. SMPTE 2022-7
	ZIXI_FAILOVER_MODE_CONTENT = 2;		//	merge by RTP headers if available or by TS content.


// Parsed from zixi_client_interface.h

// #pragma once

// #include "zixi_definitions.h"
// #ifdef WIN32
// #else
//   #if __GNUC__ >= 4
//     #define DLL_EXPORT __attribute__ ((visibility ("default")))
//   #else
//     #define DLL_EXPORT
//   #endif
// #endif


// #ifdef __cplusplus
// #endif

/**
\mainpage  ZIXI Client Interface
\section	API for using ZIXI client interface.
*/



//--------------------------------------------------------
//			Initialization functions					
//--------------------------------------------------------

/**
\brief      initializes zixi environment.
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_ALREADY_INITIALIZED
@return		ZIXI_ERROR_DLL_NOT_FOUND
*/
public static native int zixi_init();

/**
\brief		cleans up zixi environment.
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
*/
public static native int zixi_destroy();

/**
\brief		initialize a handle for zixi connection.
<p>
@param		handle[out] - returned handle upon success, destroy with zixi_delete_connection_handle function.
<p>
@return      ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
<p>
*/
public static native int zixi_init_connection_handle(@Cast("void**") PointerPointer handle);
public static native int zixi_init_connection_handle(@Cast("void**") @ByPtrPtr Pointer handle);

/**
\brief		 destroys zixi connection handle.
<p>
@param		 handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_delete_connection_handle(Pointer handle);



/**
\brief		initialize a handle for zixi failover group.
<p>
@param		group_handle[out]	- handle to initialized group
@param		inputs				- amount of input streams in group
@param		input_handles[out]	- array of initialized handles for each component - handles should be configured and connected. can't read from these handles, and can't destroy them directly.
@param		search_window_ms	- search window to look for matches between components. streams are delayed up to this amount
@param		priorities			- array of priorities. 0 - backup stream; 1 - primary stream, optional, can be NULL.
@param		max_bitrate			- max bitrate expected on streams in bps.
@param		mode				- type of merge (None / RTP headers / Content). 
								  * Streams must be binary identical for merging to succeed.
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_init_failover_group(@Cast("void**") PointerPointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntPointer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntPointer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntBuffer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, int[] priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);


/**
\brief		destroy and cleanup handle to zixi failover group.
<p>
@param		group_handle		- handle to initialized group
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_delete_failover_group( Pointer group_handle );


//--------------------------------------------------------
//			Configuration functions						
//--------------------------------------------------------


/**
\brief		reconfigure logging to new level or to different function.
<p>
@param		log_level	  - log detail level, 
						    [-1] to turn off , 	
						    [0] to log everything (significantly hurt performance - only for deep debugging) , 
						    [1-5] different log levels (3 recommended)
@param		log_func	  - logging function
@param		log_user_data - user data that will be returned as the first parameter in log_func
<p>
@return     ZIXI_ERROR_DLL_NOT_FOUND
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_client_configure_logging(int log_level, ZIXI_LOG_FUNC log_func, Pointer log_user_data);


/**
\brief		configure client id and session id.
			
			client id must be unique on a per broadcaster level.
			session id is used for authorization.
			when using RIST protocol - guid/session are used as SRP user/password for client authentication 
<p>
Warnings:	 Call zixi_configure_id(..) before the first zixi_connect(..)/zixi_async_connect(..)
<p>
@param		handle   - a handle to zixi connection returned by zixi_init_connection_handle
@param		guid	 - a unique identifier of the current client
@param		session	 - a session identifier that will be used for authorization
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_id(Pointer handle, @Cast("const char*") BytePointer guid, @Cast("const char*") BytePointer session);
public static native int zixi_configure_id(Pointer handle, String guid, String session);

/**
\brief		configure the cache that will be used when in progressive-download (PDL) mode.
<p>
Warnings: Cache size has a minimal value of several seconds of video. 
		  The minimal size is determined by the library on stream connection,
		  and depends on the individual stream and connection parameters.
		  If the provided cache size is too small, PDL mode will fail.
			 
		  You can not provide custom buffer and cache_path at the same time. 
		  At least one of the parameters must be NULL.
<p>
@param		handle        - a handle to zixi connection returned by zixi_init_connection_handle
@param		cache_size	  - the size of the cache to be used in progressive-download (PDL) mode, in bytes.
@param		cache_path	  - a path to a cache file, set to NULL to use in memory cache.
@param		custom_buffer - a pointer to preallocated buffer to be used for the cache 
							(must be at least cache_size bytes). 
							Set to NULL for internal allocation of the memory.
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") BytePointer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") ByteBuffer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") byte[] custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") BytePointer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") ByteBuffer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") byte[] custom_buffer);


/**
<p>
\brief		 Configure error correction parameters, doesn't affect connection time.
			 
@param		 handle				- a handle to zixi connection returned by zixi_init_connection_handle
@param		 max_latency		- maximum latency, higher values allow more time for error correction.
@param		 latency_mode		- select latency mode, static/increasing recomended for players, dynamic for conversion to tcp protocols
@param		 fec_mode			- one of the ZIXI_FEC_MODE enum values
@param		 fec_overhead		- % of overhead over the original stream.
@param		 fec_block_ms		- fec block size in milli seconds  .
@param		 fec_content_aware	- true=enable content aware / false=disable content aware 
@param		 stuff_null_on_unrecovered - true=return a null packet when a packet cannot be recovered
@param		 max_output_jitter	- cap output jitter in milliseconds (recommended 0 to disable)
@param		fixed_end_to_end_delay - when true, decrease the propogation delay from max_latency to guarentee syncronization between receivers (default false)
<p>
@return		 ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_INVALID_PARAMETER
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_configure_error_correction(Pointer handle, @Cast("unsigned int") int max_latency, @Cast("ZIXI_LATENCY_MODE") int latency_mode, @Cast("ZIXI_FEC_MODE") int fec_mode, @Cast("unsigned int") int fec_overhead, @Cast("unsigned int") int fec_block_ms, @Cast("bool") boolean fec_content_aware, @Cast("bool") boolean stuff_null_on_unrecovered, @Cast("unsigned int") int max_output_jitter, @Cast("bool") boolean fixed_end_to_end_delay);


/**
\brief		 Configure decryption parameters for an encrypted stream.
		    
			 If the stream is not encrypted this will have no effect.
<p>
@param		 handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		 type   - encryption type
@param		 key	   - decryption key
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return  	 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_INVALID_PARAMETER
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_configure_decryption(Pointer handle, @Cast("ZIXI_ENCRYPTION") int type, @Cast("const char*") BytePointer key);
public static native int zixi_configure_decryption(Pointer handle, @Cast("ZIXI_ENCRYPTION") int type, String key);

/**
\brief		connect to a URL in 'zixi://' format
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		 url					- URL in zixi:// format
@param		 low_latency			- enable low_latency mode at the cost of connection time
@param		 callbacks				- callback functions to handle different events
@param		 ignore_dtls_cert_error - ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
@param		dtls_only				- connect only using DTLS protocol, never fallback to unencrypted
@param		skip_rtp				- if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
<p>
URL format:
zixi://[user[:session]\]server[:port]/channel
<p>
for eg:
zixi://myserver.com/news
zixi://myserver.com:2077/news
zixi://guest42\myserver.com:2077/news
zixi://guest42:hashashash\myserver.com:2077/news
zixi://my\email.com\myserver.com:2077/news
zixi://my\email.com:mypassword\myserver.com:2077/news
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_connect_url(Pointer handle, @Cast("const char*") BytePointer url, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean dtls_only, @Cast("bool") boolean skip_rtp);
public static native int zixi_connect_url(Pointer handle, String url, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean dtls_only, @Cast("bool") boolean skip_rtp);

/**
\brief		download a URL in 'zixi://' format
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		url						- URL in zixi:// format. see zixi_connect_url
@param		offset					- start dowload file from this offset, in bytes
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
<p>
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_download_url(Pointer handle, @Cast("const char*") BytePointer url, @Cast("unsigned long long") long bitrate, @Cast("unsigned long long") long offset, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);
public static native int zixi_download_url(Pointer handle, String url, @Cast("unsigned long long") long bitrate, @Cast("unsigned long long") long offset, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);

/**
\brief		Configure the all the main and alternative streams showing a given channel
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		streams			- a vector of the stream id's
@param		bitrates		- a vector of bitrates corresponding to the given streams
@param		count			- the number of streams
@param		auto_migrate	- adaptive streaming - allow automatic switching between bitrates
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") PointerPointer streams, @Cast("unsigned long long*") LongPointer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr BytePointer streams, @Cast("unsigned long long*") LongPointer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr ByteBuffer streams, @Cast("unsigned long long*") LongBuffer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr byte[] streams, @Cast("unsigned long long*") long[] bitrates, int count, @Cast("bool") boolean auto_migrate);

/**
\brief		replace the internal socket communication with external read/write functions
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		read_function   - ptr for read function.
@param      read_param      - ptr for read parameters.
@param      write_function  - ptr for write function.
@param      write_param     - ptr for write parameters.
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return     ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_custom_io(Pointer handle, ZIXI_IO_FUNCTION read_function, Pointer read_param, ZIXI_IO_FUNCTION write_function, Pointer write_param);


/**
\brief		configure local network interface and port
			
			call before zixi_connect, zixi_async_connect, zixi_accept, zixi_connect_url or zixi_download_url
<p>
@param		handle		- a handle to zixi connection returned by zixi_init_connection_handle
@param		local_nic	- null terminated string of the local IP address to use. use null or "0.0.0.0" for any local IP
@param		local_port	- local port number. use 0 for automatic port selection
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_local_nic(Pointer handle, @Cast("const char*") BytePointer local_nic, @Cast("unsigned short") short local_port);
public static native int zixi_configure_local_nic(Pointer handle, String local_nic, @Cast("unsigned short") short local_port);

/**
\brief		configure adaptive parameters
			<p>
			call before zixi_connect, zixi_async_connect, zixi_accept, zixi_connect_url or zixi_download_url
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		initial_bitrate	- upper bound on starting bitrate
@param		max_bitrate		- maximum bitrate to use for adaptation
@param		down_threshold	- error correction threshold for adaptive down decisions, should be less then max latency [ms]
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_adaptive(Pointer handle, @Cast("unsigned int") int initial_bitrate, @Cast("unsigned int") int max_bitrate, int down_threshold);

//--------------------------------------------------------
//			Connect/Disconnect functions
//--------------------------------------------------------

/**
\brief		Connect to a broadcaster , Returns immediately.
			
			ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		host					- hostname or ip of the broadcaster
@param		port					- public port of the broadcaster
@param		index					- stream index from the vector of streams that was configured using zixi_configure_channel
@param		low_latency				- enable low_latency mode at the cost of connection time
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_async_connect(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean skip_rtp);
public static native int zixi_async_connect(Pointer handle, String host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean skip_rtp);

/**
\brief			Connect to a broadcaster , Returns after connection succeeded/failed.
				<p>
				ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		host					- hostname or ip of the broadcaster
@param		port					- public port of the broadcaster
@param		index					- stream index from the vector of streams that was configured using zixi_configure_channel
@param		low_latency				- enable low_latency mode at the cost of connection time
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
@param		skip_rtp				- if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_RECONNECTING
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_connect(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);
public static native int zixi_connect(Pointer handle, String host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);

/**
\brief			Wait for a connection from a feeder
				<p>
				ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		port		 - port on which the connection will be established
@param		callbacks	 - callback functions to handle different events
@param		skip_rtp     - if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_RECONNECTING
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_accept(Pointer handle, @Cast("unsigned short") short port, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean skip_rtp, @Cast("ZIXI_PROTOCOL") int protocol);


/**
\brief		Configure parameters for RIST main profile accept mode
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		dtls		 - connect only using DTLS
@param		cert_filename- absolute path to a certificate file, in x.509 format. Mandatory when using DTLS
@param		key_filename - absolute path to a corresponding key file, in x.509 format. Mandatory when using DTLS
@param		key_passphrase - passphrase for the key file
@param		srp_user	 - optional TLS-SRP user
@param		srp_password - optional TLS-SRP password
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_rist_main_accept(Pointer handle, @Cast("bool") boolean dtls, @Cast("const char*") BytePointer cert_filename, @Cast("const char*") BytePointer key_filename, @Cast("const char*") BytePointer key_passphrase, @Cast("const char*") BytePointer srp_user, @Cast("const char*") BytePointer srp_password);
public static native int zixi_configure_rist_main_accept(Pointer handle, @Cast("bool") boolean dtls, String cert_filename, String key_filename, String key_passphrase, String srp_user, String srp_password);

/**
\brief		disconnect from the current server
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_disconnect(Pointer handle);


/**
\brief			configure ts output stream
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		host		 - hostname or ip of the broadcaster
@param		port		 - public port of the broadcaster
<p>
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_ts_output_stream(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port);
public static native int zixi_configure_ts_output_stream(Pointer handle, String host, @Cast("unsigned short") short port);


//--------------------------------------------------------
//			Stream control functions
//--------------------------------------------------------

/**
\brief		Jump to alternative bitrate.
			<p>
			when smooth = true the transition will not be noticeable in the video, but can take a few seconds
			when smooth = false, jump immediately
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		stream_index	- hostname or ip of the broadcaster
@param		smooth			- public port of the broadcaster
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_manual_migrate(Pointer handle, int stream_index, @Cast("bool") boolean smooth);

/**
\brief		Jump to alternative bitrate in new adaptive mode, only availabel in unicast mode
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		bitrate			- a bitrate from the available list (via zixi_query_adaptive_info) or 0 to re-enable automatic mode
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_adaptive_bitrate_switch(Pointer handle, int bitrate);

/**
\brief		pause the stream (only supported in VOD)
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
*/
public static native int zixi_stream_pause(Pointer handle);

/**
\brief		resume the stream (only supported in VOD)
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
*/
public static native int zixi_stream_resume(Pointer handle);

/**
\brief		seek to a different position in the stream , 
			any value between -1 and 100 is valid , 
			passing -1 will not actually seek, but will only test for this capability
<p>
@param		handle  - a handle to zixi connection returned by zixi_init_connection_handle
@param		percent	- the location to seek to, in percent of the total length
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_stream_seek(Pointer handle, float percent);

/**
\brief		eek to a different position in the stream , 
		    any value between 0 and file size is valid	
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		bytes  - the location to seek to
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return 	ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_stream_bytes_seek(Pointer handle, long bytes);

/**
\brief		Read ready frames from zixi and fill the given buffer as much as possible
<p>
Warnings:	Next zixi_read functions will continue to read from the point in stream where 
			previous call stopped, but calls to zixi_peek_frame and zixi_get_frame 
			will not take that offset into account. 
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		buff			- preallocated buffer to hold the returning data
@param		size			- size of the preallocated buffer
@param		written_size	- the amount of bytes written to buffer
@param		eof				- flag that indicates last buffer for VOD stream. 
							  calls to 'zixi_read' past the end of file will contain 0 bytes of data with the flag set
@param		discontinuity	- flag that indicates discontinuities whithin the current frame or between the last frame to the current(output)  
@param		full_frames		  when set, frames with discontinuity will be dropped
@param		bitrate			  current bitrate, in adaptive bitrate group
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_read(Pointer handle, @Cast("char*") BytePointer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntPointer written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, IntPointer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") ByteBuffer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntBuffer written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, IntBuffer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") byte[] buff, @Cast("unsigned int") int size, @Cast("unsigned int*") int[] written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, int[] bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") BytePointer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntPointer written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, IntPointer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") ByteBuffer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntBuffer written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, IntBuffer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") byte[] buff, @Cast("unsigned int") int size, @Cast("unsigned int*") int[] written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, int[] bitrate);

//--------------------------------------------------------
//			Stream status/statistics functions
//--------------------------------------------------------

/**
\brief		Returns the current stream info if available.
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		info   - pointer to a ZIXI_STREAM_INFO struct that will receive the current stream info	
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
@return	    ZIXI_ERROR_NOT_READY
*/
public static native int zixi_query_stream_info(Pointer handle, ZIXI_STREAM_INFO info);

/**
\brief		Returns the list of availabe bitrates and current active bitrate if the stream is adaptive, will fail for single bitrate streams
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		bitrates - pointer to a preallocated vector of at least ZIXI_MAX_ADAPTIVE_STREAMS values
@param		size - pointer to an integer that will receive the number of actuall available bitrates
@param		current - pointer to an integer that will receive the current active stream
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
@return	    ZIXI_ERROR_NOT_READY
*/
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") IntPointer bitrates, @Cast("unsigned int*") IntPointer size, @Cast("unsigned int*") IntPointer current);
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") IntBuffer bitrates, @Cast("unsigned int*") IntBuffer size, @Cast("unsigned int*") IntBuffer current);
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") int[] bitrates, @Cast("unsigned int*") int[] size, @Cast("unsigned int*") int[] current);


/**
\brief		check the current network condition
<p>
Warnings:   this information updates once every 3 seconds, there is no use in calling this function more than once in 3 seconds.
<p>
@param		handle	- a handle to zixi connection returned by zixi_init_connection_handle
@param		latency	- an integer that will receive the current network latency value, in milliseconds.
@param		rtt		- an integer that will receive the current round trip time value, in milliseconds.
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return 	ZIXI_ERROR_OK
*/
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") IntPointer latency, @Cast("unsigned int*") IntPointer rtt);
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") IntBuffer latency, @Cast("unsigned int*") IntBuffer rtt);
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") int[] latency, @Cast("unsigned int*") int[] rtt);

/**
\brief		check the status of the cache file/in memory buffer
<p>
Warnings:   You can start reading data at any stage. The fullness will never reach 100%, do not wait for that to happen.
<p>
@param		handle		- a handle to zixi connection returned by zixi_init_connection_handle
@param		in_use		- will be set to true if currently connected in progressive-download mode
@param		fullness	- percentage of cache currently used.
@param		duration	- the duration of the video currently cached in the buffer in milliseconds
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, FloatPointer fullness, @Cast("unsigned int*") IntPointer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, FloatBuffer fullness, @Cast("unsigned int*") IntBuffer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, float[] fullness, @Cast("unsigned int*") int[] duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, FloatPointer fullness, @Cast("unsigned int*") IntPointer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, FloatBuffer fullness, @Cast("unsigned int*") IntBuffer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, float[] fullness, @Cast("unsigned int*") int[] duration);

/**
\brief		query error correction statistics from the client library, this information is updated once every 3 seconds.
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		con_stats  - ZIXI_CONNECTION_STATS structure for connection statistics
@param		net_stats  - ZIXI_NETWORK_STATS structure that will receive network statistics
@param		error_correction_stats  - ZIXI_ERROR_CORRECTION_STATS structure that will receive error correction statistics
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return	    ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_INVALID_PARAMETER
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_query_statistics(Pointer handle, ZIXI_CONNECTION_STATS con_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);


/**
\brief		query failover group components statistics
<p>
@param		group_handle - a handle to zixi failover group handle
@param		stats - preallocated array of ZIXI_FAILOVER_COMPONENT_STATS that will be filled by the function.
@param		count - amount of ZIXI_FAILOVER_COMPONENT_STATS structures in buffer. Should match the number of components in group
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return	    ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_query_group_statistics( Pointer group_handle, ZIXI_FAILOVER_COMPONENT_STATS stats, int count );

//--------------------------------------------------------
//			Support functions
//--------------------------------------------------------

/**
\brief		get the last error after receiving a disconnected event
<p>
Warnings: this function must not be called from the ZIXI_STATUS_FUNC callback
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return  	ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_NETWORK_ERRORS
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_CERTIFICATE
*/
public static native int zixi_get_last_error(Pointer handle);

/**
\brief		returns the libzixiClient library version
<p>
@param      major	- major version number (will remain 0 until the first release version)
@param		minor	- minor version number (incremented each time we update our internal protocol)
@param		build	- build number  
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return  	ZIXI_ERROR_OK
*/
public static native int zixi_client_version(IntPointer major, IntPointer minor, IntPointer minor_minor, IntPointer build);
public static native int zixi_client_version(IntBuffer major, IntBuffer minor, IntBuffer minor_minor, IntBuffer build);
public static native int zixi_client_version(int[] major, int[] minor, int[] minor_minor, int[] build);

/**
\brief		returns a descriptor for signaling, and the internal thread id
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		fd[out]			- pointer to a returned descriptor, fd is signalled when there is data to read
@param		thread_id[out]	- pointer to returned thread id
@param		socket[out]		- pointer to a returned socket handle, the internal native socket used in the communication
<p>
@return		ZIXI_ERROR_OK on success
*/
public static native int zixi_get_descriptors(Pointer handle, IntPointer fd, IntPointer thread_id, IntPointer socket);
public static native int zixi_get_descriptors(Pointer handle, IntBuffer fd, IntBuffer thread_id, IntBuffer socket);
public static native int zixi_get_descriptors(Pointer handle, int[] fd, int[] thread_id, int[] socket);

public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") PointerPointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr BytePointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr ByteBuffer buff, @Cast("unsigned int*") IntBuffer buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, IntBuffer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr byte[] buff, @Cast("unsigned int*") int[] buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, int[] queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr BytePointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr ByteBuffer buff, @Cast("unsigned int*") IntBuffer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntBuffer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr byte[] buff, @Cast("unsigned int*") int[] buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, int[] queue_size);

// #ifdef __cplusplus	// extern "C"
// #endif


}
