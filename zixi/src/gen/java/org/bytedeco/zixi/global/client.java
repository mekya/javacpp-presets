// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.zixi.global;

import org.bytedeco.zixi.client.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class client extends org.bytedeco.zixi.presets.zixiClient {
    static { Loader.load(); }

// Parsed from linux/uio.h

/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
 *	Berkeley style UIO structures	-	Alan Cox 1994.
 *
 *		This program is free software; you can redistribute it and/or
 *		modify it under the terms of the GNU General Public License
 *		as published by the Free Software Foundation; either version
 *		2 of the License, or (at your option) any later version.
 */
// #ifndef __LINUX_UIO_H
// #define __LINUX_UIO_H


// #include <linux/types.h>
// Targeting ../client/iovec.java



/*
 *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
 */
 
public static final int UIO_FASTIOV =	8;
public static final int UIO_MAXIOV =	1024;


// #endif /* __LINUX_UIO_H */


// Parsed from sys/uio.h

/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef _SYS_UIO_H
public static final int _SYS_UIO_H =	1;

// #include <features.h>
// #include <sys/types.h>
// #include <bits/types/struct_iovec.h>
// #include <bits/uio_lim.h>
// #ifdef __IOV_MAX
// #else
// # undef UIO_MAXIOV
// #endif

/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long readv(int __fd, @Const iovec __iovec, int __count);

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long writev(int __fd, @Const iovec __iovec, int __count);


// #ifdef __USE_MISC
// #endif	/* Use misc.  */


// #ifdef __USE_GNU
// # ifndef __USE_FILE_OFFSET64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv2(int __fp, @Const iovec __iovec, int __count,
			@Cast("__off_t") long __offset, int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev2(int __fd, @Const iovec __iodev, int __count,
			 @Cast("__off_t") long __offset, int __flags);

// # else
// # endif

// # ifdef __USE_LARGEFILE64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv64v2(int __fp, @Const iovec __iovec,
			   int __count, @Cast("__off64_t") long __offset,
			   int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev64v2(int __fd, @Const iovec __iodev,
			    int __count, @Cast("__off64_t") long __offset,
			    int __flags);
// # endif
// #endif /* Use GNU.  */

/* Some operating systems provide system-specific extensions to this
   header.  */
// #ifdef __USE_GNU
// # include <bits/uio-ext.h>
// #endif

// #endif /* sys/uio.h */


// Parsed from bits/sockaddr.h

/* Definition of struct sockaddr_* common members and sizes, generic version.
   Copyright (C) 1995-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */

// #ifndef _BITS_SOCKADDR_H
public static final int _BITS_SOCKADDR_H =	1;


/* POSIX.1g specifies this type name for the `sa_family' member.  */

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

// #define	__SOCKADDR_COMMON(sa_prefix)
//   sa_family_t sa_prefix##family

public static native @MemberGetter int __SOCKADDR_COMMON_SIZE();
public static final int __SOCKADDR_COMMON_SIZE = __SOCKADDR_COMMON_SIZE();

/* Size of struct sockaddr_storage.  */
public static final int _SS_SIZE = 128;

// #endif	/* bits/sockaddr.h */


// Parsed from bits/socket.h

/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef __BITS_SOCKET_H
// #define __BITS_SOCKET_H

// #ifndef _SYS_SOCKET_H
// # error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
// #endif

// #define __need_size_t
// #include <stddef.h>

// #include <sys/types.h>

/* Type for length arguments in socket calls.  */
// #ifndef __socklen_t_defined
// # define __socklen_t_defined
// #endif

/* Get the architecture-dependent definition of enum __socket_type.  */
// #include <bits/socket_type.h>

/* Protocol families.  */
public static final int PF_UNSPEC =	0;	/* Unspecified.  */
public static final int PF_LOCAL =	1;	/* Local to host (pipes and file-domain).  */
public static final int PF_UNIX =		PF_LOCAL; /* POSIX name for PF_LOCAL.  */
public static final int PF_FILE =		PF_LOCAL; /* Another non-standard name for PF_LOCAL.  */
public static final int PF_INET =		2;	/* IP protocol family.  */
public static final int PF_AX25 =		3;	/* Amateur Radio AX.25.  */
public static final int PF_IPX =		4;	/* Novell Internet Protocol.  */
public static final int PF_APPLETALK =	5;	/* Appletalk DDP.  */
public static final int PF_NETROM =	6;	/* Amateur radio NetROM.  */
public static final int PF_BRIDGE =	7;	/* Multiprotocol bridge.  */
public static final int PF_ATMPVC =	8;	/* ATM PVCs.  */
public static final int PF_X25 =		9;	/* Reserved for X.25 project.  */
public static final int PF_INET6 =	10;	/* IP version 6.  */
public static final int PF_ROSE =		11;	/* Amateur Radio X.25 PLP.  */
public static final int PF_DECnet =	12;	/* Reserved for DECnet project.  */
public static final int PF_NETBEUI =	13;	/* Reserved for 802.2LLC project.  */
public static final int PF_SECURITY =	14;	/* Security callback pseudo AF.  */
public static final int PF_KEY =		15;	/* PF_KEY key management API.  */
public static final int PF_NETLINK =	16;
public static final int PF_ROUTE =	PF_NETLINK; /* Alias to emulate 4.4BSD.  */
public static final int PF_PACKET =	17;	/* Packet family.  */
public static final int PF_ASH =		18;	/* Ash.  */
public static final int PF_ECONET =	19;	/* Acorn Econet.  */
public static final int PF_ATMSVC =	20;	/* ATM SVCs.  */
public static final int PF_RDS =		21;	/* RDS sockets.  */
public static final int PF_SNA =		22;	/* Linux SNA Project */
public static final int PF_IRDA =		23;	/* IRDA sockets.  */
public static final int PF_PPPOX =	24;	/* PPPoX sockets.  */
public static final int PF_WANPIPE =	25;	/* Wanpipe API sockets.  */
public static final int PF_LLC =		26;	/* Linux LLC.  */
public static final int PF_IB =		27;	/* Native InfiniBand address.  */
public static final int PF_MPLS =		28;	/* MPLS.  */
public static final int PF_CAN =		29;	/* Controller Area Network.  */
public static final int PF_TIPC =		30;	/* TIPC sockets.  */
public static final int PF_BLUETOOTH =	31;	/* Bluetooth sockets.  */
public static final int PF_IUCV =		32;	/* IUCV sockets.  */
public static final int PF_RXRPC =	33;	/* RxRPC sockets.  */
public static final int PF_ISDN =		34;	/* mISDN sockets.  */
public static final int PF_PHONET =	35;	/* Phonet sockets.  */
public static final int PF_IEEE802154 =	36;	/* IEEE 802.15.4 sockets.  */
public static final int PF_CAIF =		37;	/* CAIF sockets.  */
public static final int PF_ALG =		38;	/* Algorithm sockets.  */
public static final int PF_NFC =		39;	/* NFC sockets.  */
public static final int PF_VSOCK =	40;	/* vSockets.  */
public static final int PF_KCM =		41;	/* Kernel Connection Multiplexor.  */
public static final int PF_QIPCRTR =	42;	/* Qualcomm IPC Router.  */
public static final int PF_SMC =		43;	/* SMC sockets.  */
public static final int PF_XDP =		44;	/* XDP sockets.  */
public static final int PF_MAX =		45;	/* For now..  */

/* Address families.  */
public static final int AF_UNSPEC =	PF_UNSPEC;
public static final int AF_LOCAL =	PF_LOCAL;
public static final int AF_UNIX =		PF_UNIX;
public static final int AF_FILE =		PF_FILE;
public static final int AF_INET =		PF_INET;
public static final int AF_AX25 =		PF_AX25;
public static final int AF_IPX =		PF_IPX;
public static final int AF_APPLETALK =	PF_APPLETALK;
public static final int AF_NETROM =	PF_NETROM;
public static final int AF_BRIDGE =	PF_BRIDGE;
public static final int AF_ATMPVC =	PF_ATMPVC;
public static final int AF_X25 =		PF_X25;
public static final int AF_INET6 =	PF_INET6;
public static final int AF_ROSE =		PF_ROSE;
public static final int AF_DECnet =	PF_DECnet;
public static final int AF_NETBEUI =	PF_NETBEUI;
public static final int AF_SECURITY =	PF_SECURITY;
public static final int AF_KEY =		PF_KEY;
public static final int AF_NETLINK =	PF_NETLINK;
public static final int AF_ROUTE =	PF_ROUTE;
public static final int AF_PACKET =	PF_PACKET;
public static final int AF_ASH =		PF_ASH;
public static final int AF_ECONET =	PF_ECONET;
public static final int AF_ATMSVC =	PF_ATMSVC;
public static final int AF_RDS =		PF_RDS;
public static final int AF_SNA =		PF_SNA;
public static final int AF_IRDA =		PF_IRDA;
public static final int AF_PPPOX =	PF_PPPOX;
public static final int AF_WANPIPE =	PF_WANPIPE;
public static final int AF_LLC =		PF_LLC;
public static final int AF_IB =		PF_IB;
public static final int AF_MPLS =		PF_MPLS;
public static final int AF_CAN =		PF_CAN;
public static final int AF_TIPC =		PF_TIPC;
public static final int AF_BLUETOOTH =	PF_BLUETOOTH;
public static final int AF_IUCV =		PF_IUCV;
public static final int AF_RXRPC =	PF_RXRPC;
public static final int AF_ISDN =		PF_ISDN;
public static final int AF_PHONET =	PF_PHONET;
public static final int AF_IEEE802154 =	PF_IEEE802154;
public static final int AF_CAIF =		PF_CAIF;
public static final int AF_ALG =		PF_ALG;
public static final int AF_NFC =		PF_NFC;
public static final int AF_VSOCK =	PF_VSOCK;
public static final int AF_KCM =		PF_KCM;
public static final int AF_QIPCRTR =	PF_QIPCRTR;
public static final int AF_SMC =		PF_SMC;
public static final int AF_XDP =		PF_XDP;
public static final int AF_MAX =		PF_MAX;

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
public static final int SOL_RAW =		255;
public static final int SOL_DECNET =      261;
public static final int SOL_X25 =         262;
public static final int SOL_PACKET =	263;
public static final int SOL_ATM =		264;	/* ATM layer (cell level).  */
public static final int SOL_AAL =		265;	/* ATM Adaption Layer (packet level).  */
public static final int SOL_IRDA =	266;
public static final int SOL_NETBEUI =	267;
public static final int SOL_LLC =		268;
public static final int SOL_DCCP =	269;
public static final int SOL_NETLINK =	270;
public static final int SOL_TIPC =	271;
public static final int SOL_RXRPC =	272;
public static final int SOL_PPPOL2TP =	273;
public static final int SOL_BLUETOOTH =	274;
public static final int SOL_PNPIPE =	275;
public static final int SOL_RDS =		276;
public static final int SOL_IUCV =	277;
public static final int SOL_CAIF =	278;
public static final int SOL_ALG =		279;
public static final int SOL_NFC =		280;
public static final int SOL_KCM =		281;
public static final int SOL_TLS =		282;
public static final int SOL_XDP =		283;

/* Maximum queue length specifiable by listen.  */
public static final int SOMAXCONN =	4096;

/* Get the definition of the macro to define the common sockaddr members.  */
// #include <bits/sockaddr.h>
// Targeting ../client/sockaddr.java




/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
// #define __ss_aligntype	unsigned long int
public static native @MemberGetter int _SS_PADSIZE();
public static final int _SS_PADSIZE = _SS_PADSIZE();
// Targeting ../client/sockaddr_storage.java




/* Bits in the FLAGS argument to `send', `recv', et al.  */
/** enum  */
public static final int
    MSG_OOB		 = 0x01,	/* Process out-of-band data.  */
// #define MSG_OOB		MSG_OOB
    MSG_PEEK		 = 0x02,	/* Peek at incoming messages.  */
// #define MSG_PEEK	MSG_PEEK
    MSG_DONTROUTE	 = 0x04,	/* Don't use local routing.  */
// #define MSG_DONTROUTE	MSG_DONTROUTE
// #ifdef __USE_GNU
    /* DECnet uses a different name.  */
    MSG_TRYHARD		 = MSG_DONTROUTE,
// # define MSG_TRYHARD	MSG_DONTROUTE
// #endif
    MSG_CTRUNC		 = 0x08,	/* Control data lost before delivery.  */
// #define MSG_CTRUNC	MSG_CTRUNC
    MSG_PROXY		 = 0x10,	/* Supply or ask second address.  */
// #define MSG_PROXY	MSG_PROXY
    MSG_TRUNC		 = 0x20,
// #define MSG_TRUNC	MSG_TRUNC
    MSG_DONTWAIT	 = 0x40, /* Nonblocking IO.  */
// #define MSG_DONTWAIT	MSG_DONTWAIT
    MSG_EOR		 = 0x80, /* End of record.  */
// #define MSG_EOR		MSG_EOR
    MSG_WAITALL		 = 0x100, /* Wait for a full request.  */
// #define MSG_WAITALL	MSG_WAITALL
    MSG_FIN		 = 0x200,
// #define MSG_FIN		MSG_FIN
    MSG_SYN		 = 0x400,
// #define MSG_SYN		MSG_SYN
    MSG_CONFIRM		 = 0x800, /* Confirm path validity.  */
// #define MSG_CONFIRM	MSG_CONFIRM
    MSG_RST		 = 0x1000,
// #define MSG_RST		MSG_RST
    MSG_ERRQUEUE	 = 0x2000, /* Fetch message from error queue.  */
// #define MSG_ERRQUEUE	MSG_ERRQUEUE
    MSG_NOSIGNAL	 = 0x4000, /* Do not generate SIGPIPE.  */
// #define MSG_NOSIGNAL	MSG_NOSIGNAL
    MSG_MORE		 = 0x8000,  /* Sender will send more.  */
// #define MSG_MORE	MSG_MORE
    MSG_WAITFORONE	 = 0x10000, /* Wait for at least one packet to return.*/
// #define MSG_WAITFORONE	MSG_WAITFORONE
    MSG_BATCH		 = 0x40000, /* sendmmsg: more messages coming.  */
// #define MSG_BATCH	MSG_BATCH
    MSG_ZEROCOPY	 = 0x4000000, /* Use user data in kernel path.  */
// #define MSG_ZEROCOPY	MSG_ZEROCOPY
    MSG_FASTOPEN	 = 0x20000000, /* Send data in TCP SYN.  */
// #define MSG_FASTOPEN	MSG_FASTOPEN

    MSG_CMSG_CLOEXEC	 = 0x40000000;	/* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */
// #define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
// Targeting ../client/msghdr.java


// Targeting ../client/cmsghdr.java



/* Ancillary data object manipulation macros.  */
// #if __glibc_c99_flexarr_available
// # define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
// #else
// # define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
// #endif
// #define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
// #define CMSG_FIRSTHDR(mhdr)
//   ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)
//    ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
// #define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1)
// 			 & (size_t) ~(sizeof (size_t) - 1))
// #define CMSG_SPACE(len) (CMSG_ALIGN (len)
// 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
// #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))

public static native cmsghdr __cmsg_nxthdr(msghdr __mhdr,
				      cmsghdr __cmsg);
// #ifdef __USE_EXTERN_INLINES
// #endif	/* Use `extern inline'.  */

/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
/** enum  */
public static final int
    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
// #define SCM_RIGHTS SCM_RIGHTS
    SCM_CREDENTIALS = 0x02;	/* Credentials passing.  */
// # define SCM_CREDENTIALS SCM_CREDENTIALS
// #endif
// Targeting ../client/ucred.java


// #endif

// #ifdef __USE_MISC
// #else
public static final int SO_DEBUG = 1;
// # include <bits/socket-constants.h>
// Targeting ../client/linger.java



// #endif	/* bits/socket.h */


// Parsed from sys/socket.h

/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef	_SYS_SOCKET_H
public static final int _SYS_SOCKET_H =	1;

// #include <features.h>


// #endif /* sys/socket.h */


// Parsed from netinet/in.h

/* Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

// #ifndef	_NETINET_IN_H
public static final int _NETINET_IN_H =	1;

// #include <features.h>
// #include <bits/stdint-iLntn.h>
// #include <sys/socket.h>
// #include <bits/types.h>


/* Internet address.  */
// Targeting ../client/in_addr.java



/* Get system-specific definitions.  */
// #include <bits/in.h>

/* Standard well-defined IP protocols.  */
/** enum  */
public static final int
    IPPROTO_IP = 0,	   /* Dummy protocol for TCP.  */
// #define IPPROTO_IP		IPPROTO_IP
    IPPROTO_ICMP = 1,	   /* Internet Control Message Protocol.  */
// #define IPPROTO_ICMP		IPPROTO_ICMP
    IPPROTO_IGMP = 2,	   /* Internet Group Management Protocol. */
// #define IPPROTO_IGMP		IPPROTO_IGMP
    IPPROTO_IPIP = 4,	   /* IPIP tunnels (older KA9Q tunnels use 94).  */
// #define IPPROTO_IPIP		IPPROTO_IPIP
    IPPROTO_TCP = 6,	   /* Transmission Control Protocol.  */
// #define IPPROTO_TCP		IPPROTO_TCP
    IPPROTO_EGP = 8,	   /* Exterior Gateway Protocol.  */
// #define IPPROTO_EGP		IPPROTO_EGP
    IPPROTO_PUP = 12,	   /* PUP protocol.  */
// #define IPPROTO_PUP		IPPROTO_PUP
    IPPROTO_UDP = 17,	   /* User Datagram Protocol.  */
// #define IPPROTO_UDP		IPPROTO_UDP
    IPPROTO_IDP = 22,	   /* XNS IDP protocol.  */
// #define IPPROTO_IDP		IPPROTO_IDP
    IPPROTO_TP = 29,	   /* SO Transport Protocol Class 4.  */
// #define IPPROTO_TP		IPPROTO_TP
    IPPROTO_DCCP = 33,	   /* Datagram Congestion Control Protocol.  */
// #define IPPROTO_DCCP		IPPROTO_DCCP
    IPPROTO_IPV6 = 41,     /* IPv6 header.  */
// #define IPPROTO_IPV6		IPPROTO_IPV6
    IPPROTO_RSVP = 46,	   /* Reservation Protocol.  */
// #define IPPROTO_RSVP		IPPROTO_RSVP
    IPPROTO_GRE = 47,	   /* General Routing Encapsulation.  */
// #define IPPROTO_GRE		IPPROTO_GRE
    IPPROTO_ESP = 50,      /* encapsulating security payload.  */
// #define IPPROTO_ESP		IPPROTO_ESP
    IPPROTO_AH = 51,       /* authentication header.  */
// #define IPPROTO_AH		IPPROTO_AH
    IPPROTO_MTP = 92,	   /* Multicast Transport Protocol.  */
// #define IPPROTO_MTP		IPPROTO_MTP
    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */
// #define IPPROTO_BEETPH		IPPROTO_BEETPH
    IPPROTO_ENCAP = 98,	   /* Encapsulation Header.  */
// #define IPPROTO_ENCAP		IPPROTO_ENCAP
    IPPROTO_PIM = 103,	   /* Protocol Independent Multicast.  */
// #define IPPROTO_PIM		IPPROTO_PIM
    IPPROTO_COMP = 108,	   /* Compression Header Protocol.  */
// #define IPPROTO_COMP		IPPROTO_COMP
    IPPROTO_SCTP = 132,	   /* Stream Control Transmission Protocol.  */
// #define IPPROTO_SCTP		IPPROTO_SCTP
    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
// #define IPPROTO_UDPLITE		IPPROTO_UDPLITE
    IPPROTO_MPLS = 137,    /* MPLS in IP.  */
// #define IPPROTO_MPLS		IPPROTO_MPLS
    IPPROTO_RAW = 255,	   /* Raw IP packets.  */
// #define IPPROTO_RAW		IPPROTO_RAW
    IPPROTO_MAX = 256;

/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
   network headers first and we should use those ABI-identical definitions
   instead of our own, otherwise 0.  */
// #if !__USE_KERNEL_IPV6_DEFS
/** enum  */
public static final int
    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */
// #define IPPROTO_HOPOPTS		IPPROTO_HOPOPTS
    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */
// #define IPPROTO_ROUTING		IPPROTO_ROUTING
    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
// #define IPPROTO_FRAGMENT	IPPROTO_FRAGMENT
    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */
// #define IPPROTO_ICMPV6		IPPROTO_ICMPV6
    IPPROTO_NONE = 59,     /* IPv6 no next header.  */
// #define IPPROTO_NONE		IPPROTO_NONE
    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */
// #define IPPROTO_DSTOPTS		IPPROTO_DSTOPTS
    IPPROTO_MH = 135;       /* IPv6 mobility header.  */
// #define IPPROTO_MH		IPPROTO_MH
// #endif /* !__USE_KERNEL_IPV6_DEFS */

/* Type to represent a port.  */

/* Standard well-known ports.  */
/** enum  */
public static final int
    IPPORT_ECHO = 7,		/* Echo service.  */
    IPPORT_DISCARD = 9,		/* Discard transmissions service.  */
    IPPORT_SYSTAT = 11,		/* System status service.  */
    IPPORT_DAYTIME = 13,	/* Time of day service.  */
    IPPORT_NETSTAT = 15,	/* Network status service.  */
    IPPORT_FTP = 21,		/* File Transfer Protocol.  */
    IPPORT_TELNET = 23,		/* Telnet protocol.  */
    IPPORT_SMTP = 25,		/* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37,	/* Timeserver service.  */
    IPPORT_NAMESERVER = 42,	/* Domain Name Service.  */
    IPPORT_WHOIS = 43,		/* Internet Whois service.  */
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,		/* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,		/* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,		/* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512,	/* execd service.  */
    IPPORT_LOGINSERVER = 513,	/* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,

    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000;

/* Definitions of the bits in an Internet address integer.

   On subnets, host and network parts are found according to
   the subnet mask, not these masks.  */

// #define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
public static final int IN_CLASSA_NET =		0xff000000;
public static final int IN_CLASSA_NSHIFT =	24;
public static final int IN_CLASSA_HOST =		(0xffffffff & ~IN_CLASSA_NET);
public static final int IN_CLASSA_MAX =		128;

// #define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
public static final int IN_CLASSB_NET =		0xffff0000;
public static final int IN_CLASSB_NSHIFT =	16;
public static final int IN_CLASSB_HOST =		(0xffffffff & ~IN_CLASSB_NET);
public static final int IN_CLASSB_MAX =		65536;

// #define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
public static final int IN_CLASSC_NET =		0xffffff00;
public static final int IN_CLASSC_NSHIFT =	8;
public static final int IN_CLASSC_HOST =		(0xffffffff & ~IN_CLASSC_NET);

// #define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
// #define	IN_MULTICAST(a)		IN_CLASSD(a)

// #define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
// #define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)

/* Address to accept any incoming messages.  */
public static final int INADDR_ANY =		((int) 0x00000000);
/* Address to send to all hosts.  */
public static final int INADDR_BROADCAST =	((int) 0xffffffff);
/* Address indicating an error return.  */
public static final int INADDR_NONE =		((int) 0xffffffff);

/* Network number for local host loopback.  */
public static final int IN_LOOPBACKNET =		127;
/* Address to loopback in software to local host.  */
// #ifndef INADDR_LOOPBACK
public static final int INADDR_LOOPBACK =	((int) 0x7f000001); /* Inet 127.0.0.1.  */
// #endif

/* Defines for Multicast INADDR.  */
public static final int INADDR_UNSPEC_GROUP =	((int) 0xe0000000); /* 224.0.0.0 */
public static final int INADDR_ALLHOSTS_GROUP =	((int) 0xe0000001); /* 224.0.0.1 */
public static final int INADDR_ALLRTRS_GROUP =    ((int) 0xe0000002); /* 224.0.0.2 */
public static final int INADDR_ALLSNOOPERS_GROUP = ((int) 0xe000006a); /* 224.0.0.106 */
public static final int INADDR_MAX_LOCAL_GROUP =  ((int) 0xe00000ff);
// Targeting ../client/in6_addr.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

@MemberGetter public static native @Const @ByRef in6_addr in6addr_any();        /* :: */
@MemberGetter public static native @Const @ByRef in6_addr in6addr_loopback();   /* ::1 */
// #define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
// #define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

public static final int INET_ADDRSTRLEN = 16;
public static final int INET6_ADDRSTRLEN = 46;
// Targeting ../client/sockaddr_in.java


// Targeting ../client/sockaddr_in6.java


// Targeting ../client/ipv6_mreq.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

// #ifdef __USE_MISC
// #endif

/* Functions to convert between host and network byte order.

   Please note that these functions normally take `unsigned long int' or
   `unsigned short int' values as arguments and also return them.  But
   this was a short-sighted decision since on different systems the types
   may have different representations but the values are always the same.  */

public static native @Cast("uint32_t") int ntohl(@Cast("uint32_t") int __netlong);
public static native @Cast("uint16_t") short ntohs(@Cast("uint16_t") short __netshort);
public static native @Cast("uint32_t") int htonl(@Cast("uint32_t") int __hostlong);
public static native @Cast("uint16_t") short htons(@Cast("uint16_t") short __hostshort);

// #include <endian.h>

/* Get machine dependent optimized versions of byte swapping functions.  */
// #include <bits/byteswap.h>
// #include <bits/uintn-identity.h>

// #ifdef __OPTIMIZE__
/* We can optimize calls to the conversion functions.  Either nothing has
   to be done or we are using directly the byte-swapping functions which
   often can be inlined.  */
// # if __BYTE_ORDER == __BIG_ENDIAN
/* The host byte order is the same as network byte order,
   so these functions are all just identity.  */
// # define ntohl(x)	__uint32_identity (x)
// # define ntohs(x)	__uint16_identity (x)
// # define htonl(x)	__uint32_identity (x)
// # define htons(x)	__uint16_identity (x)
// # else
// #  if __BYTE_ORDER == __LITTLE_ENDIAN
// #   define ntohl(x)	__bswap_32 (x)
// #   define ntohs(x)	__bswap_16 (x)
// #   define htonl(x)	__bswap_32 (x)
// #   define htons(x)	__bswap_16 (x)
// #  endif
// # endif
// #endif

// #ifdef __GNUC__
// # define IN6_IS_ADDR_UNSPECIFIED(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && __a->__in6_u.__u6_addr32[3] == 0; }))

// # define IN6_IS_ADDR_LOOPBACK(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && __a->__in6_u.__u6_addr32[3] == htonl (1); }))

// # define IN6_IS_ADDR_LINKLOCAL(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfe800000); }))

// # define IN6_IS_ADDR_SITELOCAL(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       (__a->__in6_u.__u6_addr32[0] & htonl (0xffc00000)) == htonl (0xfec00000); }))

// # define IN6_IS_ADDR_V4MAPPED(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == htonl (0xffff); }))

// # define IN6_IS_ADDR_V4COMPAT(a)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       __a->__in6_u.__u6_addr32[0] == 0
//       && __a->__in6_u.__u6_addr32[1] == 0
//       && __a->__in6_u.__u6_addr32[2] == 0
//       && ntohl (__a->__in6_u.__u6_addr32[3]) > 1; }))

// # define IN6_ARE_ADDR_EQUAL(a,b)
//   (__extension__
//    ({ const struct in6_addr *__a = (const struct in6_addr *) (a);
//       const struct in6_addr *__b = (const struct in6_addr *) (b);
//       __a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]
//       && __a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]
//       && __a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]
//       && __a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]; }))
// #else
// # define IN6_IS_ADDR_UNSPECIFIED(a)
// 	(((const uint32_t *) (a))[0] == 0
// 	 && ((const uint32_t *) (a))[1] == 0
// 	 && ((const uint32_t *) (a))[2] == 0
// 	 && ((const uint32_t *) (a))[3] == 0)

// # define IN6_IS_ADDR_LOOPBACK(a)
// 	(((const uint32_t *) (a))[0] == 0
// 	 && ((const uint32_t *) (a))[1] == 0
// 	 && ((const uint32_t *) (a))[2] == 0
// 	 && ((const uint32_t *) (a))[3] == htonl (1))

// # define IN6_IS_ADDR_LINKLOCAL(a)
// 	((((const uint32_t *) (a))[0] & htonl (0xffc00000))
// 	 == htonl (0xfe800000))

// # define IN6_IS_ADDR_SITELOCAL(a)
// 	((((const uint32_t *) (a))[0] & htonl (0xffc00000))
// 	 == htonl (0xfec00000))

// # define IN6_IS_ADDR_V4MAPPED(a)
// 	((((const uint32_t *) (a))[0] == 0)
// 	 && (((const uint32_t *) (a))[1] == 0)
// 	 && (((const uint32_t *) (a))[2] == htonl (0xffff)))

// # define IN6_IS_ADDR_V4COMPAT(a)
// 	((((const uint32_t *) (a))[0] == 0)
// 	 && (((const uint32_t *) (a))[1] == 0)
// 	 && (((const uint32_t *) (a))[2] == 0)
// 	 && (ntohl (((const uint32_t *) (a))[3]) > 1))

// # define IN6_ARE_ADDR_EQUAL(a,b)
// 	((((const uint32_t *) (a))[0] == ((const uint32_t *) (b))[0])
// 	 && (((const uint32_t *) (a))[1] == ((const uint32_t *) (b))[1])
// 	 && (((const uint32_t *) (a))[2] == ((const uint32_t *) (b))[2])
// 	 && (((const uint32_t *) (a))[3] == ((const uint32_t *) (b))[3]))
// #endif

// #define IN6_IS_ADDR_MULTICAST(a) (((const uint8_t *) (a))[0] == 0xff)

// #ifdef __USE_MISC
// #endif


// #define IN6_IS_ADDR_MC_NODELOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x1))

// #define IN6_IS_ADDR_MC_LINKLOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x2))

// #define IN6_IS_ADDR_MC_SITELOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x5))

// #define IN6_IS_ADDR_MC_ORGLOCAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0x8))

// #define IN6_IS_ADDR_MC_GLOBAL(a)
// 	(IN6_IS_ADDR_MULTICAST(a)
// 	 && ((((const uint8_t *) (a))[1] & 0xf) == 0xe))


// #ifdef __USE_GNU
// Targeting ../client/in6_pktinfo.java


// Targeting ../client/ip6_mtuinfo.java


// #endif /* !__USE_KERNEL_IPV6_DEFS */

/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
public static native int inet6_option_space(int __nbytes);
public static native int inet6_option_init(Pointer __bp, @Cast("cmsghdr**") PointerPointer __cmsgp,
			      int __type);
public static native int inet6_option_init(Pointer __bp, @ByPtrPtr cmsghdr __cmsgp,
			      int __type);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") BytePointer __typep, int __multx,
				int __plusy);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") ByteBuffer __typep, int __multx,
				int __plusy);
public static native int inet6_option_append(cmsghdr __cmsg,
				@Cast("const uint8_t*") byte[] __typep, int __multx,
				int __plusy);
public static native @Cast("uint8_t*") BytePointer inet6_option_alloc(cmsghdr __cmsg, int __datalen,
				    int __multx, int __plusy);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") PointerPointer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr BytePointer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr ByteBuffer __tptrp);
public static native int inet6_option_next(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr byte[] __tptrp);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") PointerPointer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr BytePointer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr ByteBuffer __tptrp, int __type);
public static native int inet6_option_find(@Const cmsghdr __cmsg,
			      @Cast("uint8_t**") @ByPtrPtr byte[] __tptrp, int __type);


/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
public static native int inet6_opt_init(Pointer __extbuf, @Cast("socklen_t") int __extlen);
public static native int inet6_opt_append(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			     @Cast("uint8_t") byte __type, @Cast("socklen_t") int __len, @Cast("uint8_t") byte __align,
			     @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_append(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			     @Cast("uint8_t") byte __type, @Cast("socklen_t") int __len, @Cast("uint8_t") byte __align,
			     @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_finish(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset);
public static native int inet6_opt_set_val(Pointer __databuf, int __offset, Pointer __val,
			      @Cast("socklen_t") int __vallen);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") BytePointer __typep, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") BytePointer __typep, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") ByteBuffer __typep, @Cast("socklen_t*") IntBuffer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_next(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t*") byte[] __typep, @Cast("socklen_t*") int[] __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") PointerPointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntPointer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") IntBuffer __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_find(Pointer __extbuf, @Cast("socklen_t") int __extlen, int __offset,
			   @Cast("uint8_t") byte __type, @Cast("socklen_t*") int[] __lenp,
			   @Cast("void**") @ByPtrPtr Pointer __databufp);
public static native int inet6_opt_get_val(Pointer __databuf, int __offset, Pointer __val,
			      @Cast("socklen_t") int __vallen);


/* Routing Header Option (RFC 3542).  */
public static native @Cast("socklen_t") int inet6_rth_space(int __type, int __segments);
public static native Pointer inet6_rth_init(Pointer __bp, @Cast("socklen_t") int __bp_len, int __type,
			     int __segments);
public static native int inet6_rth_add(Pointer __bp, @Const in6_addr __addr);
public static native int inet6_rth_reverse(@Const Pointer __in, Pointer __out);
public static native int inet6_rth_segments(@Const Pointer __bp);
public static native in6_addr inet6_rth_getaddr(@Const Pointer __bp, int __index);


/* Multicast source filter support.  */

/* Get IPv4 source filter.  */
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") IntPointer __fmode,
				@Cast("uint32_t*") IntPointer __numsrc, in_addr __slist);
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") IntBuffer __fmode,
				@Cast("uint32_t*") IntBuffer __numsrc, in_addr __slist);
public static native int getipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t*") int[] __fmode,
				@Cast("uint32_t*") int[] __numsrc, in_addr __slist);

/* Set IPv4 source filter.  */
public static native int setipv4sourcefilter(int __s, @ByVal in_addr __interface_addr,
				@ByVal in_addr __group, @Cast("uint32_t") int __fmode,
				@Cast("uint32_t") int __numsrc,
				@Const in_addr __slist);


/* Get source filter.  */
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") IntPointer __fmode,
			    @Cast("uint32_t*") IntPointer __numsrc,
			    sockaddr_storage __slist);
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") IntBuffer __fmode,
			    @Cast("uint32_t*") IntBuffer __numsrc,
			    sockaddr_storage __slist);
public static native int getsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t*") int[] __fmode,
			    @Cast("uint32_t*") int[] __numsrc,
			    sockaddr_storage __slist);

/* Set source filter.  */
public static native int setsourcefilter(int __s, @Cast("uint32_t") int __interface_addr,
			    @Const sockaddr __group,
			    @Cast("socklen_t") int __grouplen, @Cast("uint32_t") int __fmode,
			    @Cast("uint32_t") int __numsrc,
			    @Const sockaddr_storage __slist);
// #endif	/* use GNU */

// #endif	/* netinet/in.h */


// Parsed from zixi_definitions.h

// #pragma once

// #include <time.h>

// #ifndef __cplusplus
// 	#ifndef bool
// 	#endif
// #endif

// zixi warning values
public static final int ZIXI_WARNING_OVER_LIMIT =			100;

// zixi error values
// recoverable errors
public static final int ZIXI_ERROR_RECONNECTING =			7;
public static final int ZIXI_ERROR_BUFFER_TO_SMALL =		6;
public static final int ZIXI_ERROR_NOT_READY =			5;
public static final int ZIXI_ERROR_ALREADY_CONNECTED =	4;
public static final int ZIXI_ERROR_ALREADY_INITIALIZED =	3;
public static final int ZIXI_ERROR_STREAM_CHANGED =		2;
public static final int ZIXI_ERROR_INVALID_PARAMETER =	1;

// no error
public static final int ZIXI_ERROR_OK =					0;

// non-recoverable errors
public static final int ZIXI_ERROR_FAILED =				-1;
public static final int ZIXI_ERROR_TIMEOUT =				-2;
public static final int ZIXI_ERROR_NOT_INITIALIZED =		-3;
public static final int ZIXI_ERROR_NOT_CONNECTED =		-4;
public static final int ZIXI_ERROR_DLL_NOT_FOUND =		-5;
public static final int ZIXI_ERROR_FUNCTION_NOT_FOUND =	-6;
public static final int ZIXI_ERROR_AUTHORIZATION_FAILED =	-7;
public static final int ZIXI_ERROR_LICENSING_FAILED =		-8;
public static final int ZIXI_ERROR_NETWORK_ERRORS =		-9;
public static final int ZIXI_ERROR_VERSION =				-10;
public static final int ZIXI_ERROR_SERVER_FULL =			-11;
public static final int ZIXI_ERROR_EOF =					-12;
public static final int ZIXI_ERROR_NOT_SUPPORTED =		-13;
public static final int ZIXI_ERROR_TEST_FAILED =			-14;
public static final int ZIXI_ERROR_RESOLVING_FAILED =		-15;
public static final int ZIXI_ERROR_CACHE_TO_SMALL =		-16;
public static final int ZIXI_ERROR_NETWORK =				-17;
public static final int ZIXI_ERROR_NOT_FOUND =			-18;
public static final int ZIXI_ERROR_BAD_URL =				-19;
public static final int ZIXI_ERROR_FILE_LOCAL =			-20;
public static final int ZIXI_ERROR_FILE_REMOTE =			-21;		
public static final int ZIXI_WARNING_REMOTE_FILE_EXISTS = -22;		//	File cannot be uploaded without 'overwrite' permission.
public static final int ZIXI_ERROR_DECRYPTION =			-23;	
public static final int ZIXI_ERROR_CERTIFICATE =			-24;
public static final int ZIXI_ERROR_WRONG_SRP =			-25;

// zixi encryption types
/** enum ZIXI_ENCRYPTION */
public static final int
	ZIXI_AES_128 = 0,
	ZIXI_AES_192 = 1,
	ZIXI_AES_256 = 2,
	ZIXI_CHACHA20 = 3, // fast cipher for platforms without AES-NI
	ZIXI_NO_ENCRYPTION = 4;
//	ZIXI_AUTO_ENCRYPTION - deprecated - use DTLS on the server side instead

// zixi connection status
/** enum ZIXI_STATUS */
public static final int	
	ZIXI_DISCONNECTED = 0,
	ZIXI_CONNECTING = 1,
	ZIXI_CONNECTED = 2,
	ZIXI_DISCONNECTING = 3,
	ZIXI_RECONNECTING = 4;

// zixi log levels
/** enum ZIXI_LOG_LEVELS */
public static final int
	ZIXI_LOG_NONE = -1,
	ZIXI_LOG_ALL = 0,
	ZIXI_LOG_DEBUG = 1,
	ZIXI_LOG_INFO = 2,
	ZIXI_LOG_WARNINGS = 3,
	ZIXI_LOG_ERRORS = 4,
	ZIXI_LOG_FATAL = 5;

/** enum ZIXI_LATENCY_MODE */
public static final int
	ZIXI_LATENCY_STATIC = 0,
	ZIXI_LATENCY_INCREASING = 1,
	ZIXI_LATENCY_DYNAMIC = 2;

/** enum ZIXI_ADAPTIVE_MODE */
public static final int
	ZIXI_ADAPTIVE_NONE = 0,
	ZIXI_ADAPTIVE_ENCODER = 1,
	ZIXI_ADAPTIVE_FEC = 2;

/** enum ZIXI_FEC_MODE */
public static final int
	ZIXI_FEC_OFF = 0,
	ZIXI_FEC_ON = 1,
	ZIXI_FEC_ADAPTIVE = 2;

/** enum ZIXI_VIDEO_CODECS */
public static final int
	ZIXI_VIDEO_CODEC_NONE = 0,
	ZIXI_VIDEO_CODEC_H264 = 1,
	ZIXI_VIDEO_CODEC_HEVC = 2;

/** enum ZIXI_AUDIO_CODECS */
public static final int
	ZIXI_AUDIO_CODEC_NONE = 0,
	ZIXI_AUDIO_CODEC_AAC	 = 1,
	ZIXI_AUDIO_CODEC_OPUS = 2;


/** enum ZIXI_DTLS_CERTIFICATE_VERIFICATION_STATUS */
public static final int
	ZIXI_DTLS_CERT_OK					 = 0,		//	Certificate verified.
	ZIXI_DTLS_CERT_NOT_RECEIVED			 = 1,		//	Server did not send any certificate.
	ZIXI_DLTS_CERT_INVALID_CERTIFICATE	 = 2,		//	Certificate in not valid.
	ZIXI_DTLS_CERT_NOT_VERIFIED			 = 3,		//	Certificate verification failed.
	ZIXI_DTLS_CERT_SELF_SIGNED			 = 4,		//	Certificate is self signed.
	ZIXI_DTLS_CERT_EXPIRED				 = 5,		//	Certificate is expired.
	ZIXI_DTLS_CERT_NOT_YET_VALID		 = 6,		//	Certificate is not yet valid.
	ZIXI_DTLS_CERT_INVALID_CA			 = 7,		//	Certificate authority not recognized.
	ZIXI_DTLS_CERT_HOSTNAME_MISMATCH	 = 8,		//	Certificate issued to hostname different from one provided in connection parameters.
	ZIXI_DTLS_WRONG_SRP					 = 9,		//	Wrong username/password.
	ZIXI_DTLS_INVALID_SSL_CONNECTION	 = 10;		//	Invalid SSL connection.
// Targeting ../client/ZIXI_STREAM_INFO.java


// Targeting ../client/ZIXI_NETWORK_STATS.java


// Targeting ../client/ZIXI_ERROR_CORRECTION_STATS.java


// Targeting ../client/ZIXI_CONNECTION_STATS.java


// Targeting ../client/ZIXI_BITRATE_CHANGED_FUNC.java


// Targeting ../client/ZIXI_STATUS_FUNC.java


// Targeting ../client/ZIXI_NEW_STREAM_FUNC.java


// Targeting ../client/ZIXI_LOG_FUNC.java


// Targeting ../client/ZIXI_IO_FUNCTION.java


// Targeting ../client/ZIXI_RELEASE_FUNCTION.java


// Targeting ../client/ZIXI_RTMP_HANDLE_WRITE_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_WRITE_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_HANDLE_READ_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_RTMP_READ_DATA_EXTERNAL.java


// Targeting ../client/ZIXI_CALLBACKS.java



public static final int ZIXI_GUID_LENGTH =	128;
public static final int ZIXI_SESSION_LENGTH =	128;
public static final int ZIXI_CHANNEL_LENGTH =	64;

public static final int ZIXI_MAX_ADAPTIVE_STREAMS =	16;
// Targeting ../client/ZIXI_MEDIA_INFO.java


// Targeting ../client/ZIXI_FAILOVER_COMPONENT_STATS.java



/** enum ZIXI_PROTOCOL */
public static final int
	ZIXI_PROTOCOL_UDP = 0,
	ZIXI_PROTOCOL_MMT = 1,
	ZIXI_PROTOCOL_RIST_SIMPLE = 2,
	ZIXI_PROTOCOL_RIST_MAIN = 3,
	ZIXI_PROTOCOL_HTTP = 4,
	ZIXI_PROTOCOL_HTTPS = 5;


/** enum ZIXI_FAILOVER_MODE */
public static final int
	ZIXI_FAILOVER_MODE_NONE = 0,	//	streams are assumed to be different, no merging will be attemted.
	ZIXI_FAILOVER_MODE_RTP = 1,			//	merge by RTP headers. SMPTE 2022-7
	ZIXI_FAILOVER_MODE_CONTENT = 2;		//	merge by RTP headers if available or by TS content.


// Parsed from zixi_client_interface.h

// #pragma once

// #include "zixi_definitions.h"
// #ifdef WIN32
// #else
//   #if __GNUC__ >= 4
//     #define DLL_EXPORT __attribute__ ((visibility ("default")))
//   #else
//     #define DLL_EXPORT
//   #endif
// #endif


// #ifdef __cplusplus
// #endif

/**
\mainpage  ZIXI Client Interface
\section	API for using ZIXI client interface.
*/



//--------------------------------------------------------
//			Initialization functions					
//--------------------------------------------------------

/**
\brief      initializes zixi environment.
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_ALREADY_INITIALIZED
@return		ZIXI_ERROR_DLL_NOT_FOUND
*/
public static native int zixi_init();

/**
\brief		cleans up zixi environment.
<p>
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
*/
public static native int zixi_destroy();

/**
\brief		initialize a handle for zixi connection.
<p>
@param		handle[out] - returned handle upon success, destroy with zixi_delete_connection_handle function.
<p>
@return      ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
<p>
*/
public static native int zixi_init_connection_handle(@Cast("void**") PointerPointer handle);
public static native int zixi_init_connection_handle(@Cast("void**") @ByPtrPtr Pointer handle);

/**
\brief		 destroys zixi connection handle.
<p>
@param		 handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_delete_connection_handle(Pointer handle);



/**
\brief		initialize a handle for zixi failover group.
<p>
@param		group_handle[out]	- handle to initialized group
@param		inputs				- amount of input streams in group
@param		input_handles[out]	- array of initialized handles for each component - handles should be configured and connected. can't read from these handles, and can't destroy them directly.
@param		search_window_ms	- search window to look for matches between components. streams are delayed up to this amount
@param		priorities			- array of priorities. 0 - backup stream; 1 - primary stream, optional, can be NULL.
@param		max_bitrate			- max bitrate expected on streams in bps.
@param		mode				- type of merge (None / RTP headers / Content). 
								  * Streams must be binary identical for merging to succeed.
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_init_failover_group(@Cast("void**") PointerPointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntPointer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntPointer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, IntBuffer priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);
public static native int zixi_init_failover_group(@Cast("void**") @ByPtrPtr Pointer group_handle, int inputs, @Cast("void***") @ByPtrPtr PointerPointer input_handles, int search_window_ms, int[] priorities, int max_bitrate, @Cast("ZIXI_FAILOVER_MODE") int mode);


/**
\brief		destroy and cleanup handle to zixi failover group.
<p>
@param		group_handle		- handle to initialized group
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_OK
@return		 ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_delete_failover_group( Pointer group_handle );


//--------------------------------------------------------
//			Configuration functions						
//--------------------------------------------------------


/**
\brief		reconfigure logging to new level or to different function.
<p>
@param		log_level	  - log detail level, 
						    [-1] to turn off , 	
						    [0] to log everything (significantly hurt performance - only for deep debugging) , 
						    [1-5] different log levels (3 recommended)
@param		log_func	  - logging function
@param		log_user_data - user data that will be returned as the first parameter in log_func
<p>
@return     ZIXI_ERROR_DLL_NOT_FOUND
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_client_configure_logging(int log_level, ZIXI_LOG_FUNC log_func, Pointer log_user_data);


/**
\brief		configure client id and session id.
			
			client id must be unique on a per broadcaster level.
			session id is used for authorization.
			when using RIST protocol - guid/session are used as SRP user/password for client authentication 
<p>
Warnings:	 Call zixi_configure_id(..) before the first zixi_connect(..)/zixi_async_connect(..)
<p>
@param		handle   - a handle to zixi connection returned by zixi_init_connection_handle
@param		guid	 - a unique identifier of the current client
@param		session	 - a session identifier that will be used for authorization
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_id(Pointer handle, @Cast("const char*") BytePointer guid, @Cast("const char*") BytePointer session);
public static native int zixi_configure_id(Pointer handle, String guid, String session);

/**
\brief		configure the cache that will be used when in progressive-download (PDL) mode.
<p>
Warnings: Cache size has a minimal value of several seconds of video. 
		  The minimal size is determined by the library on stream connection,
		  and depends on the individual stream and connection parameters.
		  If the provided cache size is too small, PDL mode will fail.
			 
		  You can not provide custom buffer and cache_path at the same time. 
		  At least one of the parameters must be NULL.
<p>
@param		handle        - a handle to zixi connection returned by zixi_init_connection_handle
@param		cache_size	  - the size of the cache to be used in progressive-download (PDL) mode, in bytes.
@param		cache_path	  - a path to a cache file, set to NULL to use in memory cache.
@param		custom_buffer - a pointer to preallocated buffer to be used for the cache 
							(must be at least cache_size bytes). 
							Set to NULL for internal allocation of the memory.
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") BytePointer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") ByteBuffer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") byte[] custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") BytePointer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, @Cast("const char*") BytePointer cache_path, @Cast("unsigned char*") ByteBuffer custom_buffer);
public static native int zixi_configure_pdl(Pointer handle, int cache_size, String cache_path, @Cast("unsigned char*") byte[] custom_buffer);


/**
<p>
\brief		 Configure error correction parameters, doesn't affect connection time.
			 
@param		 handle				- a handle to zixi connection returned by zixi_init_connection_handle
@param		 max_latency		- maximum latency, higher values allow more time for error correction.
@param		 latency_mode		- select latency mode, static/increasing recomended for players, dynamic for conversion to tcp protocols
@param		 fec_mode			- one of the ZIXI_FEC_MODE enum values
@param		 fec_overhead		- % of overhead over the original stream.
@param		 fec_block_ms		- fec block size in milli seconds  .
@param		 fec_content_aware	- true=enable content aware / false=disable content aware 
@param		 stuff_null_on_unrecovered - true=return a null packet when a packet cannot be recovered
@param		 max_output_jitter	- cap output jitter in milliseconds (recommended 0 to disable)
@param		fixed_end_to_end_delay - when true, decrease the propogation delay from max_latency to guarentee syncronization between receivers (default false)
<p>
@return		 ZIXI_ERROR_NOT_INITIALIZED
@return		 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_INVALID_PARAMETER
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_configure_error_correction(Pointer handle, @Cast("unsigned int") int max_latency, @Cast("ZIXI_LATENCY_MODE") int latency_mode, @Cast("ZIXI_FEC_MODE") int fec_mode, @Cast("unsigned int") int fec_overhead, @Cast("unsigned int") int fec_block_ms, @Cast("bool") boolean fec_content_aware, @Cast("bool") boolean stuff_null_on_unrecovered, @Cast("unsigned int") int max_output_jitter, @Cast("bool") boolean fixed_end_to_end_delay);


/**
\brief		 Configure decryption parameters for an encrypted stream.
		    
			 If the stream is not encrypted this will have no effect.
<p>
@param		 handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		 type   - encryption type
@param		 key	   - decryption key
<p>
@return      ZIXI_ERROR_NOT_INITIALIZED
@return  	 ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		 ZIXI_ERROR_INVALID_PARAMETER
@return		 ZIXI_ERROR_OK
*/
public static native int zixi_configure_decryption(Pointer handle, @Cast("ZIXI_ENCRYPTION") int type, @Cast("const char*") BytePointer key);
public static native int zixi_configure_decryption(Pointer handle, @Cast("ZIXI_ENCRYPTION") int type, String key);

/**
\brief		connect to a URL in 'zixi://' format
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		 url					- URL in zixi:// format
@param		 low_latency			- enable low_latency mode at the cost of connection time
@param		 callbacks				- callback functions to handle different events
@param		 ignore_dtls_cert_error - ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
@param		dtls_only				- connect only using DTLS protocol, never fallback to unencrypted
@param		skip_rtp				- if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
<p>
URL format:
zixi://[user[:session]\]server[:port]/channel
<p>
for eg:
zixi://myserver.com/news
zixi://myserver.com:2077/news
zixi://guest42\myserver.com:2077/news
zixi://guest42:hashashash\myserver.com:2077/news
zixi://my\email.com\myserver.com:2077/news
zixi://my\email.com:mypassword\myserver.com:2077/news
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_connect_url(Pointer handle, @Cast("const char*") BytePointer url, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean dtls_only, @Cast("bool") boolean skip_rtp);
public static native int zixi_connect_url(Pointer handle, String url, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean dtls_only, @Cast("bool") boolean skip_rtp);

/**
\brief		download a URL in 'zixi://' format
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		url						- URL in zixi:// format. see zixi_connect_url
@param		offset					- start dowload file from this offset, in bytes
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
<p>
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_download_url(Pointer handle, @Cast("const char*") BytePointer url, @Cast("unsigned long long") long bitrate, @Cast("unsigned long long") long offset, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);
public static native int zixi_download_url(Pointer handle, String url, @Cast("unsigned long long") long bitrate, @Cast("unsigned long long") long offset, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);

/**
\brief		Configure the all the main and alternative streams showing a given channel
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		streams			- a vector of the stream id's
@param		bitrates		- a vector of bitrates corresponding to the given streams
@param		count			- the number of streams
@param		auto_migrate	- adaptive streaming - allow automatic switching between bitrates
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") PointerPointer streams, @Cast("unsigned long long*") LongPointer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr BytePointer streams, @Cast("unsigned long long*") LongPointer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr ByteBuffer streams, @Cast("unsigned long long*") LongBuffer bitrates, int count, @Cast("bool") boolean auto_migrate);
public static native int zixi_configure_channel(Pointer handle, @Cast("char**") @ByPtrPtr byte[] streams, @Cast("unsigned long long*") long[] bitrates, int count, @Cast("bool") boolean auto_migrate);

/**
\brief		replace the internal socket communication with external read/write functions
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		read_function   - ptr for read function.
@param      read_param      - ptr for read parameters.
@param      write_function  - ptr for write function.
@param      write_param     - ptr for write parameters.
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return     ZIXI_ERROR_INVALID_PARAMETER
@return     ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_custom_io(Pointer handle, ZIXI_IO_FUNCTION read_function, Pointer read_param, ZIXI_IO_FUNCTION write_function, Pointer write_param);


/**
\brief		configure local network interface and port
			
			call before zixi_connect, zixi_async_connect, zixi_accept, zixi_connect_url or zixi_download_url
<p>
@param		handle		- a handle to zixi connection returned by zixi_init_connection_handle
@param		local_nic	- null terminated string of the local IP address to use. use null or "0.0.0.0" for any local IP
@param		local_port	- local port number. use 0 for automatic port selection
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_local_nic(Pointer handle, @Cast("const char*") BytePointer local_nic, @Cast("unsigned short") short local_port);
public static native int zixi_configure_local_nic(Pointer handle, String local_nic, @Cast("unsigned short") short local_port);

/**
\brief		configure adaptive parameters
			<p>
			call before zixi_connect, zixi_async_connect, zixi_accept, zixi_connect_url or zixi_download_url
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		initial_bitrate	- upper bound on starting bitrate
@param		max_bitrate		- maximum bitrate to use for adaptation
@param		down_threshold	- error correction threshold for adaptive down decisions, should be less then max latency [ms]
<p>
@return     ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_adaptive(Pointer handle, @Cast("unsigned int") int initial_bitrate, @Cast("unsigned int") int max_bitrate, int down_threshold);

//--------------------------------------------------------
//			Connect/Disconnect functions
//--------------------------------------------------------

/**
\brief		Connect to a broadcaster , Returns immediately.
			
			ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		host					- hostname or ip of the broadcaster
@param		port					- public port of the broadcaster
@param		index					- stream index from the vector of streams that was configured using zixi_configure_channel
@param		low_latency				- enable low_latency mode at the cost of connection time
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_async_connect(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean skip_rtp);
public static native int zixi_async_connect(Pointer handle, String host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error, @Cast("bool") boolean skip_rtp);

/**
\brief			Connect to a broadcaster , Returns after connection succeeded/failed.
				<p>
				ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle					- a handle to zixi connection returned by zixi_init_connection_handle
@param		host					- hostname or ip of the broadcaster
@param		port					- public port of the broadcaster
@param		index					- stream index from the vector of streams that was configured using zixi_configure_channel
@param		low_latency				- enable low_latency mode at the cost of connection time
@param		callbacks				- callback functions to handle different events
@param		ignore_dtls_cert_error	- ignore certificate error on dtls connection. 
										Use with caution, only if server is trusted.
										Upon certificate error DTLS connection will be established, and traffic will be encrypted.
@param		skip_rtp				- if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_RECONNECTING
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_connect(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);
public static native int zixi_connect(Pointer handle, String host, @Cast("unsigned short") short port, int index, @Cast("bool") boolean low_latency, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean ignore_dtls_cert_error);

/**
\brief			Wait for a connection from a feeder
				<p>
				ZIXI_CALLBACKS::zixi_status_changed will be called with connection status updates.
<p>
Warnings:	zixi_disconnect() must be called before calling this function a second time even if connection failed.
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		port		 - port on which the connection will be established
@param		callbacks	 - callback functions to handle different events
@param		skip_rtp     - if payload is MPEG-TS over RTP, skip RTP headers in data returned from read functions
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_ALREADY_CONNECTED
@return		ZIXI_ERROR_RECONNECTING
@return		ZIXI_ERROR_TEST_FAILED
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_accept(Pointer handle, @Cast("unsigned short") short port, @ByVal ZIXI_CALLBACKS callbacks, @Cast("bool") boolean skip_rtp, @Cast("ZIXI_PROTOCOL") int protocol);


/**
\brief		Configure parameters for RIST main profile accept mode
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		dtls		 - connect only using DTLS
@param		cert_filename- absolute path to a certificate file, in x.509 format. Mandatory when using DTLS
@param		key_filename - absolute path to a corresponding key file, in x.509 format. Mandatory when using DTLS
@param		key_passphrase - passphrase for the key file
@param		srp_user	 - optional TLS-SRP user
@param		srp_password - optional TLS-SRP password
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_rist_main_accept(Pointer handle, @Cast("bool") boolean dtls, @Cast("const char*") BytePointer cert_filename, @Cast("const char*") BytePointer key_filename, @Cast("const char*") BytePointer key_passphrase, @Cast("const char*") BytePointer srp_user, @Cast("const char*") BytePointer srp_password);
public static native int zixi_configure_rist_main_accept(Pointer handle, @Cast("bool") boolean dtls, String cert_filename, String key_filename, String key_passphrase, String srp_user, String srp_password);

/**
\brief		disconnect from the current server
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_disconnect(Pointer handle);


/**
\brief			configure ts output stream
<p>
@param		handle		 - a handle to zixi connection returned by zixi_init_connection_handle
@param		host		 - hostname or ip of the broadcaster
@param		port		 - public port of the broadcaster
<p>
@return		ZIXI_ERROR_OK
*/
public static native int zixi_configure_ts_output_stream(Pointer handle, @Cast("const char*") BytePointer host, @Cast("unsigned short") short port);
public static native int zixi_configure_ts_output_stream(Pointer handle, String host, @Cast("unsigned short") short port);


//--------------------------------------------------------
//			Stream control functions
//--------------------------------------------------------

/**
\brief		Jump to alternative bitrate.
			<p>
			when smooth = true the transition will not be noticeable in the video, but can take a few seconds
			when smooth = false, jump immediately
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		stream_index	- hostname or ip of the broadcaster
@param		smooth			- public port of the broadcaster
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_manual_migrate(Pointer handle, int stream_index, @Cast("bool") boolean smooth);

/**
\brief		Jump to alternative bitrate in new adaptive mode, only availabel in unicast mode
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		bitrate			- a bitrate from the available list (via zixi_query_adaptive_info) or 0 to re-enable automatic mode
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_adaptive_bitrate_switch(Pointer handle, int bitrate);

/**
\brief		pause the stream (only supported in VOD)
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
*/
public static native int zixi_stream_pause(Pointer handle);

/**
\brief		resume the stream (only supported in VOD)
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
*/
public static native int zixi_stream_resume(Pointer handle);

/**
\brief		seek to a different position in the stream , 
			any value between -1 and 100 is valid , 
			passing -1 will not actually seek, but will only test for this capability
<p>
@param		handle  - a handle to zixi connection returned by zixi_init_connection_handle
@param		percent	- the location to seek to, in percent of the total length
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_stream_seek(Pointer handle, float percent);

/**
\brief		eek to a different position in the stream , 
		    any value between 0 and file size is valid	
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		bytes  - the location to seek to
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_OK
@return 	ZIXI_ERROR_NOT_SUPPORTED
@return		ZIXI_ERROR_INVALID_PARAMETER
*/
public static native int zixi_stream_bytes_seek(Pointer handle, long bytes);

/**
\brief		Read ready frames from zixi and fill the given buffer as much as possible
<p>
Warnings:	Next zixi_read functions will continue to read from the point in stream where 
			previous call stopped, but calls to zixi_peek_frame and zixi_get_frame 
			will not take that offset into account. 
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		buff			- preallocated buffer to hold the returning data
@param		size			- size of the preallocated buffer
@param		written_size	- the amount of bytes written to buffer
@param		eof				- flag that indicates last buffer for VOD stream. 
							  calls to 'zixi_read' past the end of file will contain 0 bytes of data with the flag set
@param		discontinuity	- flag that indicates discontinuities whithin the current frame or between the last frame to the current(output)  
@param		full_frames		  when set, frames with discontinuity will be dropped
@param		bitrate			  current bitrate, in adaptive bitrate group
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_NOT_CONNECTED
@return		ZIXI_ERROR_NOT_READY
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_OK
*/
public static native int zixi_read(Pointer handle, @Cast("char*") BytePointer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntPointer written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, IntPointer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") ByteBuffer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntBuffer written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, IntBuffer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") byte[] buff, @Cast("unsigned int") int size, @Cast("unsigned int*") int[] written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, int[] bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") BytePointer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntPointer written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, IntPointer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") ByteBuffer buff, @Cast("unsigned int") int size, @Cast("unsigned int*") IntBuffer written_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, @Cast("bool") boolean full_frames, IntBuffer bitrate);
public static native int zixi_read(Pointer handle, @Cast("char*") byte[] buff, @Cast("unsigned int") int size, @Cast("unsigned int*") int[] written_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, @Cast("bool") boolean full_frames, int[] bitrate);

//--------------------------------------------------------
//			Stream status/statistics functions
//--------------------------------------------------------

/**
\brief		Returns the current stream info if available.
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		info   - pointer to a ZIXI_STREAM_INFO struct that will receive the current stream info	
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
@return	    ZIXI_ERROR_NOT_READY
*/
public static native int zixi_query_stream_info(Pointer handle, ZIXI_STREAM_INFO info);

/**
\brief		Returns the list of availabe bitrates and current active bitrate if the stream is adaptive, will fail for single bitrate streams
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		bitrates - pointer to a preallocated vector of at least ZIXI_MAX_ADAPTIVE_STREAMS values
@param		size - pointer to an integer that will receive the number of actuall available bitrates
@param		current - pointer to an integer that will receive the current active stream
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_OK
@return	    ZIXI_ERROR_NOT_READY
*/
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") IntPointer bitrates, @Cast("unsigned int*") IntPointer size, @Cast("unsigned int*") IntPointer current);
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") IntBuffer bitrates, @Cast("unsigned int*") IntBuffer size, @Cast("unsigned int*") IntBuffer current);
public static native int zixi_query_adaptive_info(Pointer handle, @Cast("unsigned int*") int[] bitrates, @Cast("unsigned int*") int[] size, @Cast("unsigned int*") int[] current);


/**
\brief		check the current network condition
<p>
Warnings:   this information updates once every 3 seconds, there is no use in calling this function more than once in 3 seconds.
<p>
@param		handle	- a handle to zixi connection returned by zixi_init_connection_handle
@param		latency	- an integer that will receive the current network latency value, in milliseconds.
@param		rtt		- an integer that will receive the current round trip time value, in milliseconds.
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return 	ZIXI_ERROR_OK
*/
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") IntPointer latency, @Cast("unsigned int*") IntPointer rtt);
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") IntBuffer latency, @Cast("unsigned int*") IntBuffer rtt);
public static native int zixi_query_latency(Pointer handle, @Cast("unsigned int*") int[] latency, @Cast("unsigned int*") int[] rtt);

/**
\brief		check the status of the cache file/in memory buffer
<p>
Warnings:   You can start reading data at any stage. The fullness will never reach 100%, do not wait for that to happen.
<p>
@param		handle		- a handle to zixi connection returned by zixi_init_connection_handle
@param		in_use		- will be set to true if currently connected in progressive-download mode
@param		fullness	- percentage of cache currently used.
@param		duration	- the duration of the video currently cached in the buffer in milliseconds
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_OK
*/
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, FloatPointer fullness, @Cast("unsigned int*") IntPointer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, FloatBuffer fullness, @Cast("unsigned int*") IntBuffer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, float[] fullness, @Cast("unsigned int*") int[] duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, FloatPointer fullness, @Cast("unsigned int*") IntPointer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") BoolPointer in_use, FloatBuffer fullness, @Cast("unsigned int*") IntBuffer duration);
public static native int zixi_query_pdl(Pointer handle, @Cast("bool*") boolean[] in_use, float[] fullness, @Cast("unsigned int*") int[] duration);

/**
\brief		query error correction statistics from the client library, this information is updated once every 3 seconds.
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
@param		con_stats  - ZIXI_CONNECTION_STATS structure for connection statistics
@param		net_stats  - ZIXI_NETWORK_STATS structure that will receive network statistics
@param		error_correction_stats  - ZIXI_ERROR_CORRECTION_STATS structure that will receive error correction statistics
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return	    ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_NOT_CONNECTED
@return	    ZIXI_ERROR_INVALID_PARAMETER
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_query_statistics(Pointer handle, ZIXI_CONNECTION_STATS con_stats, ZIXI_NETWORK_STATS net_stats, ZIXI_ERROR_CORRECTION_STATS error_correction_stats);


/**
\brief		query failover group components statistics
<p>
@param		group_handle - a handle to zixi failover group handle
@param		stats - preallocated array of ZIXI_FAILOVER_COMPONENT_STATS that will be filled by the function.
@param		count - amount of ZIXI_FAILOVER_COMPONENT_STATS structures in buffer. Should match the number of components in group
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return	    ZIXI_ERROR_FUNCTION_NOT_FOUND
@return	    ZIXI_ERROR_INVALID_PARAMETER
@return		ZIXI_ERROR_FAILED
@return	    ZIXI_ERROR_OK
*/
public static native int zixi_query_group_statistics( Pointer group_handle, ZIXI_FAILOVER_COMPONENT_STATS stats, int count );

//--------------------------------------------------------
//			Support functions
//--------------------------------------------------------

/**
\brief		get the last error after receiving a disconnected event
<p>
Warnings: this function must not be called from the ZIXI_STATUS_FUNC callback
<p>
@param		handle - a handle to zixi connection returned by zixi_init_connection_handle
<p>
@return		ZIXI_ERROR_AUTHORIZATION_FAILED
@return  	ZIXI_ERROR_LICENSING_FAILED
@return		ZIXI_ERROR_NETWORK_ERRORS
@return		ZIXI_ERROR_FAILED
@return		ZIXI_ERROR_TIMEOUT
@return		ZIXI_ERROR_NOT_INITIALIZED
@return		ZIXI_ERROR_FUNCTION_NOT_FOUND
@return		ZIXI_ERROR_VERSION
@return		ZIXI_ERROR_OK
@return		ZIXI_ERROR_SERVER_FULL
@return		ZIXI_ERROR_CERTIFICATE
*/
public static native int zixi_get_last_error(Pointer handle);

/**
\brief		returns the libzixiClient library version
<p>
@param      major	- major version number (will remain 0 until the first release version)
@param		minor	- minor version number (incremented each time we update our internal protocol)
@param		build	- build number  
<p>
@return		ZIXI_ERROR_NOT_INITIALIZED
@return 	ZIXI_ERROR_FUNCTION_NOT_FOUND
@return  	ZIXI_ERROR_OK
*/
public static native int zixi_client_version(IntPointer major, IntPointer minor, IntPointer minor_minor, IntPointer build);
public static native int zixi_client_version(IntBuffer major, IntBuffer minor, IntBuffer minor_minor, IntBuffer build);
public static native int zixi_client_version(int[] major, int[] minor, int[] minor_minor, int[] build);

/**
\brief		returns a descriptor for signaling, and the internal thread id
<p>
@param		handle			- a handle to zixi connection returned by zixi_init_connection_handle
@param		fd[out]			- pointer to a returned descriptor, fd is signalled when there is data to read
@param		thread_id[out]	- pointer to returned thread id
@param		socket[out]		- pointer to a returned socket handle, the internal native socket used in the communication
<p>
@return		ZIXI_ERROR_OK on success
*/
public static native int zixi_get_descriptors(Pointer handle, IntPointer fd, IntPointer thread_id, IntPointer socket);
public static native int zixi_get_descriptors(Pointer handle, IntBuffer fd, IntBuffer thread_id, IntBuffer socket);
public static native int zixi_get_descriptors(Pointer handle, int[] fd, int[] thread_id, int[] socket);

public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") PointerPointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr BytePointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr ByteBuffer buff, @Cast("unsigned int*") IntBuffer buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, IntBuffer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr byte[] buff, @Cast("unsigned int*") int[] buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, int[] queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr BytePointer buff, @Cast("unsigned int*") IntPointer buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, IntPointer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr ByteBuffer buff, @Cast("unsigned int*") IntBuffer buff_size, @Cast("bool*") BoolPointer eof, @Cast("bool*") BoolPointer discontinuity, IntBuffer queue_size);
public static native int zixi_get_ready_buffer(Pointer handle, @Cast("unsigned char**") @ByPtrPtr byte[] buff, @Cast("unsigned int*") int[] buff_size, @Cast("bool*") boolean[] eof, @Cast("bool*") boolean[] discontinuity, int[] queue_size);

// #ifdef __cplusplus	// extern "C"
// #endif


}
