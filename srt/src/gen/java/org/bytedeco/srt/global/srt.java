// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.srt.global;

import org.bytedeco.srt.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class srt extends org.bytedeco.srt.presets.srt {
    static { Loader.load(); }

// Parsed from linux/uio.h

/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
 *	Berkeley style UIO structures	-	Alan Cox 1994.
 *
 *		This program is free software; you can redistribute it and/or
 *		modify it under the terms of the GNU General Public License
 *		as published by the Free Software Foundation; either version
 *		2 of the License, or (at your option) any later version.
 */
// #ifndef __LINUX_UIO_H
// #define __LINUX_UIO_H


// #include <linux/types.h>
// Targeting ../iovec.java



/*
 *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
 */
 
public static final int UIO_FASTIOV =	8;
public static final int UIO_MAXIOV =	1024;


// #endif /* __LINUX_UIO_H */


// Parsed from sys/uio.h

/* Copyright (C) 1991-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

// #ifndef _SYS_UIO_H
public static final int _SYS_UIO_H =	1;

// #include <features.h>
// #include <sys/types.h>
// #include <bits/types/struct_iovec.h>
// #include <bits/uio_lim.h>
// #ifdef __IOV_MAX
// #else
// # undef UIO_MAXIOV
// #endif

/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long readv(int __fd, @Const iovec __iovec, int __count);

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long writev(int __fd, @Const iovec __iovec, int __count);


// #ifdef __USE_MISC
// #endif	/* Use misc.  */


// #ifdef __USE_GNU
// # ifndef __USE_FILE_OFFSET64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv2(int __fp, @Const iovec __iovec, int __count,
			@Cast("__off_t") long __offset, int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev2(int __fd, @Const iovec __iodev, int __count,
			 @Cast("__off_t") long __offset, int __flags);

// # else
// # endif

// # ifdef __USE_LARGEFILE64
/* Same as preadv but with an additional flag argumenti defined at uio.h.  */
public static native @Cast("ssize_t") long preadv64v2(int __fp, @Const iovec __iovec,
			   int __count, @Cast("__off64_t") long __offset,
			   int ___flags);

/* Same as preadv but with an additional flag argument defined at uio.h.  */
public static native @Cast("ssize_t") long pwritev64v2(int __fd, @Const iovec __iodev,
			    int __count, @Cast("__off64_t") long __offset,
			    int __flags);
// # endif
// #endif /* Use GNU.  */

/* Some operating systems provide system-specific extensions to this
   header.  */
// #ifdef __USE_GNU
// # include <bits/uio-ext.h>
// #endif

// #endif /* sys/uio.h */


// Parsed from bits/sockaddr.h

/* Definition of struct sockaddr_* common members and sizes, generic version.
   Copyright (C) 1995-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */

// #ifndef _BITS_SOCKADDR_H
public static final int _BITS_SOCKADDR_H =	1;


/* POSIX.1g specifies this type name for the `sa_family' member.  */

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

// #define	__SOCKADDR_COMMON(sa_prefix)
//   sa_family_t sa_prefix##family

public static native @MemberGetter int __SOCKADDR_COMMON_SIZE();
public static final int __SOCKADDR_COMMON_SIZE = __SOCKADDR_COMMON_SIZE();

/* Size of struct sockaddr_storage.  */
public static final int _SS_SIZE = 128;

// #endif	/* bits/sockaddr.h */


// Parsed from bits/socket.h

/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

// #ifndef __BITS_SOCKET_H
// #define __BITS_SOCKET_H

// #ifndef _SYS_SOCKET_H
// # error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
// #endif

// #define __need_size_t
// #include <stddef.h>

// #include <sys/types.h>

/* Type for length arguments in socket calls.  */
// #ifndef __socklen_t_defined
// # define __socklen_t_defined
// #endif

/* Get the architecture-dependent definition of enum __socket_type.  */
// #include <bits/socket_type.h>

/* Protocol families.  */
public static final int PF_UNSPEC =	0;	/* Unspecified.  */
public static final int PF_LOCAL =	1;	/* Local to host (pipes and file-domain).  */
public static final int PF_UNIX =		PF_LOCAL; /* POSIX name for PF_LOCAL.  */
public static final int PF_FILE =		PF_LOCAL; /* Another non-standard name for PF_LOCAL.  */
public static final int PF_INET =		2;	/* IP protocol family.  */
public static final int PF_AX25 =		3;	/* Amateur Radio AX.25.  */
public static final int PF_IPX =		4;	/* Novell Internet Protocol.  */
public static final int PF_APPLETALK =	5;	/* Appletalk DDP.  */
public static final int PF_NETROM =	6;	/* Amateur radio NetROM.  */
public static final int PF_BRIDGE =	7;	/* Multiprotocol bridge.  */
public static final int PF_ATMPVC =	8;	/* ATM PVCs.  */
public static final int PF_X25 =		9;	/* Reserved for X.25 project.  */
public static final int PF_INET6 =	10;	/* IP version 6.  */
public static final int PF_ROSE =		11;	/* Amateur Radio X.25 PLP.  */
public static final int PF_DECnet =	12;	/* Reserved for DECnet project.  */
public static final int PF_NETBEUI =	13;	/* Reserved for 802.2LLC project.  */
public static final int PF_SECURITY =	14;	/* Security callback pseudo AF.  */
public static final int PF_KEY =		15;	/* PF_KEY key management API.  */
public static final int PF_NETLINK =	16;
public static final int PF_ROUTE =	PF_NETLINK; /* Alias to emulate 4.4BSD.  */
public static final int PF_PACKET =	17;	/* Packet family.  */
public static final int PF_ASH =		18;	/* Ash.  */
public static final int PF_ECONET =	19;	/* Acorn Econet.  */
public static final int PF_ATMSVC =	20;	/* ATM SVCs.  */
public static final int PF_RDS =		21;	/* RDS sockets.  */
public static final int PF_SNA =		22;	/* Linux SNA Project */
public static final int PF_IRDA =		23;	/* IRDA sockets.  */
public static final int PF_PPPOX =	24;	/* PPPoX sockets.  */
public static final int PF_WANPIPE =	25;	/* Wanpipe API sockets.  */
public static final int PF_LLC =		26;	/* Linux LLC.  */
public static final int PF_IB =		27;	/* Native InfiniBand address.  */
public static final int PF_MPLS =		28;	/* MPLS.  */
public static final int PF_CAN =		29;	/* Controller Area Network.  */
public static final int PF_TIPC =		30;	/* TIPC sockets.  */
public static final int PF_BLUETOOTH =	31;	/* Bluetooth sockets.  */
public static final int PF_IUCV =		32;	/* IUCV sockets.  */
public static final int PF_RXRPC =	33;	/* RxRPC sockets.  */
public static final int PF_ISDN =		34;	/* mISDN sockets.  */
public static final int PF_PHONET =	35;	/* Phonet sockets.  */
public static final int PF_IEEE802154 =	36;	/* IEEE 802.15.4 sockets.  */
public static final int PF_CAIF =		37;	/* CAIF sockets.  */
public static final int PF_ALG =		38;	/* Algorithm sockets.  */
public static final int PF_NFC =		39;	/* NFC sockets.  */
public static final int PF_VSOCK =	40;	/* vSockets.  */
public static final int PF_KCM =		41;	/* Kernel Connection Multiplexor.  */
public static final int PF_QIPCRTR =	42;	/* Qualcomm IPC Router.  */
public static final int PF_SMC =		43;	/* SMC sockets.  */
public static final int PF_MAX =		44;	/* For now..  */

/* Address families.  */
public static final int AF_UNSPEC =	PF_UNSPEC;
public static final int AF_LOCAL =	PF_LOCAL;
public static final int AF_UNIX =		PF_UNIX;
public static final int AF_FILE =		PF_FILE;
public static final int AF_INET =		PF_INET;
public static final int AF_AX25 =		PF_AX25;
public static final int AF_IPX =		PF_IPX;
public static final int AF_APPLETALK =	PF_APPLETALK;
public static final int AF_NETROM =	PF_NETROM;
public static final int AF_BRIDGE =	PF_BRIDGE;
public static final int AF_ATMPVC =	PF_ATMPVC;
public static final int AF_X25 =		PF_X25;
public static final int AF_INET6 =	PF_INET6;
public static final int AF_ROSE =		PF_ROSE;
public static final int AF_DECnet =	PF_DECnet;
public static final int AF_NETBEUI =	PF_NETBEUI;
public static final int AF_SECURITY =	PF_SECURITY;
public static final int AF_KEY =		PF_KEY;
public static final int AF_NETLINK =	PF_NETLINK;
public static final int AF_ROUTE =	PF_ROUTE;
public static final int AF_PACKET =	PF_PACKET;
public static final int AF_ASH =		PF_ASH;
public static final int AF_ECONET =	PF_ECONET;
public static final int AF_ATMSVC =	PF_ATMSVC;
public static final int AF_RDS =		PF_RDS;
public static final int AF_SNA =		PF_SNA;
public static final int AF_IRDA =		PF_IRDA;
public static final int AF_PPPOX =	PF_PPPOX;
public static final int AF_WANPIPE =	PF_WANPIPE;
public static final int AF_LLC =		PF_LLC;
public static final int AF_IB =		PF_IB;
public static final int AF_MPLS =		PF_MPLS;
public static final int AF_CAN =		PF_CAN;
public static final int AF_TIPC =		PF_TIPC;
public static final int AF_BLUETOOTH =	PF_BLUETOOTH;
public static final int AF_IUCV =		PF_IUCV;
public static final int AF_RXRPC =	PF_RXRPC;
public static final int AF_ISDN =		PF_ISDN;
public static final int AF_PHONET =	PF_PHONET;
public static final int AF_IEEE802154 =	PF_IEEE802154;
public static final int AF_CAIF =		PF_CAIF;
public static final int AF_ALG =		PF_ALG;
public static final int AF_NFC =		PF_NFC;
public static final int AF_VSOCK =	PF_VSOCK;
public static final int AF_KCM =		PF_KCM;
public static final int AF_QIPCRTR =	PF_QIPCRTR;
public static final int AF_SMC =		PF_SMC;
public static final int AF_MAX =		PF_MAX;

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
public static final int SOL_RAW =		255;
public static final int SOL_DECNET =      261;
public static final int SOL_X25 =         262;
public static final int SOL_PACKET =	263;
public static final int SOL_ATM =		264;	/* ATM layer (cell level).  */
public static final int SOL_AAL =		265;	/* ATM Adaption Layer (packet level).  */
public static final int SOL_IRDA =	266;
public static final int SOL_NETBEUI =	267;
public static final int SOL_LLC =		268;
public static final int SOL_DCCP =	269;
public static final int SOL_NETLINK =	270;
public static final int SOL_TIPC =	271;
public static final int SOL_RXRPC =	272;
public static final int SOL_PPPOL2TP =	273;
public static final int SOL_BLUETOOTH =	274;
public static final int SOL_PNPIPE =	275;
public static final int SOL_RDS =		276;
public static final int SOL_IUCV =	277;
public static final int SOL_CAIF =	278;
public static final int SOL_ALG =		279;
public static final int SOL_NFC =		280;
public static final int SOL_KCM =		281;
public static final int SOL_TLS =		282;

/* Maximum queue length specifiable by listen.  */
public static final int SOMAXCONN =	128;

/* Get the definition of the macro to define the common sockaddr members.  */
// #include <bits/sockaddr.h>
// Targeting ../sockaddr.java




/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
// #define __ss_aligntype	unsigned long int
public static native @MemberGetter int _SS_PADSIZE();
public static final int _SS_PADSIZE = _SS_PADSIZE();
// Targeting ../sockaddr_storage.java




/* Bits in the FLAGS argument to `send', `recv', et al.  */
/** enum  */
public static final int
    MSG_OOB		 = 0x01,	/* Process out-of-band data.  */
// #define MSG_OOB		MSG_OOB
    MSG_PEEK		 = 0x02,	/* Peek at incoming messages.  */
// #define MSG_PEEK	MSG_PEEK
    MSG_DONTROUTE	 = 0x04,	/* Don't use local routing.  */
// #define MSG_DONTROUTE	MSG_DONTROUTE
// #ifdef __USE_GNU
    /* DECnet uses a different name.  */
    MSG_TRYHARD		 = MSG_DONTROUTE,
// # define MSG_TRYHARD	MSG_DONTROUTE
// #endif
    MSG_CTRUNC		 = 0x08,	/* Control data lost before delivery.  */
// #define MSG_CTRUNC	MSG_CTRUNC
    MSG_PROXY		 = 0x10,	/* Supply or ask second address.  */
// #define MSG_PROXY	MSG_PROXY
    MSG_TRUNC		 = 0x20,
// #define MSG_TRUNC	MSG_TRUNC
    MSG_DONTWAIT	 = 0x40, /* Nonblocking IO.  */
// #define MSG_DONTWAIT	MSG_DONTWAIT
    MSG_EOR		 = 0x80, /* End of record.  */
// #define MSG_EOR		MSG_EOR
    MSG_WAITALL		 = 0x100, /* Wait for a full request.  */
// #define MSG_WAITALL	MSG_WAITALL
    MSG_FIN		 = 0x200,
// #define MSG_FIN		MSG_FIN
    MSG_SYN		 = 0x400,
// #define MSG_SYN		MSG_SYN
    MSG_CONFIRM		 = 0x800, /* Confirm path validity.  */
// #define MSG_CONFIRM	MSG_CONFIRM
    MSG_RST		 = 0x1000,
// #define MSG_RST		MSG_RST
    MSG_ERRQUEUE	 = 0x2000, /* Fetch message from error queue.  */
// #define MSG_ERRQUEUE	MSG_ERRQUEUE
    MSG_NOSIGNAL	 = 0x4000, /* Do not generate SIGPIPE.  */
// #define MSG_NOSIGNAL	MSG_NOSIGNAL
    MSG_MORE		 = 0x8000,  /* Sender will send more.  */
// #define MSG_MORE	MSG_MORE
    MSG_WAITFORONE	 = 0x10000, /* Wait for at least one packet to return.*/
// #define MSG_WAITFORONE	MSG_WAITFORONE
    MSG_BATCH		 = 0x40000, /* sendmmsg: more messages coming.  */
// #define MSG_BATCH	MSG_BATCH
    MSG_ZEROCOPY	 = 0x4000000, /* Use user data in kernel path.  */
// #define MSG_ZEROCOPY	MSG_ZEROCOPY
    MSG_FASTOPEN	 = 0x20000000, /* Send data in TCP SYN.  */
// #define MSG_FASTOPEN	MSG_FASTOPEN

    MSG_CMSG_CLOEXEC	 = 0x40000000;	/* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */
// #define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
// Targeting ../msghdr.java


// Targeting ../cmsghdr.java



/* Ancillary data object manipulation macros.  */
// #if __glibc_c99_flexarr_available
// # define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
// #else
// # define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
// #endif
// #define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
// #define CMSG_FIRSTHDR(mhdr)
//   ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)
//    ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
// #define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1)
// 			 & (size_t) ~(sizeof (size_t) - 1))
// #define CMSG_SPACE(len) (CMSG_ALIGN (len)
// 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
// #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))

public static native cmsghdr __cmsg_nxthdr(msghdr __mhdr,
				      cmsghdr __cmsg);
// #ifdef __USE_EXTERN_INLINES
// #endif	/* Use `extern inline'.  */

/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
/** enum  */
public static final int
    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
// #define SCM_RIGHTS SCM_RIGHTS
    SCM_CREDENTIALS = 0x02;	/* Credentials passing.  */
// # define SCM_CREDENTIALS SCM_CREDENTIALS
// #endif
// Targeting ../ucred.java


// #endif

/* Ugly workaround for unclean kernel headers.  */
// #ifndef __USE_MISC
// # ifndef FIOGETOWN
// #  define __SYS_SOCKET_H_undef_FIOGETOWN
// # endif
// # ifndef FIOSETOWN
// #  define __SYS_SOCKET_H_undef_FIOSETOWN
// # endif
// # ifndef SIOCATMARK
// #  define __SYS_SOCKET_H_undef_SIOCATMARK
// # endif
// # ifndef SIOCGPGRP
// #  define __SYS_SOCKET_H_undef_SIOCGPGRP
// # endif
// # ifndef SIOCGSTAMP
// #  define __SYS_SOCKET_H_undef_SIOCGSTAMP
// # endif
// # ifndef SIOCGSTAMPNS
// #  define __SYS_SOCKET_H_undef_SIOCGSTAMPNS
// # endif
// # ifndef SIOCSPGRP
// #  define __SYS_SOCKET_H_undef_SIOCSPGRP
// # endif
// #endif
// #ifndef IOCSIZE_MASK
// # define __SYS_SOCKET_H_undef_IOCSIZE_MASK
// #endif
// #ifndef IOCSIZE_SHIFT
// # define __SYS_SOCKET_H_undef_IOCSIZE_SHIFT
// #endif
// #ifndef IOC_IN
// # define __SYS_SOCKET_H_undef_IOC_IN
// #endif
// #ifndef IOC_INOUT
// # define __SYS_SOCKET_H_undef_IOC_INOUT
// #endif
// #ifndef IOC_OUT
// # define __SYS_SOCKET_H_undef_IOC_OUT
// #endif

/* Get socket manipulation related informations from kernel headers.  */
// #include <asm/socket.h>
// Targeting ../linger.java



// #endif	/* bits/socket.h */


// Parsed from sys/socket.h

/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

// #ifndef	_SYS_SOCKET_H
public static final int _SYS_SOCKET_H =	1;

// #include <features.h>


// #endif /* sys/socket.h */


// Parsed from sys/syslog.h

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
 */

// #ifndef _SYS_SYSLOG_H
public static final int _SYS_SYSLOG_H = 1;

// #include <features.h>
// #define __need___va_list
// #include <stdarg.h>

/* This file defines _PATH_LOG.  */
// #include <bits/syslog-path.h>

/*
 * priorities/facilities are encoded into a single 32-bit quantity, where the
 * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
 * (0-big number).  Both the priorities and the facilities map roughly
 * one-to-one to strings in the syslogd(8) source code.  This mapping is
 * included in this file.
 *
 * priorities (these are ordered)
 */
public static final int LOG_EMERG =	0;	/* system is unusable */
public static final int LOG_ALERT =	1;	/* action must be taken immediately */
public static final int LOG_CRIT =	2;	/* critical conditions */
public static final int LOG_ERR =		3;	/* error conditions */
public static final int LOG_WARNING =	4;	/* warning conditions */
public static final int LOG_NOTICE =	5;	/* normal but significant condition */
public static final int LOG_INFO =	6;	/* informational */
public static final int LOG_DEBUG =	7;	/* debug-level messages */

public static final int LOG_PRIMASK =	0x07;	/* mask to extract priority part (internal) */
				/* extract priority */
// #define	LOG_PRI(p)	((p) & LOG_PRIMASK)
// #define	LOG_MAKEPRI(fac, pri)	((fac) | (pri))

// #ifdef SYSLOG_NAMES
// #endif

/* facility codes */
public static final int LOG_KERN =	(0<<3);	/* kernel messages */
public static final int LOG_USER =	(1<<3);	/* random user-level messages */
public static final int LOG_MAIL =	(2<<3);	/* mail system */
public static final int LOG_DAEMON =	(3<<3);	/* system daemons */
public static final int LOG_AUTH =	(4<<3);	/* security/authorization messages */
public static final int LOG_SYSLOG =	(5<<3);	/* messages generated internally by syslogd */
public static final int LOG_LPR =		(6<<3);	/* line printer subsystem */
public static final int LOG_NEWS =	(7<<3);	/* network news subsystem */
public static final int LOG_UUCP =	(8<<3);	/* UUCP subsystem */
public static final int LOG_CRON =	(9<<3);	/* clock daemon */
public static final int LOG_AUTHPRIV =	(10<<3);	/* security/authorization messages (private) */
public static final int LOG_FTP =		(11<<3);	/* ftp daemon */

	/* other codes through 15 reserved for system use */
public static final int LOG_LOCAL0 =	(16<<3);	/* reserved for local use */
public static final int LOG_LOCAL1 =	(17<<3);	/* reserved for local use */
public static final int LOG_LOCAL2 =	(18<<3);	/* reserved for local use */
public static final int LOG_LOCAL3 =	(19<<3);	/* reserved for local use */
public static final int LOG_LOCAL4 =	(20<<3);	/* reserved for local use */
public static final int LOG_LOCAL5 =	(21<<3);	/* reserved for local use */
public static final int LOG_LOCAL6 =	(22<<3);	/* reserved for local use */
public static final int LOG_LOCAL7 =	(23<<3);	/* reserved for local use */

public static final int LOG_NFACILITIES =	24;	/* current number of facilities */
public static final int LOG_FACMASK =	0x03f8;	/* mask to extract facility part */
				/* facility of pri */
// #define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)

// #ifdef SYSLOG_NAMES
// #endif

/*
 * arguments to setlogmask.
 */
// #define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
// #define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */

/*
 * Option flags for openlog.
 *
 * LOG_ODELAY no longer does anything.
 * LOG_NDELAY is the inverse of what it used to be.
 */
public static final int LOG_PID =		0x01;	/* log the pid with each message */
public static final int LOG_CONS =	0x02;	/* log on the console if errors in sending */
public static final int LOG_ODELAY =	0x04;	/* delay open until first syslog() (default) */
public static final int LOG_NDELAY =	0x08;	/* don't delay open */
public static final int LOG_NOWAIT =	0x10;	/* don't wait for console forks: DEPRECATED */
public static final int LOG_PERROR =	0x20;	/* log to stderr as well */

/* Close descriptor used to write to system logger.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void closelog();

/* Open connection to system logger.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void openlog(@Cast("const char*") BytePointer __ident, int __option, int __facility);
public static native void openlog(String __ident, int __option, int __facility);

/* Set the log mask level.  */
public static native int setlogmask(int __mask);

/* Generate a log message using FMT string and option arguments.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void syslog(int __pri, @Cast("const char*") BytePointer __fmt);
public static native void syslog(int __pri, String __fmt);

// #ifdef __USE_MISC
// #endif


/* Define some macros helping to catch buffer overflows.  */
// #if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
// # include <bits/syslog.h>
// #endif
// #ifdef __LDBL_COMPAT
// # include <bits/syslog-db.h>
// #endif

// #endif /* sys/syslog.h */


// Parsed from srt/logging_api.h

/*
 * SRT - Secure, Reliable, Transport
 * Copyright (c) 2018 Haivision Systems Inc.
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 */

/*****************************************************************************
written by
   Haivision Systems Inc.
 *****************************************************************************/

// #ifndef INC_SRT_LOGGING_API_H
// #define INC_SRT_LOGGING_API_H

// These are required for access functions:
// - adding FA (requires set)
// - setting a log stream (requires iostream)
// #ifdef __cplusplus
// #include <set>
// #include <iostream>
// #endif

// #ifdef _WIN32
// #else
// #include <syslog.h>
// #endif

// Syslog is included so that it provides log level names.
// Haivision log standard requires the same names plus extra one:
// #ifndef LOG_DEBUG_TRACE
public static final int LOG_DEBUG_TRACE = 8;
// #endif
// It's unused anyway, just for the record.
public static final int SRT_LOG_LEVEL_MIN = LOG_CRIT;
public static final int SRT_LOG_LEVEL_MAX = LOG_DEBUG;

// Flags
public static final int SRT_LOGF_DISABLE_TIME = 1;
public static final int SRT_LOGF_DISABLE_THREADNAME = 2;
public static final int SRT_LOGF_DISABLE_SEVERITY = 4;
public static final int SRT_LOGF_DISABLE_EOL = 8;
// Targeting ../SRT_LOG_HANDLER_FN.java


// Targeting ../LogFA.java



@Namespace("srt_logging") @MemberGetter public static native @Const @ByRef LogFA LOGFA_GENERAL();
    // There are 3 general levels:

    // A. fatal - this means the application WILL crash.
    // B. unexpected:
    //    - error: this was unexpected for the library
    //    - warning: this was expected by the library, but may be harmful for the application
    // C. expected:
    //    - note: a significant, but rarely occurring event
    //    - debug: may occur even very often and enabling it can harm performance

    /** enum srt_logging::LogLevel::type */
    public static final int
        fatal = LOG_CRIT,
        // Fatal vs. Error: with Error, you can still continue.
        error = LOG_ERR,
        // Error vs. Warning: Warning isn't considered a problem for the library.
        warning = LOG_WARNING,
        // Warning vs. Note: Note means something unusual, but completely correct behavior.
        note = LOG_NOTICE,
        // Note vs. Debug: Debug may occur even multiple times in a millisecond.
        // (Well, worth noting that Error and Warning potentially also can).
        debug = LOG_DEBUG;

// Targeting ../Logger.java




// #endif

// #endif


// Parsed from srt/srt.h

/*
 * SRT - Secure, Reliable, Transport
 * Copyright (c) 2018 Haivision Systems Inc.
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 */

/*****************************************************************************
written by
   Haivision Systems Inc.
 *****************************************************************************/

// #ifndef INC_SRTC_H
// #define INC_SRTC_H

// #include "version.h"

// #include "platform_sys.h"

// #include <string.h>
// #include <stdlib.h>

// #include "logging_api.h"

////////////////////////////////////////////////////////////////////////////////

//if compiling on VC6.0 or pre-WindowsXP systems
//use -DLEGACY_WIN32

//if compiling with MinGW, it only works on XP or above
//use -D_WIN32_WINNT=0x0501


// #ifdef _WIN32
// #else
//    #define SRT_API __attribute__ ((visibility("default")))
// #endif


// For feature tests if you need.
// You can use these constants with SRTO_MINVERSION option.
public static final int SRT_VERSION_FEAT_HSv5 = 0x010300;

// #if defined(__cplusplus) && __cplusplus > 201406
public static final int SRT_HAVE_CXX17 = 1;
// #else
// #endif


// Stadnard attributes

// When compiling in C++17 mode, use the standard C++17 attributes
// (out of these, only [[deprecated]] is supported in C++14, so
// for all lesser standard use compiler-specific attributes).
// #if SRT_HAVE_CXX17

// Unused: DO NOT issue a warning if this entity is unused.
// #define SRT_ATR_UNUSED [[maybe_unused]]

// Nodiscard: issue a warning if the return value was discarded.
// #define SRT_ATR_NODISCARD [[nodiscard]]

// GNUG is GNU C/C++; this syntax is also supported by Clang
// #elif defined(__GNUC__)
// #elif defined(_MSC_VER)
// #define SRT_ATR_UNUSED __pragma(warning(suppress: 4100 4101))
// #define SRT_ATR_NODISCARD _Check_return_
// #else
// #define SRT_ATR_UNUSED
// #define SRT_ATR_NODISCARD
// #endif


// DEPRECATED attributes

// There's needed DEPRECATED and DEPRECATED_PX, as some compilers require them
// before the entity, others after the entity.
// The *_PX version is the prefix attribute, which applies only
// to functions (Microsoft compilers).

// When deprecating a function, mark it:
//
// SRT_ATR_DEPRECATED_PX retval function(arguments) SRT_ATR_DEPRECATED;
//

// When SRT_NO_DEPRECATED defined, do not issue any deprecation warnings.
// Regardless of the compiler type.
// #if defined(SRT_NO_DEPRECATED)

// #define SRT_ATR_DEPRECATED
// #define SRT_ATR_DEPRECATED_PX

// #elif SRT_HAVE_CXX17

// #define SRT_ATR_DEPRECATED
// #define SRT_ATR_DEPRECATED_PX [[deprecated]]

// GNUG is GNU C/C++; this syntax is also supported by Clang
// #elif defined(__GNUC__)
// #elif defined(_MSC_VER)
// #define SRT_ATR_DEPRECATED_PX __declspec(deprecated)
// #define SRT_ATR_DEPRECATED // no postfix-type modifier
// #else
// #define SRT_ATR_DEPRECATED_PX
// #define SRT_ATR_DEPRECATED
// #endif

// #ifdef __cplusplus
// #endif

// The most significant bit 31 (sign bit actually) is left unused,
// so that all people who check the value for < 0 instead of -1
// still get what they want. The bit 30 is reserved for marking
// the "socket group". Most of the API functions should work
// transparently with the socket descriptor designating a single
// socket or a socket group.
@MemberGetter public static native int SRTGROUP_MASK();
public static final int SRTGROUP_MASK = SRTGROUP_MASK();

// #ifdef _WIN32
// #else
// #endif

// #ifndef ENABLE_EXPERIMENTAL_BONDING
public static native @MemberGetter int ENABLE_EXPERIMENTAL_BONDING();
public static final int ENABLE_EXPERIMENTAL_BONDING = ENABLE_EXPERIMENTAL_BONDING();
// #endif


// Values returned by srt_getsockstate()
/** enum SRT_SOCKSTATUS */
public static final int
   SRTS_INIT = 1,
   SRTS_OPENED = 2,
   SRTS_LISTENING = 3,
   SRTS_CONNECTING = 4,
   SRTS_CONNECTED = 5,
   SRTS_BROKEN = 6,
   SRTS_CLOSING = 7,
   SRTS_CLOSED = 8,
   SRTS_NONEXIST = 9;

// This is a duplicate enum. Must be kept in sync with the original UDT enum for
// backward compatibility until all compat is destroyed.
/** enum SRT_SOCKOPT */
public static final int

   SRTO_MSS = 0,             // the Maximum Transfer Unit
   SRTO_SNDSYN = 1,          // if sending is blocking
   SRTO_RCVSYN = 2,          // if receiving is blocking
   SRTO_ISN = 3,             // Initial Sequence Number (valid only after srt_connect or srt_accept-ed sockets)
   SRTO_FC = 4,              // Flight flag size (window size)
   SRTO_SNDBUF = 5,          // maximum buffer in sending queue
   SRTO_RCVBUF = 6,          // UDT receiving buffer size
   SRTO_LINGER = 7,          // waiting for unsent data when closing
   SRTO_UDP_SNDBUF = 8,      // UDP sending buffer size
   SRTO_UDP_RCVBUF = 9,      // UDP receiving buffer size
   // (some space left)
   SRTO_RENDEZVOUS = 12,     // rendezvous connection mode
   SRTO_SNDTIMEO = 13,       // send() timeout
   SRTO_RCVTIMEO = 14,       // recv() timeout
   SRTO_REUSEADDR = 15,      // reuse an existing port or create a new one
   SRTO_MAXBW = 16,          // maximum bandwidth (bytes per second) that the connection can use
   SRTO_STATE = 17,          // current socket state, see UDTSTATUS, read only
   SRTO_EVENT = 18,          // current available events associated with the socket
   SRTO_SNDDATA = 19,        // size of data in the sending buffer
   SRTO_RCVDATA = 20,        // size of data available for recv
   SRTO_SENDER = 21,         // Sender mode (independent of conn mode), for encryption, tsbpd handshake.
   SRTO_TSBPDMODE = 22,      // Enable/Disable TsbPd. Enable -> Tx set origin timestamp, Rx deliver packet at origin time + delay
   SRTO_LATENCY = 23,        // NOT RECOMMENDED. SET: to both SRTO_RCVLATENCY and SRTO_PEERLATENCY. GET: same as SRTO_RCVLATENCY.
   SRTO_INPUTBW = 24,        // Estimated input stream rate.
   SRTO_OHEADBW = 25,             // MaxBW ceiling based on % over input stream rate. Applies when UDT_MAXBW=0 (auto).
   SRTO_PASSPHRASE = 26,     // Crypto PBKDF2 Passphrase (must be 10..79 characters, or empty to disable encryption)
   SRTO_PBKEYLEN = 27,            // Crypto key len in bytes {16,24,32} Default: 16 (AES-128)
   SRTO_KMSTATE = 28,             // Key Material exchange status (UDT_SRTKmState)
   SRTO_IPTTL = 29,          // IP Time To Live (passthru for system sockopt IPPROTO_IP/IP_TTL)
   SRTO_IPTOS = 30,               // IP Type of Service (passthru for system sockopt IPPROTO_IP/IP_TOS)
   SRTO_TLPKTDROP = 31,      // Enable receiver pkt drop
   SRTO_SNDDROPDELAY = 32,   // Extra delay towards latency for sender TLPKTDROP decision (-1 to off)
   SRTO_NAKREPORT = 33,      // Enable receiver to send periodic NAK reports
   SRTO_VERSION = 34,        // Local SRT Version
   SRTO_PEERVERSION = 35,         // Peer SRT Version (from SRT Handshake)
   SRTO_CONNTIMEO = 36,      // Connect timeout in msec. Caller default: 3000, rendezvous (x 10)
   SRTO_DRIFTTRACER = 37,    // Enable or disable drift tracer
   SRTO_MININPUTBW = 38,     // Minimum estimate of input stream rate.
   // (some space left)
   SRTO_SNDKMSTATE = 40,     // (GET) the current state of the encryption at the peer side
   SRTO_RCVKMSTATE = 41,          // (GET) the current state of the encryption at the agent side
   SRTO_LOSSMAXTTL = 42,          // Maximum possible packet reorder tolerance (number of packets to receive after loss to send lossreport)
   SRTO_RCVLATENCY = 43,          // TsbPd receiver delay (mSec) to absorb burst of missed packet retransmission
   SRTO_PEERLATENCY = 44,         // Minimum value of the TsbPd receiver delay (mSec) for the opposite side (peer)
   SRTO_MINVERSION = 45,          // Minimum SRT version needed for the peer (peers with less version will get connection reject)
   SRTO_STREAMID = 46,            // A string set to a socket and passed to the listener's accepted socket
   SRTO_CONGESTION = 47,          // Congestion controller type selection
   SRTO_MESSAGEAPI = 48,          // In File mode, use message API (portions of data with boundaries)
   SRTO_PAYLOADSIZE = 49,         // Maximum payload size sent in one UDP packet (0 if unlimited)
   SRTO_TRANSTYPE = 50,      // Transmission type (set of options required for given transmission type)
   SRTO_KMREFRESHRATE = 51,       // After sending how many packets the encryption key should be flipped to the new key
   SRTO_KMPREANNOUNCE = 52,       // How many packets before key flip the new key is annnounced and after key flip the old one decommissioned
   SRTO_ENFORCEDENCRYPTION = 53,  // Connection to be rejected or quickly broken when one side encryption set or bad password
   SRTO_IPV6ONLY = 54,            // IPV6_V6ONLY mode
   SRTO_PEERIDLETIMEO = 55,       // Peer-idle timeout (max time of silence heard from peer) in [ms]
   SRTO_BINDTODEVICE = 56,        // Forward the SOL_SOCKET/SO_BINDTODEVICE option on socket (pass packets only from that device)
// #if ENABLE_EXPERIMENTAL_BONDING
// #endif
   SRTO_PACKETFILTER = 60,   // Add and configure a packet filter
   SRTO_RETRANSMITALGO = 61,  // An option to select packet retransmission algorithm

   SRTO_E_SIZE = 62; // Always last element, not a valid option.


// #ifdef __cplusplus


// #if __cplusplus > 199711L // C++11
    // Newer compilers report error when [[deprecated]] is applied to types,
    // and C++11 and higher uses this.
    // Note that this doesn't exactly use the 'deprecated' attribute,
    // as it's introduced in C++14. What is actually used here is the
    // fact that unknown attributes are ignored, but still warned about.
    // This should only catch an eye - and that's what it does.
// #define SRT_DEPRECATED_OPTION(value) ((SRT_SOCKOPT [[deprecated]])value)
// #else
    // Older (pre-C++11) compilers use gcc deprecated applied to a typedef
// #define SRT_DEPRECATED_OPTION(value) ((SRT_SOCKOPT_DEPRECATED)value)
// #endif


// #else

// deprecated enum labels are supported only since gcc 6, so in C there
// will be a whole deprecated enum type, as it's not an error in C to mix
// enum types
/** enum SRT_SOCKOPT_DEPRECATED */
public static final int

    // Dummy last option, as every entry ends with a comma
    SRTO_DEPRECATED_END = 0;
// #define SRT_DEPRECATED_OPTION(value) ((enum SRT_SOCKOPT_DEPRECATED)value)
// #endif

// Note that there are no deprecated options at the moment, but the mechanism
// stays so that it can be used in future. Example:
// #define SRTO_STRICTENC SRT_DEPRECATED_OPTION(53)

/** enum SRT_TRANSTYPE */
public static final int
    SRTT_LIVE = 0,
    SRTT_FILE = 1,
    SRTT_INVALID = 2;

// These sizes should be used for Live mode. In Live mode you should not
// exceed the size that fits in a single MTU.

// This is for MPEG TS and it's a default SRTO_PAYLOADSIZE for SRTT_LIVE.
@MemberGetter public static native int SRT_LIVE_DEF_PLSIZE();
public static final int SRT_LIVE_DEF_PLSIZE = SRT_LIVE_DEF_PLSIZE(); // = 188*7, recommended for MPEG TS

// This is the maximum payload size for Live mode, should you have a different
// payload type than MPEG TS.
@MemberGetter public static native int SRT_LIVE_MAX_PLSIZE();
public static final int SRT_LIVE_MAX_PLSIZE = SRT_LIVE_MAX_PLSIZE(); // MTU(1500) - UDP.hdr(28) - SRT.hdr(16)

// Latency for Live transmission: default is 120
@MemberGetter public static native int SRT_LIVE_DEF_LATENCY_MS();
public static final int SRT_LIVE_DEF_LATENCY_MS = SRT_LIVE_DEF_LATENCY_MS();
// Targeting ../CBytePerfMon.java



////////////////////////////////////////////////////////////////////////////////

// Error codes - define outside the CUDTException class
// because otherwise you'd have to use CUDTException::MJ_SUCCESS etc.
// in all throw CUDTException expressions.
/** enum CodeMajor */
public static final int
    MJ_UNKNOWN    = -1,
    MJ_SUCCESS    = 0,
    MJ_SETUP      = 1,
    MJ_CONNECTION = 2,
    MJ_SYSTEMRES  = 3,
    MJ_FILESYSTEM = 4,
    MJ_NOTSUP     = 5,
    MJ_AGAIN      = 6,
    MJ_PEERERROR  = 7;

/** enum CodeMinor */
public static final int
    // These are "minor" error codes from various "major" categories
    // MJ_SETUP
    MN_NONE            = 0,
    MN_TIMEOUT         = 1,
    MN_REJECTED        = 2,
    MN_NORES           = 3,
    MN_SECURITY        = 4,
    MN_CLOSED          = 5,
    // MJ_CONNECTION
    MN_CONNLOST        = 1,
    MN_NOCONN          = 2,
    // MJ_SYSTEMRES
    MN_THREAD          = 1,
    MN_MEMORY          = 2,
    MN_OBJECT          = 3,
    // MJ_FILESYSTEM
    MN_SEEKGFAIL       = 1,
    MN_READFAIL        = 2,
    MN_SEEKPFAIL       = 3,
    MN_WRITEFAIL       = 4,
    // MJ_NOTSUP
    MN_ISBOUND         = 1,
    MN_ISCONNECTED     = 2,
    MN_INVAL           = 3,
    MN_SIDINVAL        = 4,
    MN_ISUNBOUND       = 5,
    MN_NOLISTEN        = 6,
    MN_ISRENDEZVOUS    = 7,
    MN_ISRENDUNBOUND   = 8,
    MN_INVALMSGAPI     = 9,
    MN_INVALBUFFERAPI  = 10,
    MN_BUSY            = 11,
    MN_XSIZE           = 12,
    MN_EIDINVAL        = 13,
    MN_EEMPTY          = 14,
    MN_BUSYPORT        = 15,
    // MJ_AGAIN
    MN_WRAVAIL         = 1,
    MN_RDAVAIL         = 2,
    MN_XMTIMEOUT       = 3,
    MN_CONGESTION      = 4;


// Stupid, but effective. This will be #undefined, so don't worry.
// #define MJ(major) (1000 * MJ_##major)
// #define MN(major, minor) (1000 * MJ_##major + MN_##minor)

// Some better way to define it, and better for C language.
/** enum SRT_ERRNO */
public static final int
    SRT_EUNKNOWN        = -1,
    SRT_SUCCESS         = MJ_SUCCESS,

    SRT_ECONNSETUP      = (1000 * MJ_SETUP),
    SRT_ENOSERVER       = (1000 * MJ_SETUP + MN_TIMEOUT),
    SRT_ECONNREJ        = (1000 * MJ_SETUP + MN_REJECTED),
    SRT_ESOCKFAIL       = (1000 * MJ_SETUP + MN_NORES),
    SRT_ESECFAIL        = (1000 * MJ_SETUP + MN_SECURITY),
    SRT_ESCLOSED        = (1000 * MJ_SETUP + MN_CLOSED),

    SRT_ECONNFAIL       = (1000 * MJ_CONNECTION),
    SRT_ECONNLOST       = (1000 * MJ_CONNECTION + MN_CONNLOST),
    SRT_ENOCONN         = (1000 * MJ_CONNECTION + MN_NOCONN),

    SRT_ERESOURCE       = (1000 * MJ_SYSTEMRES),
    SRT_ETHREAD         = (1000 * MJ_SYSTEMRES + MN_THREAD),
    SRT_ENOBUF          = (1000 * MJ_SYSTEMRES + MN_MEMORY),
    SRT_ESYSOBJ         = (1000 * MJ_SYSTEMRES + MN_OBJECT),

    SRT_EFILE           = (1000 * MJ_FILESYSTEM),
    SRT_EINVRDOFF       = (1000 * MJ_FILESYSTEM + MN_SEEKGFAIL),
    SRT_ERDPERM         = (1000 * MJ_FILESYSTEM + MN_READFAIL),
    SRT_EINVWROFF       = (1000 * MJ_FILESYSTEM + MN_SEEKPFAIL),
    SRT_EWRPERM         = (1000 * MJ_FILESYSTEM + MN_WRITEFAIL),

    SRT_EINVOP          = (1000 * MJ_NOTSUP),
    SRT_EBOUNDSOCK      = (1000 * MJ_NOTSUP + MN_ISBOUND),
    SRT_ECONNSOCK       = (1000 * MJ_NOTSUP + MN_ISCONNECTED),
    SRT_EINVPARAM       = (1000 * MJ_NOTSUP + MN_INVAL),
    SRT_EINVSOCK        = (1000 * MJ_NOTSUP + MN_SIDINVAL),
    SRT_EUNBOUNDSOCK    = (1000 * MJ_NOTSUP + MN_ISUNBOUND),
    SRT_ENOLISTEN       = (1000 * MJ_NOTSUP + MN_NOLISTEN),
    SRT_ERDVNOSERV      = (1000 * MJ_NOTSUP + MN_ISRENDEZVOUS),
    SRT_ERDVUNBOUND     = (1000 * MJ_NOTSUP + MN_ISRENDUNBOUND),
    SRT_EINVALMSGAPI    = (1000 * MJ_NOTSUP + MN_INVALMSGAPI),
    SRT_EINVALBUFFERAPI = (1000 * MJ_NOTSUP + MN_INVALBUFFERAPI),
    SRT_EDUPLISTEN      = (1000 * MJ_NOTSUP + MN_BUSY),
    SRT_ELARGEMSG       = (1000 * MJ_NOTSUP + MN_XSIZE),
    SRT_EINVPOLLID      = (1000 * MJ_NOTSUP + MN_EIDINVAL),
    SRT_EPOLLEMPTY      = (1000 * MJ_NOTSUP + MN_EEMPTY),
    SRT_EBINDCONFLICT   = (1000 * MJ_NOTSUP + MN_BUSYPORT),

    SRT_EASYNCFAIL      = (1000 * MJ_AGAIN),
    SRT_EASYNCSND       = (1000 * MJ_AGAIN + MN_WRAVAIL),
    SRT_EASYNCRCV       = (1000 * MJ_AGAIN + MN_RDAVAIL),
    SRT_ETIMEOUT        = (1000 * MJ_AGAIN + MN_XMTIMEOUT),
    SRT_ECONGEST        = (1000 * MJ_AGAIN + MN_CONGESTION),

    SRT_EPEERERR        = (1000 * MJ_PEERERROR);


// #undef MJ
// #undef MN

/** enum SRT_REJECT_REASON */
public static final int
    SRT_REJ_UNKNOWN = 0,     // initial set when in progress
    SRT_REJ_SYSTEM = 1,      // broken due to system function error
    SRT_REJ_PEER = 2,        // connection was rejected by peer
    SRT_REJ_RESOURCE = 3,    // internal problem with resource allocation
    SRT_REJ_ROGUE = 4,       // incorrect data in handshake messages
    SRT_REJ_BACKLOG = 5,     // listener's backlog exceeded
    SRT_REJ_IPE = 6,         // internal program error
    SRT_REJ_CLOSE = 7,       // socket is closing
    SRT_REJ_VERSION = 8,     // peer is older version than agent's minimum set
    SRT_REJ_RDVCOOKIE = 9,   // rendezvous cookie collision
    SRT_REJ_BADSECRET = 10,   // wrong password
    SRT_REJ_UNSECURE = 11,    // password required or unexpected
    SRT_REJ_MESSAGEAPI = 12,  // streamapi/messageapi collision
    SRT_REJ_CONGESTION = 13,  // incompatible congestion-controller type
    SRT_REJ_FILTER = 14,      // incompatible packet filter
    SRT_REJ_GROUP = 15,       // incompatible group
    SRT_REJ_TIMEOUT = 16,     // connection timeout

    SRT_REJ_E_SIZE = 17;

// XXX This value remains for some time, but it's deprecated
// Planned deprecation removal: rel1.6.0.
public static final int SRT_REJ__SIZE = SRT_REJ_E_SIZE;

// Reject category codes:

// #define SRT_REJC_VALUE(code) (1000 * (code/1000))
public static final int SRT_REJC_INTERNAL = 0;     // Codes from above SRT_REJECT_REASON enum
public static final int SRT_REJC_PREDEFINED = 1000;  // Standard server error codes
public static final int SRT_REJC_USERDEFINED = 2000;    // User defined error codes


// Logging API - specialization for SRT.

// WARNING: This part is generated.

// Logger Functional Areas
// Note that 0 is "general".

// Values 0* - general, unqualified
// Values 1* - control
// Values 2* - receiving
// Values 3* - sending
// Values 4* - management

// Made by #define so that it's available also for C API.

// Use ../scripts/generate-logging-defs.tcl to regenerate.

// SRT_LOGFA BEGIN GENERATED SECTION {

public static final int SRT_LOGFA_GENERAL =    0;   // gglog: General uncategorized log, for serious issues only
public static final int SRT_LOGFA_SOCKMGMT =   1;   // smlog: Socket create/open/close/configure activities
public static final int SRT_LOGFA_CONN =       2;   // cnlog: Connection establishment and handshake
public static final int SRT_LOGFA_XTIMER =     3;   // xtlog: The checkTimer and around activities
public static final int SRT_LOGFA_TSBPD =      4;   // tslog: The TsBPD thread
public static final int SRT_LOGFA_RSRC =       5;   // rslog: System resource allocation and management

public static final int SRT_LOGFA_CONGEST =    7;   // cclog: Congestion control module
public static final int SRT_LOGFA_PFILTER =    8;   // pflog: Packet filter module

public static final int SRT_LOGFA_API_CTRL =   11;  // aclog: API part for socket and library managmenet

public static final int SRT_LOGFA_QUE_CTRL =   13;  // qclog: Queue control activities

public static final int SRT_LOGFA_EPOLL_UPD =  16;  // eilog: EPoll, internal update activities

public static final int SRT_LOGFA_API_RECV =   21;  // arlog: API part for receiving
public static final int SRT_LOGFA_BUF_RECV =   22;  // brlog: Buffer, receiving side
public static final int SRT_LOGFA_QUE_RECV =   23;  // qrlog: Queue, receiving side
public static final int SRT_LOGFA_CHN_RECV =   24;  // krlog: CChannel, receiving side
public static final int SRT_LOGFA_GRP_RECV =   25;  // grlog: Group, receiving side

public static final int SRT_LOGFA_API_SEND =   31;  // aslog: API part for sending
public static final int SRT_LOGFA_BUF_SEND =   32;  // bslog: Buffer, sending side
public static final int SRT_LOGFA_QUE_SEND =   33;  // qslog: Queue, sending side
public static final int SRT_LOGFA_CHN_SEND =   34;  // kslog: CChannel, sending side
public static final int SRT_LOGFA_GRP_SEND =   35;  // gslog: Group, sending side

public static final int SRT_LOGFA_INTERNAL =   41;  // inlog: Internal activities not connected directly to a socket

public static final int SRT_LOGFA_QUE_MGMT =   43;  // qmlog: Queue, management part
public static final int SRT_LOGFA_CHN_MGMT =   44;  // kmlog: CChannel, management part
public static final int SRT_LOGFA_GRP_MGMT =   45;  // gmlog: Group, management part
public static final int SRT_LOGFA_EPOLL_API =  46;  // ealog: EPoll, API part

public static final int SRT_LOGFA_HAICRYPT =   6;   // hclog: Haicrypt module area
public static final int SRT_LOGFA_APPLOG =     10;  // aplog: Applications

// } SRT_LOGFA END GENERATED SECTION

// To make a typical int64_t size, although still use std::bitset.
// C API will carry it over.
public static final int SRT_LOGFA_LASTNONE = 63;

/** enum SRT_KM_STATE */
public static final int
    SRT_KM_S_UNSECURED = 0,      //No encryption
    SRT_KM_S_SECURING  = 1,      //Stream encrypted, exchanging Keying Material
    SRT_KM_S_SECURED   = 2,      //Stream encrypted, keying Material exchanged, decrypting ok.
    SRT_KM_S_NOSECRET  = 3,      //Stream encrypted and no secret to decrypt Keying Material
    SRT_KM_S_BADSECRET = 4;       //Stream encrypted and wrong secret, cannot decrypt Keying Material

/** enum SRT_EPOLL_OPT */
public static final int
   
///
///
///
///
   SRT_EPOLL_OPT_NONE = 0x0, // fallback

   // Values intended to be the same as in `<sys/epoll.h>`.
   // so that if system values are used by mistake, they should have the same effect
   // This applies to: IN, OUT, ERR and ET.

   /** Ready for 'recv' operation:
    * 
    *  - For stream mode it means that at least 1 byte is available.
    *  In this mode the buffer may extract only a part of the packet,
    *  leaving next data possible for extraction later.
    * 
    *  - For message mode it means that there is at least one packet
    *  available (this may change in future, as it is desired that
    *  one full message should only wake up, not single packet of a
    *  not yet extractable message).
    * 
    *  - For live mode it means that there's at least one packet
    *  ready to play.
    * 
    *  - For listener sockets, this means that there is a new connection
    *  waiting for pickup through the {@code srt_accept()} call, that is,
    *  the next call to {@code srt_accept()} will succeed without blocking
    *  (see an alias SRT_EPOLL_ACCEPT below). */
   
///
///
///
///
   SRT_EPOLL_IN       = 0x1,

   /** Ready for 'send' operation.
    * 
    *  - For stream mode it means that there's a free space in the
    *  sender buffer for at least 1 byte of data. The next send
    *  operation will only allow to send as much data as it is free
    *  space in the buffer.
    * 
    *  - For message mode it means that there's a free space for at
    *  least one UDP packet. The edge-triggered mode can be used to
    *  pick up updates as the free space in the sender buffer grows.
    * 
    *  - For live mode it means that there's a free space for at least
    *  one UDP packet. On the other hand, no readiness for OUT usually
    *  means an extraordinary congestion on the link, meaning also that
    *  you should immediately slow down the sending rate or you may get
    *  a connection break soon.
    * 
    *  - For non-blocking sockets used with {@code srt_connect*} operation,
    *  this flag simply means that the connection was established. */
   SRT_EPOLL_OUT      = 0x4,

   /** The socket has encountered an error in the last operation
    *  and the next operation on that socket will end up with error.
    *  You can retry the operation, but getting the error from it
    *  is certain, so you may as well close the socket. */
   SRT_EPOLL_ERR      = 0x8,

   // To avoid confusion in the internal code, the following
   // duplicates are introduced to improve clarity.
   SRT_EPOLL_CONNECT = SRT_EPOLL_OUT,
   SRT_EPOLL_ACCEPT = SRT_EPOLL_IN,

   SRT_EPOLL_UPDATE = 0x10,
   SRT_EPOLL_ET       = 1 << 31;
// These are actually flags - use a bit container:

// Define which epoll flags determine events. All others are special flags.
public static final int SRT_EPOLL_EVENTTYPES = (SRT_EPOLL_IN | SRT_EPOLL_OUT | SRT_EPOLL_UPDATE | SRT_EPOLL_ERR);
public static final int SRT_EPOLL_ETONLY = (SRT_EPOLL_UPDATE);

/** enum SRT_EPOLL_FLAGS */
public static final int
    /** This allows the EID container to be empty when calling the waiting
     *  function with infinite time. This means an infinite hangup, although
     *  a socket can be added to this EID from a separate thread. */
    SRT_EPOLL_ENABLE_EMPTY = 1,

    /** This makes the waiting function check if there is output container
     *  passed to it, and report an error if it isn't. By default it is allowed
     *  that the output container is 0 size or NULL and therefore the readiness
     *  state is reported only as a number of ready sockets from return value. */
    SRT_EPOLL_ENABLE_OUTPUTCHECK = 2;

// #ifdef __cplusplus
// In C++ these enums cannot be treated as int and glued by operator |.
// Unless this operator is defined.
public static native @Cast("SRT_EPOLL_OPT") @Name("operator |") int or(@Cast("SRT_EPOLL_OPT") int a1, @Cast("SRT_EPOLL_OPT") int a2);
// Targeting ../SRT_TRACEBSTATS.java



@MemberGetter public static native @Cast("const SRTSOCKET") int SRT_INVALID_SOCK();
public static final int SRT_INVALID_SOCK = SRT_INVALID_SOCK();
@MemberGetter public static native int SRT_ERROR();
public static final int SRT_ERROR = SRT_ERROR();

// library initialization
public static native int srt_startup();
public static native int srt_cleanup();

//
// Socket operations
//
// DEPRECATED: srt_socket with 3 arguments. All these arguments are ignored
// and socket creation doesn't need any arguments. Use srt_create_socket().
// Planned deprecation removal: rel1.6.0
public static native @Cast("SRTSOCKET") int srt_socket(int arg0, int arg1, int arg2);
public static native @Cast("SRTSOCKET") int srt_create_socket();
// Targeting ../SRT_SOCKGROUPDATA.java



// #if ENABLE_EXPERIMENTAL_BONDING

// #endif // ENABLE_EXPERIMENTAL_BONDING

public static native int srt_bind(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen);
public static native int srt_bind_acquire(@Cast("SRTSOCKET") int u, @Cast("UDPSOCKET") int sys_udp_sock);
// Old name of srt_bind_acquire(), please don't use
// Planned deprecation removal: rel1.6.0
public static native int srt_bind_peerof(@Cast("SRTSOCKET") int u, @Cast("UDPSOCKET") int sys_udp_sock);
public static native int srt_listen(@Cast("SRTSOCKET") int u, int backlog);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, IntPointer addrlen);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, IntBuffer addrlen);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, int[] addrlen);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") IntPointer listeners, int lsize, @Cast("int64_t") long msTimeOut);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") IntBuffer listeners, int lsize, @Cast("int64_t") long msTimeOut);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") int[] listeners, int lsize, @Cast("int64_t") long msTimeOut);
// Targeting ../srt_listen_callback_fn.java


public static native int srt_listen_callback(@Cast("SRTSOCKET") int lsn, srt_listen_callback_fn hook_fn, Pointer hook_opaque);
// Targeting ../srt_connect_callback_fn.java


public static native int srt_connect_callback(@Cast("SRTSOCKET") int clr, srt_connect_callback_fn hook_fn, Pointer hook_opaque);
public static native int srt_connect(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen);
public static native int srt_connect_debug(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen, int forced_isn);
public static native int srt_connect_bind(@Cast("SRTSOCKET") int u, @Const sockaddr source,
                                    @Const sockaddr target, int len);
public static native int srt_rendezvous(@Cast("SRTSOCKET") int u, @Const sockaddr local_name, int local_namelen,
                                    @Const sockaddr remote_name, int remote_namelen);

public static native int srt_close(@Cast("SRTSOCKET") int u);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, IntPointer namelen);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, IntBuffer namelen);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, int[] namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, IntPointer namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, IntBuffer namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, int[] namelen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, IntPointer optlen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, IntBuffer optlen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, int[] optlen);
public static native int srt_setsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, @Const Pointer optval, int optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, IntPointer optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, IntBuffer optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, int[] optlen);
public static native int srt_setsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, @Const Pointer optval, int optlen);
// Targeting ../SRT_MSGCTRL.java



// Trap representation for sequence and message numbers
// This value means that this is "unset", and it's never
// a result of an operation made on this number.
@MemberGetter public static native int SRT_SEQNO_NONE();
public static final int SRT_SEQNO_NONE = SRT_SEQNO_NONE();    // -1: no seq (0 is a valid seqno!)
@MemberGetter public static native int SRT_MSGNO_NONE();
public static final int SRT_MSGNO_NONE = SRT_MSGNO_NONE();    // -1: unset
@MemberGetter public static native int SRT_MSGNO_CONTROL();
public static final int SRT_MSGNO_CONTROL = SRT_MSGNO_CONTROL();  //  0: control (used by packet filter)

@MemberGetter public static native int SRT_MSGTTL_INF();
public static final int SRT_MSGTTL_INF = SRT_MSGTTL_INF(); // unlimited TTL specification for message TTL

// XXX Might be useful also other special uses of -1:
// - -1 as infinity for srt_epoll_wait
// - -1 as a trap index value used in list.cpp

// You are free to use either of these two methods to set SRT_MSGCTRL object
// to default values: either call srt_msgctrl_init(&obj) or obj = srt_msgctrl_default.
public static native void srt_msgctrl_init(SRT_MSGCTRL mctrl);
@MemberGetter public static native @Const @ByRef SRT_MSGCTRL srt_msgctrl_default();

// The send/receive functions.
// These functions have different names due to different sets of parameters
// to be supplied. Not all of them are needed or make sense in all modes:

// Plain: supply only the buffer and its size.
// Msg: supply additionally
// - TTL (message is not delivered when exceeded) and
// - INORDER (when false, the message is allowed to be delivered in different
// order than when it was sent, when the later message is earlier ready to
// deliver)
// Msg2: Supply extra parameters in SRT_MSGCTRL. When receiving, these
// parameters will be filled, as needed. NULL is acceptable, in which case
// the defaults are used.

//
// Sending functions
//
public static native int srt_send(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len);
public static native int srt_send(@Cast("SRTSOCKET") int u, String buf, int len);
public static native int srt_sendmsg(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len, int ttl, int inorder);
public static native int srt_sendmsg(@Cast("SRTSOCKET") int u, String buf, int len, int ttl, int inorder);
public static native int srt_sendmsg2(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_sendmsg2(@Cast("SRTSOCKET") int u, String buf, int len, SRT_MSGCTRL mctrl);

//
// Receiving functions
//
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len);
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len);
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len);

// srt_recvmsg is actually an alias to srt_recv, it stays under the old name for compat reasons.
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len);
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len);
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len, SRT_MSGCTRL mctrl);


// Special send/receive functions for files only.
public static final int SRT_DEFAULT_SENDFILE_BLOCK = 364000;
public static final int SRT_DEFAULT_RECVFILE_BLOCK = 7280000;
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);


// last error detection
public static native @Cast("const char*") BytePointer srt_getlasterror_str();
public static native int srt_getlasterror(IntPointer errno_loc);
public static native int srt_getlasterror(IntBuffer errno_loc);
public static native int srt_getlasterror(int[] errno_loc);
public static native @Cast("const char*") BytePointer srt_strerror(int code, int errnoval);
public static native void srt_clearlasterror();

// Performance tracking
// Performance monitor with Byte counters for better bitrate estimation.
public static native int srt_bstats(@Cast("SRTSOCKET") int u, SRT_TRACEBSTATS perf, int clear);
// Performance monitor with Byte counters and instantaneous stats instead of moving averages for Snd/Rcvbuffer sizes.
public static native int srt_bistats(@Cast("SRTSOCKET") int u, SRT_TRACEBSTATS perf, int clear, int instantaneous);

// Socket Status (for problem tracking)
public static native @Cast("SRT_SOCKSTATUS") int srt_getsockstate(@Cast("SRTSOCKET") int u);

public static native int srt_epoll_create();
public static native int srt_epoll_clear_usocks(int eid);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntPointer events);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntBuffer events);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const int[] events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntPointer events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntBuffer events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const int[] events);
public static native int srt_epoll_remove_usock(int eid, @Cast("SRTSOCKET") int u);
public static native int srt_epoll_remove_ssock(int eid, @Cast("SYSSOCKET") int s);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntPointer events);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntBuffer events);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const int[] events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntPointer events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntBuffer events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const int[] events);

public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") IntPointer readfds, IntPointer rnum, @Cast("SRTSOCKET*") IntPointer writefds, IntPointer wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") IntPointer lrfds, IntPointer lrnum, @Cast("SYSSOCKET*") IntPointer lwfds, IntPointer lwnum);
public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") IntBuffer readfds, IntBuffer rnum, @Cast("SRTSOCKET*") IntBuffer writefds, IntBuffer wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") IntBuffer lrfds, IntBuffer lrnum, @Cast("SYSSOCKET*") IntBuffer lwfds, IntBuffer lwnum);
public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") int[] readfds, int[] rnum, @Cast("SRTSOCKET*") int[] writefds, int[] wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") int[] lrfds, int[] lrnum, @Cast("SYSSOCKET*") int[] lwfds, int[] lwnum);
// Targeting ../SRT_EPOLL_EVENT.java


public static native int srt_epoll_uwait(int eid, SRT_EPOLL_EVENT fdsSet, int fdsSize, @Cast("int64_t") long msTimeOut);

public static native int srt_epoll_set(int eid, int flags);
public static native int srt_epoll_release(int eid);

// Logging control

public static native void srt_setloglevel(int ll);
public static native void srt_addlogfa(int fa);
public static native void srt_dellogfa(int fa);
public static native void srt_resetlogfa(@Const IntPointer fara, @Cast("size_t") long fara_size);
public static native void srt_resetlogfa(@Const IntBuffer fara, @Cast("size_t") long fara_size);
public static native void srt_resetlogfa(@Const int[] fara, @Cast("size_t") long fara_size);
// This isn't predicted, will be only available in SRT C++ API.
// For the time being, until this API is ready, use UDT::setlogstream.
// SRT_API void srt_setlogstream(std::ostream& stream);
public static native void srt_setloghandler(Pointer opaque, SRT_LOG_HANDLER_FN handler);
public static native void srt_setlogflags(int flags);


public static native int srt_getsndbuffer(@Cast("SRTSOCKET") int sock, @Cast("size_t*") SizeTPointer blocks, @Cast("size_t*") SizeTPointer bytes);

public static native int srt_getrejectreason(@Cast("SRTSOCKET") int sock);
public static native int srt_setrejectreason(@Cast("SRTSOCKET") int sock, int value);
@MemberGetter public static native @Cast("const char*") BytePointer srt_rejectreason_msg(int i);
@MemberGetter public static native @Cast("const char*const*") PointerPointer srt_rejectreason_msg();
public static native @Cast("const char*") BytePointer srt_rejectreason_str(int id);

public static native @Cast("uint32_t") int srt_getversion();

public static native @Cast("int64_t") long srt_time_now();

public static native @Cast("int64_t") long srt_connection_time(@Cast("SRTSOCKET") int sock);

// Possible internal clock types
public static final int SRT_SYNC_CLOCK_STDCXX_STEADY =      0; // C++11 std::chrono::steady_clock
public static final int SRT_SYNC_CLOCK_GETTIME_MONOTONIC =  1; // clock_gettime with CLOCK_MONOTONIC
public static final int SRT_SYNC_CLOCK_WINQPC =             2;
public static final int SRT_SYNC_CLOCK_MACH_ABSTIME =       3;
public static final int SRT_SYNC_CLOCK_POSIX_GETTIMEOFDAY = 4;
public static final int SRT_SYNC_CLOCK_AMD64_RDTSC =        5;
public static final int SRT_SYNC_CLOCK_IA32_RDTSC =         6;
public static final int SRT_SYNC_CLOCK_IA64_ITC =           7;

public static native int srt_clock_type();

// #ifdef __cplusplus
// #endif

// #endif


}
