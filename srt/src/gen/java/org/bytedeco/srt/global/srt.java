// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.srt.global;

import org.bytedeco.srt.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class srt extends org.bytedeco.srt.presets.srt {
    static { Loader.load(); }

// Parsed from sys/_types/_iovec_t.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_IOVEC
// #define _STRUCT_IOVEC
// #include <sys/_types/_size_t.h>
// Targeting ../iovec.java


// #endif /* _STRUCT_IOVEC */


// Parsed from sys/socket.h

/*
 * Copyright (c) 2000-2019 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
 */
/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */

// #ifndef _SYS_SOCKET_H_
// #define _SYS_SOCKET_H_

// #include <sys/types.h>
// #include <sys/cdefs.h>
// #include <machine/_param.h>
// #include <net/net_kev.h>


// #include <Availability.h>

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Data types.
 */

// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sa_family_t.h>
// #include <sys/_types/_socklen_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_size_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_ssize_t.h>

/*
 * [XSI] The iovec structure shall be defined as described in <sys/uio.h>.
 */
// #include <sys/_types/_iovec_t.h>

/*
 * Types
 */
public static final int SOCK_STREAM =     1;               /* stream socket */
public static final int SOCK_DGRAM =      2;               /* datagram socket */
public static final int SOCK_RAW =        3;               /* raw-protocol interface */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_RDM =        4;               /* reliably-delivered message */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SOCK_SEQPACKET =  5;               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
public static final int SO_DEBUG =        0x0001;          /* turn on debugging info recording */
public static final int SO_ACCEPTCONN =   0x0002;          /* socket has had listen() */
public static final int SO_REUSEADDR =    0x0004;          /* allow local address reuse */
public static final int SO_KEEPALIVE =    0x0008;          /* keep connections alive */
public static final int SO_DONTROUTE =    0x0010;          /* just use interface addresses */
public static final int SO_BROADCAST =    0x0020;          /* permit sending of broadcast msgs */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_USELOOPBACK =  0x0040;          /* bypass hardware when possible */
public static final int SO_LINGER =       0x0080;          /* linger on close if data present (in ticks) */
// #else
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SO_OOBINLINE =    0x0100;          /* leave received OOB data in line */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_REUSEPORT =    0x0200;          /* allow local address & port reuse */
public static final int SO_TIMESTAMP =    0x0400;          /* timestamp received dgram traffic */
public static final int SO_TIMESTAMP_MONOTONIC =  0x0800;  /* Monotonically increasing timestamp on rcvd dgram */
// #ifndef __APPLE__
// #else
public static final int SO_DONTTRUNC =    0x2000;          /* APPLE: Retain unread data */
                                        /*  (ATOMIC proto) */
public static final int SO_WANTMORE =     0x4000;          /* APPLE: Give hint when more data ready */
public static final int SO_WANTOOBFLAG =  0x8000;          /* APPLE: Want OOB in MSG_FLAG on receive */


// #endif  /* (!__APPLE__) */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Additional options, not kept in so_options.
 */
public static final int SO_SNDBUF =       0x1001;          /* send buffer size */
public static final int SO_RCVBUF =       0x1002;          /* receive buffer size */
public static final int SO_SNDLOWAT =     0x1003;          /* send low-water mark */
public static final int SO_RCVLOWAT =     0x1004;          /* receive low-water mark */
public static final int SO_SNDTIMEO =     0x1005;          /* send timeout */
public static final int SO_RCVTIMEO =     0x1006;          /* receive timeout */
public static final int SO_ERROR =        0x1007;          /* get error status and clear */
public static final int SO_TYPE =         0x1008;          /* get socket type */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_LABEL =        0x1010;          /* deprecated */
public static final int SO_PEERLABEL =    0x1011;          /* deprecated */
// #ifdef __APPLE__
public static final int SO_NREAD =        0x1020;          /* APPLE: get 1st-packet byte count */
public static final int SO_NKE =          0x1021;          /* APPLE: Install socket-level NKE */
public static final int SO_NOSIGPIPE =    0x1022;          /* APPLE: No SIGPIPE on EPIPE */
public static final int SO_NOADDRERR =    0x1023;          /* APPLE: Returns EADDRNOTAVAIL when src is not available anymore */
public static final int SO_NWRITE =       0x1024;          /* APPLE: Get number of bytes currently in send socket buffer */
public static final int SO_REUSESHAREUID =        0x1025;          /* APPLE: Allow reuse of port/socket by different userids */
// #ifdef __APPLE_API_PRIVATE
public static final int SO_NOTIFYCONFLICT =       0x1026;  /* APPLE: send notification if there is a bind on a port which is already in use */
public static final int SO_UPCALLCLOSEWAIT =      0x1027;  /* APPLE: block on close until an upcall returns */
// #endif
public static final int SO_LINGER_SEC =   0x1080;          /* linger on close if data present (in seconds) */
public static final int SO_RANDOMPORT =   0x1082;  /* APPLE: request local port randomization */
public static final int SO_NP_EXTENSIONS =        0x1083;  /* To turn off some POSIX behavior */
// #endif

public static final int SO_NUMRCVPKT =            0x1112;  /* number of datagrams in receive socket buffer */
public static final int SO_NET_SERVICE_TYPE =     0x1116;  /* Network service type */


public static final int SO_NETSVC_MARKING_LEVEL =    0x1119;  /* Get QoS marking in effect for socket */


/* When adding new socket-options, you need to make sure MPTCP supports these as well! */

/*
 * Network Service Type for option SO_NET_SERVICE_TYPE
 *
 * The vast majority of sockets should use Best Effort that is the default
 * Network Service Type. Other Network Service Types have to be used only if
 * the traffic actually matches the description of the Network Service Type.
 *
 * Network Service Types do not represent priorities but rather describe
 * different categories of delay, jitter and loss parameters.
 * Those parameters may influence protocols from layer 4 protocols like TCP
 * to layer 2 protocols like Wi-Fi. The Network Service Type can determine
 * how the traffic is queued and scheduled by the host networking stack and
 * by other entities on the network like switches and routers. For example
 * for Wi-Fi, the Network Service Type can select the marking of the
 * layer 2 packet with the appropriate WMM Access Category.
 *
 * There is no point in attempting to game the system and use
 * a Network Service Type that does not correspond to the actual
 * traffic characteristic but one that seems to have a higher precedence.
 * The reason is that for service classes that have lower tolerance
 * for delay and jitter, the queues size is lower than for service
 * classes that are more tolerant to delay and jitter.
 *
 * For example using a voice service type for bulk data transfer will lead
 * to disastrous results as soon as congestion happens because the voice
 * queue overflows and packets get dropped. This is not only bad for the bulk
 * data transfer but it is also bad for VoIP apps that legitimately are using
 * the voice  service type.
 *
 * The characteristics of the Network Service Types are based on the service
 * classes defined in RFC 4594 "Configuration Guidelines for DiffServ Service
 * Classes"
 *
 * When system detects the outgoing interface belongs to a DiffServ domain
 * that follows the recommendation of the IETF draft "Guidelines for DiffServ to
 * IEEE 802.11 Mapping", the packet will marked at layer 3 with a DSCP value
 * that corresponds to Network Service Type.
 *
 * NET_SERVICE_TYPE_BE
 *	"Best Effort", unclassified/standard.  This is the default service
 *	class and cover the majority of the traffic.
 *
 * NET_SERVICE_TYPE_BK
 *	"Background", high delay tolerant, loss tolerant. elastic flow,
 *	variable size & long-lived. E.g: non-interactive network bulk transfer
 *	like synching or backup.
 *
 * NET_SERVICE_TYPE_RD
 *	"Responsive Data", a notch higher than "Best Effort", medium delay
 *	tolerant, elastic & inelastic flow, bursty, long-lived. E.g. email,
 *	instant messaging, for which there is a sense of interactivity and
 *	urgency (user waiting for output).
 *
 * NET_SERVICE_TYPE_OAM
 *	"Operations, Administration, and Management", medium delay tolerant,
 *	low-medium loss tolerant, elastic & inelastic flows, variable size.
 *	E.g. VPN tunnels.
 *
 * NET_SERVICE_TYPE_AV
 *	"Multimedia Audio/Video Streaming", medium delay tolerant, low-medium
 *	loss tolerant, elastic flow, constant packet interval, variable rate
 *	and size. E.g. video and audio playback with buffering.
 *
 * NET_SERVICE_TYPE_RV
 *	"Responsive Multimedia Audio/Video", low delay tolerant, low-medium
 *	loss tolerant, elastic flow, variable packet interval, rate and size.
 *	E.g. screen sharing.
 *
 * NET_SERVICE_TYPE_VI
 *	"Interactive Video", low delay tolerant, low-medium loss tolerant,
 *	elastic flow, constant packet interval, variable rate & size. E.g.
 *	video telephony.
 *
 * NET_SERVICE_TYPE_SIG
 *	"Signaling", low delay tolerant, low loss tolerant, inelastic flow,
 *	jitter tolerant, rate is bursty but short, variable size. E.g. SIP.
 *
 * NET_SERVICE_TYPE_VO
 *	"Interactive Voice", very low delay tolerant, very low loss tolerant,
 *	inelastic flow, constant packet rate, somewhat fixed size.
 *	E.g. VoIP.
 */

public static final int NET_SERVICE_TYPE_BE =     0; /* Best effort */
public static final int NET_SERVICE_TYPE_BK =     1; /* Background system initiated */
public static final int NET_SERVICE_TYPE_SIG =    2; /* Signaling */
public static final int NET_SERVICE_TYPE_VI =     3; /* Interactive Video */
public static final int NET_SERVICE_TYPE_VO =     4; /* Interactive Voice */
public static final int NET_SERVICE_TYPE_RV =     5; /* Responsive Multimedia Audio/Video */
public static final int NET_SERVICE_TYPE_AV =     6; /* Multimedia Audio/Video Streaming */
public static final int NET_SERVICE_TYPE_OAM =    7; /* Operations, Administration, and Management */
public static final int NET_SERVICE_TYPE_RD =     8; /* Responsive Data */


/* These are supported values for SO_NETSVC_MARKING_LEVEL */
public static final int NETSVC_MRKNG_UNKNOWN =            0;       /* The outgoing network interface is not known */
public static final int NETSVC_MRKNG_LVL_L2 =             1;       /* Default marking at layer 2 (for example Wi-Fi WMM) */
public static final int NETSVC_MRKNG_LVL_L3L2_ALL =       2;       /* Layer 3 DSCP marking and layer 2 marking for all Network Service Types */
public static final int NETSVC_MRKNG_LVL_L3L2_BK =        3;       /* The system policy limits layer 3 DSCP marking and layer 2 marking
	                                         * to background Network Service Types */
public static final int SAE_ASSOCID_ANY = 0;
// #define SAE_ASSOCID_ALL ((sae_associd_t)(-1L))
public static final int SAE_CONNID_ANY =  0;
// #define SAE_CONNID_ALL  ((sae_connid_t)(-1L))

/* connectx() flag parameters */
public static final int CONNECT_RESUME_ON_READ_WRITE =    0x1; /* resume connect() on read/write */
public static final int CONNECT_DATA_IDEMPOTENT =         0x2; /* data is idempotent */
public static final int CONNECT_DATA_AUTHENTICATED =      0x4;
// Targeting ../sa_endpoints_t.java


// Targeting ../linger.java


// Targeting ../so_np_extensions.java



public static final int SONPX_SETOPTSHUT =        0x000000001;     /* flag for allowing setsockopt after shutdown */



// #endif
// #endif

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
public static final int SOL_SOCKET =      0xffff;          /* options for socket level */


/*
 * Address families.
 */
public static final int AF_UNSPEC =       0;               /* unspecified */
public static final int AF_UNIX =         1;               /* local to host (pipes) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_LOCAL =        AF_UNIX;         /* backward compatibility */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET =         2;               /* internetwork: UDP, TCP, etc. */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_IMPLINK =      3;               /* arpanet imp addresses */
public static final int AF_PUP =          4;               /* pup protocols: e.g. BSP */
public static final int AF_CHAOS =        5;               /* mit CHAOS protocols */
public static final int AF_NS =           6;               /* XEROX NS protocols */
public static final int AF_ISO =          7;               /* ISO protocols */
public static final int AF_OSI =          AF_ISO;
public static final int AF_ECMA =         8;               /* European computer manufacturers */
public static final int AF_DATAKIT =      9;               /* datakit protocols */
public static final int AF_CCITT =        10;              /* CCITT protocols, X.25 etc */
public static final int AF_SNA =          11;              /* IBM SNA */
public static final int AF_DECnet =       12;              /* DECnet */
public static final int AF_DLI =          13;              /* DEC Direct data link interface */
public static final int AF_LAT =          14;              /* LAT */
public static final int AF_HYLINK =       15;              /* NSC Hyperchannel */
public static final int AF_APPLETALK =    16;              /* Apple Talk */
public static final int AF_ROUTE =        17;              /* Internal Routing Protocol */
public static final int AF_LINK =         18;              /* Link layer interface */
public static final int pseudo_AF_XTP =   19;              /* eXpress Transfer Protocol (no AF) */
public static final int AF_COIP =         20;              /* connection-oriented IP, aka ST II */
public static final int AF_CNT =          21;              /* Computer Network Technology */
public static final int pseudo_AF_RTIP =  22;              /* Help Identify RTIP packets */
public static final int AF_IPX =          23;              /* Novell Internet Protocol */
public static final int AF_SIP =          24;              /* Simple Internet Protocol */
public static final int pseudo_AF_PIP =   25;              /* Help Identify PIP packets */
public static final int AF_NDRV =         27;              /* Network Driver 'raw' access */
public static final int AF_ISDN =         28;              /* Integrated Services Digital Network */
public static final int AF_E164 =         AF_ISDN;         /* CCITT E.164 recommendation */
public static final int pseudo_AF_KEY =   29;              /* Internal key-management function */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET6 =        30;              /* IPv6 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_NATM =         31;              /* native ATM access */
public static final int AF_SYSTEM =       32;              /* Kernel event messages */
public static final int AF_NETBIOS =      33;              /* NetBIOS */
public static final int AF_PPP =          34;              /* PPP communication protocol */
public static final int pseudo_AF_HDRCMPLT = 35;           /* Used by BPF to not rewrite headers
	                                 *  in interface output routine */
public static final int AF_RESERVED_36 =  36;              /* Reserved for internal usage */
public static final int AF_IEEE80211 =    37;              /* IEEE 802.11 protocol */
public static final int AF_UTUN =         38;
public static final int AF_VSOCK =        40;              /* VM Sockets */
public static final int AF_MAX =          41;
// Targeting ../sockaddr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_MAXADDRLEN = 255;
// Targeting ../sockproto.java


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
public static final int _SS_MAXSIZE =     128;
public static native @MemberGetter int _SS_ALIGNSIZE();
public static final int _SS_ALIGNSIZE = _SS_ALIGNSIZE();
public static native @MemberGetter int _SS_PAD1SIZE();
public static final int _SS_PAD1SIZE = _SS_PAD1SIZE();
public static native @MemberGetter int _SS_PAD2SIZE();
public static final int _SS_PAD2SIZE = _SS_PAD2SIZE();
// Targeting ../sockaddr_storage.java



/*
 * Protocol families, same as address families for now.
 */
public static final int PF_UNSPEC =       AF_UNSPEC;
public static final int PF_LOCAL =        AF_LOCAL;
public static final int PF_UNIX =         PF_LOCAL;        /* backward compatibility */
public static final int PF_INET =         AF_INET;
public static final int PF_IMPLINK =      AF_IMPLINK;
public static final int PF_PUP =          AF_PUP;
public static final int PF_CHAOS =        AF_CHAOS;
public static final int PF_NS =           AF_NS;
public static final int PF_ISO =          AF_ISO;
public static final int PF_OSI =          AF_ISO;
public static final int PF_ECMA =         AF_ECMA;
public static final int PF_DATAKIT =      AF_DATAKIT;
public static final int PF_CCITT =        AF_CCITT;
public static final int PF_SNA =          AF_SNA;
public static final int PF_DECnet =       AF_DECnet;
public static final int PF_DLI =          AF_DLI;
public static final int PF_LAT =          AF_LAT;
public static final int PF_HYLINK =       AF_HYLINK;
public static final int PF_APPLETALK =    AF_APPLETALK;
public static final int PF_ROUTE =        AF_ROUTE;
public static final int PF_LINK =         AF_LINK;
public static final int PF_XTP =          pseudo_AF_XTP;   /* really just proto family, no AF */
public static final int PF_COIP =         AF_COIP;
public static final int PF_CNT =          AF_CNT;
public static final int PF_SIP =          AF_SIP;
public static final int PF_IPX =          AF_IPX;          /* same format as AF_NS */
public static final int PF_RTIP =         pseudo_AF_RTIP;  /* same format as AF_INET */
public static final int PF_PIP =          pseudo_AF_PIP;
public static final int PF_NDRV =         AF_NDRV;
public static final int PF_ISDN =         AF_ISDN;
public static final int PF_KEY =          pseudo_AF_KEY;
public static final int PF_INET6 =        AF_INET6;
public static final int PF_NATM =         AF_NATM;
public static final int PF_SYSTEM =       AF_SYSTEM;
public static final int PF_NETBIOS =      AF_NETBIOS;
public static final int PF_PPP =          AF_PPP;
public static final int PF_RESERVED_36 =  AF_RESERVED_36;
public static final int PF_UTUN =         AF_UTUN;
public static final int PF_VSOCK =        AF_VSOCK;
public static final int PF_MAX =          AF_MAX;

/*
 * These do not have socket-layer support:
 */
public static final int PF_VLAN =         ((int)0x766c616e);  /* 'vlan' */
public static final int PF_BOND =         ((int)0x626f6e64);  /* 'bond' */

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int NET_MAXID =       AF_MAX;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 */
public static final int NET_RT_DUMP =             1;       /* dump; may limit to a.f. */
public static final int NET_RT_FLAGS =            2;       /* by flags, e.g. RESOLVING */
public static final int NET_RT_IFLIST =           3;       /* survey interface list */
public static final int NET_RT_STAT =             4;       /* routing statistics */
public static final int NET_RT_TRASH =            5;       /* routes not in table but not freed */
public static final int NET_RT_IFLIST2 =          6;       /* interface list with addresses */
public static final int NET_RT_DUMP2 =            7;       /* dump; may limit to a.f. */
/*
 * Allows read access non-local host's MAC address
 * if the process has neighbor cache entitlement.
 */
public static final int NET_RT_FLAGS_PRIV =       10;
public static final int NET_RT_MAXID =            11;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */




/*
 * Maximum queue length specifiable by listen.
 */
public static final int SOMAXCONN =       128;
// Targeting ../msghdr.java





public static final int MSG_OOB =         0x1;             /* process out-of-band data */
public static final int MSG_PEEK =        0x2;             /* peek at incoming message */
public static final int MSG_DONTROUTE =   0x4;             /* send without using routing tables */
public static final int MSG_EOR =         0x8;             /* data completes record */
public static final int MSG_TRUNC =       0x10;            /* data discarded before delivery */
public static final int MSG_CTRUNC =      0x20;            /* control data lost before delivery */
public static final int MSG_WAITALL =     0x40;            /* wait for full request or error */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int MSG_DONTWAIT =    0x80;            /* this message should be nonblocking */
public static final int MSG_EOF =         0x100;           /* data completes connection */
// #ifdef __APPLE__
// #ifdef __APPLE_API_OBSOLETE
public static final int MSG_WAITSTREAM =  0x200;           /* wait up to full request.. may return partial */
// #endif
public static final int MSG_FLUSH =       0x400;           /* Start of 'hold' seq; dump so_temp, deprecated */
public static final int MSG_HOLD =        0x800;           /* Hold frag in so_temp, deprecated */
public static final int MSG_SEND =        0x1000;          /* Send the packet in so_temp, deprecated */
public static final int MSG_HAVEMORE =    0x2000;          /* Data ready to be read */
public static final int MSG_RCVMORE =     0x4000;          /* Data remains in current pkt */
// #endif
public static final int MSG_NEEDSA =      0x10000;         /* Fail receive if socket address cannot be allocated */
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #if __DARWIN_C_LEVEL >= 200809L
public static final int MSG_NOSIGNAL =    0x80000;
// Targeting ../cmsghdr.java



// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #ifndef __APPLE__
// #endif
// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* given pointer to struct cmsghdr, return pointer to data */
// #define CMSG_DATA(cmsg)         ((unsigned char *)(cmsg) +
// 	__DARWIN_ALIGN32(sizeof(struct cmsghdr)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
// #define CMSG_FIRSTHDR(mhdr)
// 	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ?
// 	    (struct cmsghdr *)(mhdr)->msg_control :
// 	    (struct cmsghdr *)0L)


/*
 * Given pointer to struct cmsghdr, return pointer to next cmsghdr
 * RFC 2292 says that CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr)
 */
// #define CMSG_NXTHDR(mhdr, cmsg)
// 	((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) :
// 	    ((((unsigned char *)(cmsg) +
// 	    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) +
// 	    __DARWIN_ALIGN32(sizeof(struct cmsghdr))) >
// 	    ((unsigned char *)(mhdr)->msg_control +
// 	    (mhdr)->msg_controllen)) ?
// 	        (struct cmsghdr *)0L /* NULL */ :
// 	        (struct cmsghdr *)(void *)((unsigned char *)(cmsg) +
// 	            __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/* RFC 2292 additions */
// #define CMSG_SPACE(l)           (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(l))
// #define CMSG_LEN(l)             (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (l))

// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* "Socket"-level control message types: */
public static final int SCM_RIGHTS =                      0x01;    /* access rights (array of int) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SCM_TIMESTAMP =                   0x02;    /* timestamp (struct timeval) */
public static final int SCM_CREDS =                       0x03;    /* process creds (struct cmsgcred) */
public static final int SCM_TIMESTAMP_MONOTONIC =         0x04;    /* timestamp (uint64_t) */


// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * howto arguments for shutdown(2), specified by Posix.1g.
 */
public static final int SHUT_RD =         0;               /* shut down the reading side */
public static final int SHUT_WR =         1;               /* shut down the writing side */
public static final int SHUT_RDWR =       2;
// Targeting ../sf_hdtr.java




// #endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */




// #endif /* !_SYS_SOCKET_H_ */


// Parsed from sys/syslog.h

/*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*-
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)syslog.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: src/sys/sys/syslog.h,v 1.27.2.1.4.1 2010/06/14 02:09:06 kensmith Exp $
 */

// #ifndef _SYS_SYSLOG_H_
// #define _SYS_SYSLOG_H_

// #include <sys/appleapiopts.h>
// #include <sys/cdefs.h>

public static final String _PATH_LOG =       "/var/run/syslog";

/*
 * priorities/facilities are encoded into a single 32-bit quantity, where the
 * bottom 3 bits are the priority (0-7) and the top 28 bits are the facility
 * (0-big number).  Both the priorities and the facilities map roughly
 * one-to-one to strings in the syslogd(8) source code.  This mapping is
 * included in this file.
 *
 * priorities (these are ordered)
 */
public static final int LOG_EMERG =       0;       /* system is unusable */
public static final int LOG_ALERT =       1;       /* action must be taken immediately */
public static final int LOG_CRIT =        2;       /* critical conditions */
public static final int LOG_ERR =         3;       /* error conditions */
public static final int LOG_WARNING =     4;       /* warning conditions */
public static final int LOG_NOTICE =      5;       /* normal but significant condition */
public static final int LOG_INFO =        6;       /* informational */
public static final int LOG_DEBUG =       7;       /* debug-level messages */

public static final int LOG_PRIMASK =     0x07;    /* mask to extract priority part (internal) */
/* extract priority */
// #define LOG_PRI(p)      ((p) & LOG_PRIMASK)
// #define LOG_MAKEPRI(fac, pri)   ((fac) | (pri))

// #ifdef SYSLOG_NAMES
// #endif

/* facility codes */
public static final int LOG_KERN =        (0<<3);  /* kernel messages */
public static final int LOG_USER =        (1<<3);  /* random user-level messages */
public static final int LOG_MAIL =        (2<<3);  /* mail system */
public static final int LOG_DAEMON =      (3<<3);  /* system daemons */
public static final int LOG_AUTH =        (4<<3);  /* authorization messages */
public static final int LOG_SYSLOG =      (5<<3);  /* messages generated internally by syslogd */
public static final int LOG_LPR =         (6<<3);  /* line printer subsystem */
public static final int LOG_NEWS =        (7<<3);  /* network news subsystem */
public static final int LOG_UUCP =        (8<<3);  /* UUCP subsystem */
public static final int LOG_CRON =        (9<<3);  /* clock daemon */
public static final int LOG_AUTHPRIV =    (10<<3); /* authorization messages (private) */
/* Facility #10 clashes in DEC UNIX, where */
/* it's defined as LOG_MEGASAFE for AdvFS  */
/* event logging.                          */
public static final int LOG_FTP =         (11<<3); /* ftp daemon */
//#define	LOG_NTP		(12<<3)	/* NTP subsystem */
//#define	LOG_SECURITY	(13<<3) /* security subsystems (firewalling, etc.) */
//#define	LOG_CONSOLE	(14<<3) /* /dev/console output */
public static final int LOG_NETINFO =     (12<<3); /* NetInfo */
public static final int LOG_REMOTEAUTH =  (13<<3); /* remote authentication/authorization */
public static final int LOG_INSTALL =     (14<<3); /* installer subsystem */
public static final int LOG_RAS =         (15<<3); /* Remote Access Service (VPN / PPP) */

/* other codes through 15 reserved for system use */
public static final int LOG_LOCAL0 =      (16<<3); /* reserved for local use */
public static final int LOG_LOCAL1 =      (17<<3); /* reserved for local use */
public static final int LOG_LOCAL2 =      (18<<3); /* reserved for local use */
public static final int LOG_LOCAL3 =      (19<<3); /* reserved for local use */
public static final int LOG_LOCAL4 =      (20<<3); /* reserved for local use */
public static final int LOG_LOCAL5 =      (21<<3); /* reserved for local use */
public static final int LOG_LOCAL6 =      (22<<3); /* reserved for local use */
public static final int LOG_LOCAL7 =      (23<<3); /* reserved for local use */

public static final int LOG_LAUNCHD =     (24<<3); /* launchd - general bootstrap daemon */

public static final int LOG_NFACILITIES = 25;      /* current number of facilities */
public static final int LOG_FACMASK =     0x03f8;  /* mask to extract facility part */
/* facility of pri */
// #define LOG_FAC(p)      (((p) & LOG_FACMASK) >> 3)

// #ifdef SYSLOG_NAMES
// #endif


/*
 * arguments to setlogmask.
 */
// #define LOG_MASK(pri)   (1 << (pri))            /* mask for one priority */
// #define LOG_UPTO(pri)   ((1 << ((pri)+1)) - 1)  /* all priorities through pri */

/*
 * Option flags for openlog.
 *
 * LOG_ODELAY no longer does anything.
 * LOG_NDELAY is the inverse of what it used to be.
 */
public static final int LOG_PID =         0x01;    /* log the pid with each message */
public static final int LOG_CONS =        0x02;    /* log on the console if errors in sending */
public static final int LOG_ODELAY =      0x04;    /* delay open until first syslog() (default) */
public static final int LOG_NDELAY =      0x08;    /* don't delay open */
public static final int LOG_NOWAIT =      0x10;    /* don't wait for console forks: DEPRECATED */
public static final int LOG_PERROR =      0x20;    /* log to stderr as well */


/*
 * Don't use va_list in the vsyslog() prototype.   Va_list is typedef'd in two
 * places (<machine/varargs.h> and <machine/stdarg.h>), so if we include one
 * of them here we may collide with the utility's includes.  It's unreasonable
 * for utilities to have to include one of them to include syslog.h, so we get
 * __va_list from <sys/_types.h> and use it.
 */
// #include <sys/_types.h>

public static native void closelog();
public static native void openlog(@Cast("const char*") BytePointer arg0, int arg1, int arg2);
public static native void openlog(String arg0, int arg1, int arg2);
public static native int setlogmask(int arg0);
// #if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static native void syslog(int arg0, @Cast("const char*") BytePointer arg1);
public static native void syslog(int arg0, String arg1);
// #else
// #endif
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
// #endif
// #endif /* !_SYS_SYSLOG_H_ */


// Parsed from srt/logging_api.h

/*
 * SRT - Secure, Reliable, Transport
 * Copyright (c) 2018 Haivision Systems Inc.
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 */

/*****************************************************************************
written by
   Haivision Systems Inc.
 *****************************************************************************/

// #ifndef INC_SRT_LOGGING_API_H
// #define INC_SRT_LOGGING_API_H

// These are required for access functions:
// - adding FA (requires set)
// - setting a log stream (requires iostream)
// #ifdef __cplusplus
// #include <set>
// #include <iostream>
// #endif

// #ifdef _WIN32
// #else
// #include <syslog.h>
// #endif

// Syslog is included so that it provides log level names.
// Haivision log standard requires the same names plus extra one:
// #ifndef LOG_DEBUG_TRACE
public static final int LOG_DEBUG_TRACE = 8;
// #endif
// It's unused anyway, just for the record.
public static final int SRT_LOG_LEVEL_MIN = LOG_CRIT;
public static final int SRT_LOG_LEVEL_MAX = LOG_DEBUG;

// Flags
public static final int SRT_LOGF_DISABLE_TIME = 1;
public static final int SRT_LOGF_DISABLE_THREADNAME = 2;
public static final int SRT_LOGF_DISABLE_SEVERITY = 4;
public static final int SRT_LOGF_DISABLE_EOL = 8;
// Targeting ../SRT_LOG_HANDLER_FN.java


// Targeting ../LogFA.java



@Namespace("srt_logging") @MemberGetter public static native @Const @ByRef LogFA LOGFA_GENERAL();
    // There are 3 general levels:

    // A. fatal - this means the application WILL crash.
    // B. unexpected:
    //    - error: this was unexpected for the library
    //    - warning: this was expected by the library, but may be harmful for the application
    // C. expected:
    //    - note: a significant, but rarely occurring event
    //    - debug: may occur even very often and enabling it can harm performance

    /** enum srt_logging::LogLevel::type */
    public static final int
        fatal = LOG_CRIT,
        // Fatal vs. Error: with Error, you can still continue.
        error = LOG_ERR,
        // Error vs. Warning: Warning isn't considered a problem for the library.
        warning = LOG_WARNING,
        // Warning vs. Note: Note means something unusual, but completely correct behavior.
        note = LOG_NOTICE,
        // Note vs. Debug: Debug may occur even multiple times in a millisecond.
        // (Well, worth noting that Error and Warning potentially also can).
        debug = LOG_DEBUG;

// Targeting ../Logger.java




// #endif

// #endif


// Parsed from srt/srt.h

/*
 * SRT - Secure, Reliable, Transport
 * Copyright (c) 2018 Haivision Systems Inc.
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 */

/*****************************************************************************
written by
   Haivision Systems Inc.
 *****************************************************************************/

// #ifndef INC_SRTC_H
// #define INC_SRTC_H

// #include "version.h"

// #include "platform_sys.h"

// #include <string.h>
// #include <stdlib.h>

// #include "logging_api.h"

////////////////////////////////////////////////////////////////////////////////

//if compiling on VC6.0 or pre-WindowsXP systems
//use -DLEGACY_WIN32

//if compiling with MinGW, it only works on XP or above
//use -D_WIN32_WINNT=0x0501


// #ifdef _WIN32
// #else
//    #define SRT_API __attribute__ ((visibility("default")))
// #endif


// For feature tests if you need.
// You can use these constants with SRTO_MINVERSION option.
public static final int SRT_VERSION_FEAT_HSv5 = 0x010300;

// #if defined(__cplusplus) && __cplusplus > 201406
public static final int SRT_HAVE_CXX17 = 1;
// #else
// #endif


// Stadnard attributes

// When compiling in C++17 mode, use the standard C++17 attributes
// (out of these, only [[deprecated]] is supported in C++14, so
// for all lesser standard use compiler-specific attributes).
// #if SRT_HAVE_CXX17

// Unused: DO NOT issue a warning if this entity is unused.
// #define SRT_ATR_UNUSED [[maybe_unused]]

// Nodiscard: issue a warning if the return value was discarded.
// #define SRT_ATR_NODISCARD [[nodiscard]]

// GNUG is GNU C/C++; this syntax is also supported by Clang
// #elif defined(__GNUC__)
// #elif defined(_MSC_VER)
// #define SRT_ATR_UNUSED __pragma(warning(suppress: 4100 4101))
// #define SRT_ATR_NODISCARD _Check_return_
// #else
// #define SRT_ATR_UNUSED
// #define SRT_ATR_NODISCARD
// #endif


// DEPRECATED attributes

// There's needed DEPRECATED and DEPRECATED_PX, as some compilers require them
// before the entity, others after the entity.
// The *_PX version is the prefix attribute, which applies only
// to functions (Microsoft compilers).

// When deprecating a function, mark it:
//
// SRT_ATR_DEPRECATED_PX retval function(arguments) SRT_ATR_DEPRECATED;
//

// When SRT_NO_DEPRECATED defined, do not issue any deprecation warnings.
// Regardless of the compiler type.
// #if defined(SRT_NO_DEPRECATED)

// #define SRT_ATR_DEPRECATED
// #define SRT_ATR_DEPRECATED_PX

// #elif SRT_HAVE_CXX17

// #define SRT_ATR_DEPRECATED
// #define SRT_ATR_DEPRECATED_PX [[deprecated]]

// GNUG is GNU C/C++; this syntax is also supported by Clang
// #elif defined(__GNUC__)
// #elif defined(_MSC_VER)
// #define SRT_ATR_DEPRECATED_PX __declspec(deprecated)
// #define SRT_ATR_DEPRECATED // no postfix-type modifier
// #else
// #define SRT_ATR_DEPRECATED_PX
// #define SRT_ATR_DEPRECATED
// #endif

// #ifdef __cplusplus
// #endif

// The most significant bit 31 (sign bit actually) is left unused,
// so that all people who check the value for < 0 instead of -1
// still get what they want. The bit 30 is reserved for marking
// the "socket group". Most of the API functions should work
// transparently with the socket descriptor designating a single
// socket or a socket group.
@MemberGetter public static native int SRTGROUP_MASK();
public static final int SRTGROUP_MASK = SRTGROUP_MASK();

// #ifdef _WIN32
// #else
// #endif

// #ifndef ENABLE_EXPERIMENTAL_BONDING
public static native @MemberGetter int ENABLE_EXPERIMENTAL_BONDING();
public static final int ENABLE_EXPERIMENTAL_BONDING = ENABLE_EXPERIMENTAL_BONDING();
// #endif


// Values returned by srt_getsockstate()
/** enum SRT_SOCKSTATUS */
public static final int
   SRTS_INIT = 1,
   SRTS_OPENED = 2,
   SRTS_LISTENING = 3,
   SRTS_CONNECTING = 4,
   SRTS_CONNECTED = 5,
   SRTS_BROKEN = 6,
   SRTS_CLOSING = 7,
   SRTS_CLOSED = 8,
   SRTS_NONEXIST = 9;

// This is a duplicate enum. Must be kept in sync with the original UDT enum for
// backward compatibility until all compat is destroyed.
/** enum SRT_SOCKOPT */
public static final int

   SRTO_MSS = 0,             // the Maximum Transfer Unit
   SRTO_SNDSYN = 1,          // if sending is blocking
   SRTO_RCVSYN = 2,          // if receiving is blocking
   SRTO_ISN = 3,             // Initial Sequence Number (valid only after srt_connect or srt_accept-ed sockets)
   SRTO_FC = 4,              // Flight flag size (window size)
   SRTO_SNDBUF = 5,          // maximum buffer in sending queue
   SRTO_RCVBUF = 6,          // UDT receiving buffer size
   SRTO_LINGER = 7,          // waiting for unsent data when closing
   SRTO_UDP_SNDBUF = 8,      // UDP sending buffer size
   SRTO_UDP_RCVBUF = 9,      // UDP receiving buffer size
   // (some space left)
   SRTO_RENDEZVOUS = 12,     // rendezvous connection mode
   SRTO_SNDTIMEO = 13,       // send() timeout
   SRTO_RCVTIMEO = 14,       // recv() timeout
   SRTO_REUSEADDR = 15,      // reuse an existing port or create a new one
   SRTO_MAXBW = 16,          // maximum bandwidth (bytes per second) that the connection can use
   SRTO_STATE = 17,          // current socket state, see UDTSTATUS, read only
   SRTO_EVENT = 18,          // current available events associated with the socket
   SRTO_SNDDATA = 19,        // size of data in the sending buffer
   SRTO_RCVDATA = 20,        // size of data available for recv
   SRTO_SENDER = 21,         // Sender mode (independent of conn mode), for encryption, tsbpd handshake.
   SRTO_TSBPDMODE = 22,      // Enable/Disable TsbPd. Enable -> Tx set origin timestamp, Rx deliver packet at origin time + delay
   SRTO_LATENCY = 23,        // NOT RECOMMENDED. SET: to both SRTO_RCVLATENCY and SRTO_PEERLATENCY. GET: same as SRTO_RCVLATENCY.
   SRTO_INPUTBW = 24,        // Estimated input stream rate.
   SRTO_OHEADBW = 25,             // MaxBW ceiling based on % over input stream rate. Applies when UDT_MAXBW=0 (auto).
   SRTO_PASSPHRASE = 26,     // Crypto PBKDF2 Passphrase (must be 10..79 characters, or empty to disable encryption)
   SRTO_PBKEYLEN = 27,            // Crypto key len in bytes {16,24,32} Default: 16 (AES-128)
   SRTO_KMSTATE = 28,             // Key Material exchange status (UDT_SRTKmState)
   SRTO_IPTTL = 29,          // IP Time To Live (passthru for system sockopt IPPROTO_IP/IP_TTL)
   SRTO_IPTOS = 30,               // IP Type of Service (passthru for system sockopt IPPROTO_IP/IP_TOS)
   SRTO_TLPKTDROP = 31,      // Enable receiver pkt drop
   SRTO_SNDDROPDELAY = 32,   // Extra delay towards latency for sender TLPKTDROP decision (-1 to off)
   SRTO_NAKREPORT = 33,      // Enable receiver to send periodic NAK reports
   SRTO_VERSION = 34,        // Local SRT Version
   SRTO_PEERVERSION = 35,         // Peer SRT Version (from SRT Handshake)
   SRTO_CONNTIMEO = 36,      // Connect timeout in msec. Caller default: 3000, rendezvous (x 10)
   SRTO_DRIFTTRACER = 37,    // Enable or disable drift tracer
   SRTO_MININPUTBW = 38,     // Minimum estimate of input stream rate.
   // (some space left)
   SRTO_SNDKMSTATE = 40,     // (GET) the current state of the encryption at the peer side
   SRTO_RCVKMSTATE = 41,          // (GET) the current state of the encryption at the agent side
   SRTO_LOSSMAXTTL = 42,          // Maximum possible packet reorder tolerance (number of packets to receive after loss to send lossreport)
   SRTO_RCVLATENCY = 43,          // TsbPd receiver delay (mSec) to absorb burst of missed packet retransmission
   SRTO_PEERLATENCY = 44,         // Minimum value of the TsbPd receiver delay (mSec) for the opposite side (peer)
   SRTO_MINVERSION = 45,          // Minimum SRT version needed for the peer (peers with less version will get connection reject)
   SRTO_STREAMID = 46,            // A string set to a socket and passed to the listener's accepted socket
   SRTO_CONGESTION = 47,          // Congestion controller type selection
   SRTO_MESSAGEAPI = 48,          // In File mode, use message API (portions of data with boundaries)
   SRTO_PAYLOADSIZE = 49,         // Maximum payload size sent in one UDP packet (0 if unlimited)
   SRTO_TRANSTYPE = 50,      // Transmission type (set of options required for given transmission type)
   SRTO_KMREFRESHRATE = 51,       // After sending how many packets the encryption key should be flipped to the new key
   SRTO_KMPREANNOUNCE = 52,       // How many packets before key flip the new key is annnounced and after key flip the old one decommissioned
   SRTO_ENFORCEDENCRYPTION = 53,  // Connection to be rejected or quickly broken when one side encryption set or bad password
   SRTO_IPV6ONLY = 54,            // IPV6_V6ONLY mode
   SRTO_PEERIDLETIMEO = 55,       // Peer-idle timeout (max time of silence heard from peer) in [ms]
   SRTO_BINDTODEVICE = 56,        // Forward the SOL_SOCKET/SO_BINDTODEVICE option on socket (pass packets only from that device)
// #if ENABLE_EXPERIMENTAL_BONDING
// #endif
   SRTO_PACKETFILTER = 60,   // Add and configure a packet filter
   SRTO_RETRANSMITALGO = 61,  // An option to select packet retransmission algorithm

   SRTO_E_SIZE = 62; // Always last element, not a valid option.


// #ifdef __cplusplus


// #if __cplusplus > 199711L // C++11
    // Newer compilers report error when [[deprecated]] is applied to types,
    // and C++11 and higher uses this.
    // Note that this doesn't exactly use the 'deprecated' attribute,
    // as it's introduced in C++14. What is actually used here is the
    // fact that unknown attributes are ignored, but still warned about.
    // This should only catch an eye - and that's what it does.
// #define SRT_DEPRECATED_OPTION(value) ((SRT_SOCKOPT [[deprecated]])value)
// #else
    // Older (pre-C++11) compilers use gcc deprecated applied to a typedef
// #define SRT_DEPRECATED_OPTION(value) ((SRT_SOCKOPT_DEPRECATED)value)
// #endif


// #else

// deprecated enum labels are supported only since gcc 6, so in C there
// will be a whole deprecated enum type, as it's not an error in C to mix
// enum types
/** enum SRT_SOCKOPT_DEPRECATED */
public static final int

    // Dummy last option, as every entry ends with a comma
    SRTO_DEPRECATED_END = 0;
// #define SRT_DEPRECATED_OPTION(value) ((enum SRT_SOCKOPT_DEPRECATED)value)
// #endif

// Note that there are no deprecated options at the moment, but the mechanism
// stays so that it can be used in future. Example:
// #define SRTO_STRICTENC SRT_DEPRECATED_OPTION(53)

/** enum SRT_TRANSTYPE */
public static final int
    SRTT_LIVE = 0,
    SRTT_FILE = 1,
    SRTT_INVALID = 2;

// These sizes should be used for Live mode. In Live mode you should not
// exceed the size that fits in a single MTU.

// This is for MPEG TS and it's a default SRTO_PAYLOADSIZE for SRTT_LIVE.
@MemberGetter public static native int SRT_LIVE_DEF_PLSIZE();
public static final int SRT_LIVE_DEF_PLSIZE = SRT_LIVE_DEF_PLSIZE(); // = 188*7, recommended for MPEG TS

// This is the maximum payload size for Live mode, should you have a different
// payload type than MPEG TS.
@MemberGetter public static native int SRT_LIVE_MAX_PLSIZE();
public static final int SRT_LIVE_MAX_PLSIZE = SRT_LIVE_MAX_PLSIZE(); // MTU(1500) - UDP.hdr(28) - SRT.hdr(16)

// Latency for Live transmission: default is 120
@MemberGetter public static native int SRT_LIVE_DEF_LATENCY_MS();
public static final int SRT_LIVE_DEF_LATENCY_MS = SRT_LIVE_DEF_LATENCY_MS();
// Targeting ../CBytePerfMon.java



////////////////////////////////////////////////////////////////////////////////

// Error codes - define outside the CUDTException class
// because otherwise you'd have to use CUDTException::MJ_SUCCESS etc.
// in all throw CUDTException expressions.
/** enum CodeMajor */
public static final int
    MJ_UNKNOWN    = -1,
    MJ_SUCCESS    = 0,
    MJ_SETUP      = 1,
    MJ_CONNECTION = 2,
    MJ_SYSTEMRES  = 3,
    MJ_FILESYSTEM = 4,
    MJ_NOTSUP     = 5,
    MJ_AGAIN      = 6,
    MJ_PEERERROR  = 7;

/** enum CodeMinor */
public static final int
    // These are "minor" error codes from various "major" categories
    // MJ_SETUP
    MN_NONE            = 0,
    MN_TIMEOUT         = 1,
    MN_REJECTED        = 2,
    MN_NORES           = 3,
    MN_SECURITY        = 4,
    MN_CLOSED          = 5,
    // MJ_CONNECTION
    MN_CONNLOST        = 1,
    MN_NOCONN          = 2,
    // MJ_SYSTEMRES
    MN_THREAD          = 1,
    MN_MEMORY          = 2,
    MN_OBJECT          = 3,
    // MJ_FILESYSTEM
    MN_SEEKGFAIL       = 1,
    MN_READFAIL        = 2,
    MN_SEEKPFAIL       = 3,
    MN_WRITEFAIL       = 4,
    // MJ_NOTSUP
    MN_ISBOUND         = 1,
    MN_ISCONNECTED     = 2,
    MN_INVAL           = 3,
    MN_SIDINVAL        = 4,
    MN_ISUNBOUND       = 5,
    MN_NOLISTEN        = 6,
    MN_ISRENDEZVOUS    = 7,
    MN_ISRENDUNBOUND   = 8,
    MN_INVALMSGAPI     = 9,
    MN_INVALBUFFERAPI  = 10,
    MN_BUSY            = 11,
    MN_XSIZE           = 12,
    MN_EIDINVAL        = 13,
    MN_EEMPTY          = 14,
    MN_BUSYPORT        = 15,
    // MJ_AGAIN
    MN_WRAVAIL         = 1,
    MN_RDAVAIL         = 2,
    MN_XMTIMEOUT       = 3,
    MN_CONGESTION      = 4;


// Stupid, but effective. This will be #undefined, so don't worry.
// #define MJ(major) (1000 * MJ_##major)
// #define MN(major, minor) (1000 * MJ_##major + MN_##minor)

// Some better way to define it, and better for C language.
/** enum SRT_ERRNO */
public static final int
    SRT_EUNKNOWN        = -1,
    SRT_SUCCESS         = MJ_SUCCESS,

    SRT_ECONNSETUP      = (1000 * MJ_SETUP),
    SRT_ENOSERVER       = (1000 * MJ_SETUP + MN_TIMEOUT),
    SRT_ECONNREJ        = (1000 * MJ_SETUP + MN_REJECTED),
    SRT_ESOCKFAIL       = (1000 * MJ_SETUP + MN_NORES),
    SRT_ESECFAIL        = (1000 * MJ_SETUP + MN_SECURITY),
    SRT_ESCLOSED        = (1000 * MJ_SETUP + MN_CLOSED),

    SRT_ECONNFAIL       = (1000 * MJ_CONNECTION),
    SRT_ECONNLOST       = (1000 * MJ_CONNECTION + MN_CONNLOST),
    SRT_ENOCONN         = (1000 * MJ_CONNECTION + MN_NOCONN),

    SRT_ERESOURCE       = (1000 * MJ_SYSTEMRES),
    SRT_ETHREAD         = (1000 * MJ_SYSTEMRES + MN_THREAD),
    SRT_ENOBUF          = (1000 * MJ_SYSTEMRES + MN_MEMORY),
    SRT_ESYSOBJ         = (1000 * MJ_SYSTEMRES + MN_OBJECT),

    SRT_EFILE           = (1000 * MJ_FILESYSTEM),
    SRT_EINVRDOFF       = (1000 * MJ_FILESYSTEM + MN_SEEKGFAIL),
    SRT_ERDPERM         = (1000 * MJ_FILESYSTEM + MN_READFAIL),
    SRT_EINVWROFF       = (1000 * MJ_FILESYSTEM + MN_SEEKPFAIL),
    SRT_EWRPERM         = (1000 * MJ_FILESYSTEM + MN_WRITEFAIL),

    SRT_EINVOP          = (1000 * MJ_NOTSUP),
    SRT_EBOUNDSOCK      = (1000 * MJ_NOTSUP + MN_ISBOUND),
    SRT_ECONNSOCK       = (1000 * MJ_NOTSUP + MN_ISCONNECTED),
    SRT_EINVPARAM       = (1000 * MJ_NOTSUP + MN_INVAL),
    SRT_EINVSOCK        = (1000 * MJ_NOTSUP + MN_SIDINVAL),
    SRT_EUNBOUNDSOCK    = (1000 * MJ_NOTSUP + MN_ISUNBOUND),
    SRT_ENOLISTEN       = (1000 * MJ_NOTSUP + MN_NOLISTEN),
    SRT_ERDVNOSERV      = (1000 * MJ_NOTSUP + MN_ISRENDEZVOUS),
    SRT_ERDVUNBOUND     = (1000 * MJ_NOTSUP + MN_ISRENDUNBOUND),
    SRT_EINVALMSGAPI    = (1000 * MJ_NOTSUP + MN_INVALMSGAPI),
    SRT_EINVALBUFFERAPI = (1000 * MJ_NOTSUP + MN_INVALBUFFERAPI),
    SRT_EDUPLISTEN      = (1000 * MJ_NOTSUP + MN_BUSY),
    SRT_ELARGEMSG       = (1000 * MJ_NOTSUP + MN_XSIZE),
    SRT_EINVPOLLID      = (1000 * MJ_NOTSUP + MN_EIDINVAL),
    SRT_EPOLLEMPTY      = (1000 * MJ_NOTSUP + MN_EEMPTY),
    SRT_EBINDCONFLICT   = (1000 * MJ_NOTSUP + MN_BUSYPORT),

    SRT_EASYNCFAIL      = (1000 * MJ_AGAIN),
    SRT_EASYNCSND       = (1000 * MJ_AGAIN + MN_WRAVAIL),
    SRT_EASYNCRCV       = (1000 * MJ_AGAIN + MN_RDAVAIL),
    SRT_ETIMEOUT        = (1000 * MJ_AGAIN + MN_XMTIMEOUT),
    SRT_ECONGEST        = (1000 * MJ_AGAIN + MN_CONGESTION),

    SRT_EPEERERR        = (1000 * MJ_PEERERROR);


// #undef MJ
// #undef MN

/** enum SRT_REJECT_REASON */
public static final int
    SRT_REJ_UNKNOWN = 0,     // initial set when in progress
    SRT_REJ_SYSTEM = 1,      // broken due to system function error
    SRT_REJ_PEER = 2,        // connection was rejected by peer
    SRT_REJ_RESOURCE = 3,    // internal problem with resource allocation
    SRT_REJ_ROGUE = 4,       // incorrect data in handshake messages
    SRT_REJ_BACKLOG = 5,     // listener's backlog exceeded
    SRT_REJ_IPE = 6,         // internal program error
    SRT_REJ_CLOSE = 7,       // socket is closing
    SRT_REJ_VERSION = 8,     // peer is older version than agent's minimum set
    SRT_REJ_RDVCOOKIE = 9,   // rendezvous cookie collision
    SRT_REJ_BADSECRET = 10,   // wrong password
    SRT_REJ_UNSECURE = 11,    // password required or unexpected
    SRT_REJ_MESSAGEAPI = 12,  // streamapi/messageapi collision
    SRT_REJ_CONGESTION = 13,  // incompatible congestion-controller type
    SRT_REJ_FILTER = 14,      // incompatible packet filter
    SRT_REJ_GROUP = 15,       // incompatible group
    SRT_REJ_TIMEOUT = 16,     // connection timeout

    SRT_REJ_E_SIZE = 17;

// XXX This value remains for some time, but it's deprecated
// Planned deprecation removal: rel1.6.0.
public static final int SRT_REJ__SIZE = SRT_REJ_E_SIZE;

// Reject category codes:

// #define SRT_REJC_VALUE(code) (1000 * (code/1000))
public static final int SRT_REJC_INTERNAL = 0;     // Codes from above SRT_REJECT_REASON enum
public static final int SRT_REJC_PREDEFINED = 1000;  // Standard server error codes
public static final int SRT_REJC_USERDEFINED = 2000;    // User defined error codes


// Logging API - specialization for SRT.

// WARNING: This part is generated.

// Logger Functional Areas
// Note that 0 is "general".

// Values 0* - general, unqualified
// Values 1* - control
// Values 2* - receiving
// Values 3* - sending
// Values 4* - management

// Made by #define so that it's available also for C API.

// Use ../scripts/generate-logging-defs.tcl to regenerate.

// SRT_LOGFA BEGIN GENERATED SECTION {

public static final int SRT_LOGFA_GENERAL =    0;   // gglog: General uncategorized log, for serious issues only
public static final int SRT_LOGFA_SOCKMGMT =   1;   // smlog: Socket create/open/close/configure activities
public static final int SRT_LOGFA_CONN =       2;   // cnlog: Connection establishment and handshake
public static final int SRT_LOGFA_XTIMER =     3;   // xtlog: The checkTimer and around activities
public static final int SRT_LOGFA_TSBPD =      4;   // tslog: The TsBPD thread
public static final int SRT_LOGFA_RSRC =       5;   // rslog: System resource allocation and management

public static final int SRT_LOGFA_CONGEST =    7;   // cclog: Congestion control module
public static final int SRT_LOGFA_PFILTER =    8;   // pflog: Packet filter module

public static final int SRT_LOGFA_API_CTRL =   11;  // aclog: API part for socket and library managmenet

public static final int SRT_LOGFA_QUE_CTRL =   13;  // qclog: Queue control activities

public static final int SRT_LOGFA_EPOLL_UPD =  16;  // eilog: EPoll, internal update activities

public static final int SRT_LOGFA_API_RECV =   21;  // arlog: API part for receiving
public static final int SRT_LOGFA_BUF_RECV =   22;  // brlog: Buffer, receiving side
public static final int SRT_LOGFA_QUE_RECV =   23;  // qrlog: Queue, receiving side
public static final int SRT_LOGFA_CHN_RECV =   24;  // krlog: CChannel, receiving side
public static final int SRT_LOGFA_GRP_RECV =   25;  // grlog: Group, receiving side

public static final int SRT_LOGFA_API_SEND =   31;  // aslog: API part for sending
public static final int SRT_LOGFA_BUF_SEND =   32;  // bslog: Buffer, sending side
public static final int SRT_LOGFA_QUE_SEND =   33;  // qslog: Queue, sending side
public static final int SRT_LOGFA_CHN_SEND =   34;  // kslog: CChannel, sending side
public static final int SRT_LOGFA_GRP_SEND =   35;  // gslog: Group, sending side

public static final int SRT_LOGFA_INTERNAL =   41;  // inlog: Internal activities not connected directly to a socket

public static final int SRT_LOGFA_QUE_MGMT =   43;  // qmlog: Queue, management part
public static final int SRT_LOGFA_CHN_MGMT =   44;  // kmlog: CChannel, management part
public static final int SRT_LOGFA_GRP_MGMT =   45;  // gmlog: Group, management part
public static final int SRT_LOGFA_EPOLL_API =  46;  // ealog: EPoll, API part

public static final int SRT_LOGFA_HAICRYPT =   6;   // hclog: Haicrypt module area
public static final int SRT_LOGFA_APPLOG =     10;  // aplog: Applications

// } SRT_LOGFA END GENERATED SECTION

// To make a typical int64_t size, although still use std::bitset.
// C API will carry it over.
public static final int SRT_LOGFA_LASTNONE = 63;

/** enum SRT_KM_STATE */
public static final int
    SRT_KM_S_UNSECURED = 0,      //No encryption
    SRT_KM_S_SECURING  = 1,      //Stream encrypted, exchanging Keying Material
    SRT_KM_S_SECURED   = 2,      //Stream encrypted, keying Material exchanged, decrypting ok.
    SRT_KM_S_NOSECRET  = 3,      //Stream encrypted and no secret to decrypt Keying Material
    SRT_KM_S_BADSECRET = 4;       //Stream encrypted and wrong secret, cannot decrypt Keying Material

/** enum SRT_EPOLL_OPT */
public static final int
   
///
///
///
///
   SRT_EPOLL_OPT_NONE = 0x0, // fallback

   // Values intended to be the same as in `<sys/epoll.h>`.
   // so that if system values are used by mistake, they should have the same effect
   // This applies to: IN, OUT, ERR and ET.

   /** Ready for 'recv' operation:
    * 
    *  - For stream mode it means that at least 1 byte is available.
    *  In this mode the buffer may extract only a part of the packet,
    *  leaving next data possible for extraction later.
    * 
    *  - For message mode it means that there is at least one packet
    *  available (this may change in future, as it is desired that
    *  one full message should only wake up, not single packet of a
    *  not yet extractable message).
    * 
    *  - For live mode it means that there's at least one packet
    *  ready to play.
    * 
    *  - For listener sockets, this means that there is a new connection
    *  waiting for pickup through the {@code srt_accept()} call, that is,
    *  the next call to {@code srt_accept()} will succeed without blocking
    *  (see an alias SRT_EPOLL_ACCEPT below). */
   
///
///
///
///
   SRT_EPOLL_IN       = 0x1,

   /** Ready for 'send' operation.
    * 
    *  - For stream mode it means that there's a free space in the
    *  sender buffer for at least 1 byte of data. The next send
    *  operation will only allow to send as much data as it is free
    *  space in the buffer.
    * 
    *  - For message mode it means that there's a free space for at
    *  least one UDP packet. The edge-triggered mode can be used to
    *  pick up updates as the free space in the sender buffer grows.
    * 
    *  - For live mode it means that there's a free space for at least
    *  one UDP packet. On the other hand, no readiness for OUT usually
    *  means an extraordinary congestion on the link, meaning also that
    *  you should immediately slow down the sending rate or you may get
    *  a connection break soon.
    * 
    *  - For non-blocking sockets used with {@code srt_connect*} operation,
    *  this flag simply means that the connection was established. */
   SRT_EPOLL_OUT      = 0x4,

   /** The socket has encountered an error in the last operation
    *  and the next operation on that socket will end up with error.
    *  You can retry the operation, but getting the error from it
    *  is certain, so you may as well close the socket. */
   SRT_EPOLL_ERR      = 0x8,

   // To avoid confusion in the internal code, the following
   // duplicates are introduced to improve clarity.
   SRT_EPOLL_CONNECT = SRT_EPOLL_OUT,
   SRT_EPOLL_ACCEPT = SRT_EPOLL_IN,

   SRT_EPOLL_UPDATE = 0x10,
   SRT_EPOLL_ET       = 1 << 31;
// These are actually flags - use a bit container:

// Define which epoll flags determine events. All others are special flags.
public static final int SRT_EPOLL_EVENTTYPES = (SRT_EPOLL_IN | SRT_EPOLL_OUT | SRT_EPOLL_UPDATE | SRT_EPOLL_ERR);
public static final int SRT_EPOLL_ETONLY = (SRT_EPOLL_UPDATE);

/** enum SRT_EPOLL_FLAGS */
public static final int
    /** This allows the EID container to be empty when calling the waiting
     *  function with infinite time. This means an infinite hangup, although
     *  a socket can be added to this EID from a separate thread. */
    SRT_EPOLL_ENABLE_EMPTY = 1,

    /** This makes the waiting function check if there is output container
     *  passed to it, and report an error if it isn't. By default it is allowed
     *  that the output container is 0 size or NULL and therefore the readiness
     *  state is reported only as a number of ready sockets from return value. */
    SRT_EPOLL_ENABLE_OUTPUTCHECK = 2;

// #ifdef __cplusplus
// In C++ these enums cannot be treated as int and glued by operator |.
// Unless this operator is defined.
public static native @Cast("SRT_EPOLL_OPT") @Name("operator |") int or(@Cast("SRT_EPOLL_OPT") int a1, @Cast("SRT_EPOLL_OPT") int a2);
// Targeting ../SRT_TRACEBSTATS.java



@MemberGetter public static native @Cast("const SRTSOCKET") int SRT_INVALID_SOCK();
public static final int SRT_INVALID_SOCK = SRT_INVALID_SOCK();
@MemberGetter public static native int SRT_ERROR();
public static final int SRT_ERROR = SRT_ERROR();

// library initialization
public static native int srt_startup();
public static native int srt_cleanup();

//
// Socket operations
//
// DEPRECATED: srt_socket with 3 arguments. All these arguments are ignored
// and socket creation doesn't need any arguments. Use srt_create_socket().
// Planned deprecation removal: rel1.6.0
public static native @Cast("SRTSOCKET") int srt_socket(int arg0, int arg1, int arg2);
public static native @Cast("SRTSOCKET") int srt_create_socket();
// Targeting ../SRT_SOCKGROUPDATA.java



// #if ENABLE_EXPERIMENTAL_BONDING

// #endif // ENABLE_EXPERIMENTAL_BONDING

public static native int srt_bind(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen);
public static native int srt_bind_acquire(@Cast("SRTSOCKET") int u, @Cast("UDPSOCKET") int sys_udp_sock);
// Old name of srt_bind_acquire(), please don't use
// Planned deprecation removal: rel1.6.0
public static native int srt_bind_peerof(@Cast("SRTSOCKET") int u, @Cast("UDPSOCKET") int sys_udp_sock);
public static native int srt_listen(@Cast("SRTSOCKET") int u, int backlog);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, IntPointer addrlen);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, IntBuffer addrlen);
public static native @Cast("SRTSOCKET") int srt_accept(@Cast("SRTSOCKET") int u, sockaddr addr, int[] addrlen);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") IntPointer listeners, int lsize, @Cast("int64_t") long msTimeOut);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") IntBuffer listeners, int lsize, @Cast("int64_t") long msTimeOut);
public static native @Cast("SRTSOCKET") int srt_accept_bond(@Cast("const SRTSOCKET*") int[] listeners, int lsize, @Cast("int64_t") long msTimeOut);
// Targeting ../srt_listen_callback_fn.java


public static native int srt_listen_callback(@Cast("SRTSOCKET") int lsn, srt_listen_callback_fn hook_fn, Pointer hook_opaque);
// Targeting ../srt_connect_callback_fn.java


public static native int srt_connect_callback(@Cast("SRTSOCKET") int clr, srt_connect_callback_fn hook_fn, Pointer hook_opaque);
public static native int srt_connect(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen);
public static native int srt_connect_debug(@Cast("SRTSOCKET") int u, @Const sockaddr name, int namelen, int forced_isn);
public static native int srt_connect_bind(@Cast("SRTSOCKET") int u, @Const sockaddr source,
                                    @Const sockaddr target, int len);
public static native int srt_rendezvous(@Cast("SRTSOCKET") int u, @Const sockaddr local_name, int local_namelen,
                                    @Const sockaddr remote_name, int remote_namelen);

public static native int srt_close(@Cast("SRTSOCKET") int u);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, IntPointer namelen);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, IntBuffer namelen);
public static native int srt_getpeername(@Cast("SRTSOCKET") int u, sockaddr name, int[] namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, IntPointer namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, IntBuffer namelen);
public static native int srt_getsockname(@Cast("SRTSOCKET") int u, sockaddr name, int[] namelen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, IntPointer optlen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, IntBuffer optlen);
public static native int srt_getsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, Pointer optval, int[] optlen);
public static native int srt_setsockopt(@Cast("SRTSOCKET") int u, int level, @Cast("SRT_SOCKOPT") int optname, @Const Pointer optval, int optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, IntPointer optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, IntBuffer optlen);
public static native int srt_getsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, Pointer optval, int[] optlen);
public static native int srt_setsockflag(@Cast("SRTSOCKET") int u, @Cast("SRT_SOCKOPT") int opt, @Const Pointer optval, int optlen);
// Targeting ../SRT_MSGCTRL.java



// Trap representation for sequence and message numbers
// This value means that this is "unset", and it's never
// a result of an operation made on this number.
@MemberGetter public static native int SRT_SEQNO_NONE();
public static final int SRT_SEQNO_NONE = SRT_SEQNO_NONE();    // -1: no seq (0 is a valid seqno!)
@MemberGetter public static native int SRT_MSGNO_NONE();
public static final int SRT_MSGNO_NONE = SRT_MSGNO_NONE();    // -1: unset
@MemberGetter public static native int SRT_MSGNO_CONTROL();
public static final int SRT_MSGNO_CONTROL = SRT_MSGNO_CONTROL();  //  0: control (used by packet filter)

@MemberGetter public static native int SRT_MSGTTL_INF();
public static final int SRT_MSGTTL_INF = SRT_MSGTTL_INF(); // unlimited TTL specification for message TTL

// XXX Might be useful also other special uses of -1:
// - -1 as infinity for srt_epoll_wait
// - -1 as a trap index value used in list.cpp

// You are free to use either of these two methods to set SRT_MSGCTRL object
// to default values: either call srt_msgctrl_init(&obj) or obj = srt_msgctrl_default.
public static native void srt_msgctrl_init(SRT_MSGCTRL mctrl);
@MemberGetter public static native @Const @ByRef SRT_MSGCTRL srt_msgctrl_default();

// The send/receive functions.
// These functions have different names due to different sets of parameters
// to be supplied. Not all of them are needed or make sense in all modes:

// Plain: supply only the buffer and its size.
// Msg: supply additionally
// - TTL (message is not delivered when exceeded) and
// - INORDER (when false, the message is allowed to be delivered in different
// order than when it was sent, when the later message is earlier ready to
// deliver)
// Msg2: Supply extra parameters in SRT_MSGCTRL. When receiving, these
// parameters will be filled, as needed. NULL is acceptable, in which case
// the defaults are used.

//
// Sending functions
//
public static native int srt_send(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len);
public static native int srt_send(@Cast("SRTSOCKET") int u, String buf, int len);
public static native int srt_sendmsg(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len, int ttl, int inorder);
public static native int srt_sendmsg(@Cast("SRTSOCKET") int u, String buf, int len, int ttl, int inorder);
public static native int srt_sendmsg2(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_sendmsg2(@Cast("SRTSOCKET") int u, String buf, int len, SRT_MSGCTRL mctrl);

//
// Receiving functions
//
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len);
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len);
public static native int srt_recv(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len);

// srt_recvmsg is actually an alias to srt_recv, it stays under the old name for compat reasons.
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len);
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len);
public static native int srt_recvmsg(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") BytePointer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") ByteBuffer buf, int len, SRT_MSGCTRL mctrl);
public static native int srt_recvmsg2(@Cast("SRTSOCKET") int u, @Cast("char*") byte[] buf, int len, SRT_MSGCTRL mctrl);


// Special send/receive functions for files only.
public static final int SRT_DEFAULT_SENDFILE_BLOCK = 364000;
public static final int SRT_DEFAULT_RECVFILE_BLOCK = 7280000;
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_sendfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") LongPointer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, @Cast("const char*") BytePointer path, @Cast("int64_t*") LongBuffer offset, @Cast("int64_t") long size, int block);
public static native @Cast("int64_t") long srt_recvfile(@Cast("SRTSOCKET") int u, String path, @Cast("int64_t*") long[] offset, @Cast("int64_t") long size, int block);


// last error detection
public static native @Cast("const char*") BytePointer srt_getlasterror_str();
public static native int srt_getlasterror(IntPointer errno_loc);
public static native int srt_getlasterror(IntBuffer errno_loc);
public static native int srt_getlasterror(int[] errno_loc);
public static native @Cast("const char*") BytePointer srt_strerror(int code, int errnoval);
public static native void srt_clearlasterror();

// Performance tracking
// Performance monitor with Byte counters for better bitrate estimation.
public static native int srt_bstats(@Cast("SRTSOCKET") int u, SRT_TRACEBSTATS perf, int clear);
// Performance monitor with Byte counters and instantaneous stats instead of moving averages for Snd/Rcvbuffer sizes.
public static native int srt_bistats(@Cast("SRTSOCKET") int u, SRT_TRACEBSTATS perf, int clear, int instantaneous);

// Socket Status (for problem tracking)
public static native @Cast("SRT_SOCKSTATUS") int srt_getsockstate(@Cast("SRTSOCKET") int u);

public static native int srt_epoll_create();
public static native int srt_epoll_clear_usocks(int eid);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntPointer events);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntBuffer events);
public static native int srt_epoll_add_usock(int eid, @Cast("SRTSOCKET") int u, @Const int[] events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntPointer events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntBuffer events);
public static native int srt_epoll_add_ssock(int eid, @Cast("SYSSOCKET") int s, @Const int[] events);
public static native int srt_epoll_remove_usock(int eid, @Cast("SRTSOCKET") int u);
public static native int srt_epoll_remove_ssock(int eid, @Cast("SYSSOCKET") int s);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntPointer events);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const IntBuffer events);
public static native int srt_epoll_update_usock(int eid, @Cast("SRTSOCKET") int u, @Const int[] events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntPointer events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const IntBuffer events);
public static native int srt_epoll_update_ssock(int eid, @Cast("SYSSOCKET") int s, @Const int[] events);

public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") IntPointer readfds, IntPointer rnum, @Cast("SRTSOCKET*") IntPointer writefds, IntPointer wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") IntPointer lrfds, IntPointer lrnum, @Cast("SYSSOCKET*") IntPointer lwfds, IntPointer lwnum);
public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") IntBuffer readfds, IntBuffer rnum, @Cast("SRTSOCKET*") IntBuffer writefds, IntBuffer wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") IntBuffer lrfds, IntBuffer lrnum, @Cast("SYSSOCKET*") IntBuffer lwfds, IntBuffer lwnum);
public static native int srt_epoll_wait(int eid, @Cast("SRTSOCKET*") int[] readfds, int[] rnum, @Cast("SRTSOCKET*") int[] writefds, int[] wnum, @Cast("int64_t") long msTimeOut,
                           @Cast("SYSSOCKET*") int[] lrfds, int[] lrnum, @Cast("SYSSOCKET*") int[] lwfds, int[] lwnum);
// Targeting ../SRT_EPOLL_EVENT.java


public static native int srt_epoll_uwait(int eid, SRT_EPOLL_EVENT fdsSet, int fdsSize, @Cast("int64_t") long msTimeOut);

public static native int srt_epoll_set(int eid, int flags);
public static native int srt_epoll_release(int eid);

// Logging control

public static native void srt_setloglevel(int ll);
public static native void srt_addlogfa(int fa);
public static native void srt_dellogfa(int fa);
public static native void srt_resetlogfa(@Const IntPointer fara, @Cast("size_t") long fara_size);
public static native void srt_resetlogfa(@Const IntBuffer fara, @Cast("size_t") long fara_size);
public static native void srt_resetlogfa(@Const int[] fara, @Cast("size_t") long fara_size);
// This isn't predicted, will be only available in SRT C++ API.
// For the time being, until this API is ready, use UDT::setlogstream.
// SRT_API void srt_setlogstream(std::ostream& stream);
public static native void srt_setloghandler(Pointer opaque, SRT_LOG_HANDLER_FN handler);
public static native void srt_setlogflags(int flags);


public static native int srt_getsndbuffer(@Cast("SRTSOCKET") int sock, @Cast("size_t*") SizeTPointer blocks, @Cast("size_t*") SizeTPointer bytes);

public static native int srt_getrejectreason(@Cast("SRTSOCKET") int sock);
public static native int srt_setrejectreason(@Cast("SRTSOCKET") int sock, int value);
@MemberGetter public static native @Cast("const char*") BytePointer srt_rejectreason_msg(int i);
@MemberGetter public static native @Cast("const char*const*") PointerPointer srt_rejectreason_msg();
public static native @Cast("const char*") BytePointer srt_rejectreason_str(int id);

public static native @Cast("uint32_t") int srt_getversion();

public static native @Cast("int64_t") long srt_time_now();

public static native @Cast("int64_t") long srt_connection_time(@Cast("SRTSOCKET") int sock);

// Possible internal clock types
public static final int SRT_SYNC_CLOCK_STDCXX_STEADY =      0; // C++11 std::chrono::steady_clock
public static final int SRT_SYNC_CLOCK_GETTIME_MONOTONIC =  1; // clock_gettime with CLOCK_MONOTONIC
public static final int SRT_SYNC_CLOCK_WINQPC =             2;
public static final int SRT_SYNC_CLOCK_MACH_ABSTIME =       3;
public static final int SRT_SYNC_CLOCK_POSIX_GETTIMEOFDAY = 4;
public static final int SRT_SYNC_CLOCK_AMD64_RDTSC =        5;
public static final int SRT_SYNC_CLOCK_IA32_RDTSC =         6;
public static final int SRT_SYNC_CLOCK_IA64_ITC =           7;

public static native int srt_clock_type();

// #ifdef __cplusplus
// #endif

// #endif


}
